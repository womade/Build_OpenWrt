From a14e2c52aa7001beb31b4ee25a57890aba4ee0ea Mon Sep 17 00:00:00 2001
From: John Crispin <john@phrozen.org>
Date: Tue, 4 Jan 2022 06:56:05 +0100
Subject: [PATCH 01/47] hostapd: backport latest HEAD

Signed-off-by: John Crispin <john@phrozen.org>
---
 package/network/services/hostapd/Makefile     |  25 +-
 .../services/hostapd/files/dhcp-get-server.sh |   2 +
 .../hostapd/files/hostapd-basic.config        |   3 +
 .../hostapd/files/hostapd-full.config         |   5 +-
 .../hostapd/files/hostapd-mini.config         |   3 +
 .../network/services/hostapd/files/hostapd.sh |  89 ++-
 .../hostapd/files/wpa_supplicant-full.config  |   2 +-
 .../hostapd/files/wpa_supplicant-p2p.config   |   2 +-
 .../services/hostapd/files/wps-hotplug.sh     |  21 +-
 ...-fix-frequency-setup-with-HE-enabled.patch | 196 -------
 ...> 001-wolfssl-init-RNG-with-ECC-key.patch} |   6 +-
 ...-init-order-disable-pri-sec-channel-.patch | 126 -----
 ...andle-HT40-and-mode-downgrade-in-AP-.patch | 102 ----
 ...ix-frequency-config-for-non-p2p-vht-.patch |  63 ---
 ...nable-vht-and-he-in-default-config-p.patch |  25 -
 ...er-debug-messages-for-some-error-cas.patch |  83 ---
 ...lper-functions-for-vht-he-parameters.patch |  27 -
 ...ompletion-callback-to-complete-mesh-.patch | 108 ----
 ...-frequency-as-pri-sec-channel-switch.patch |  26 -
 ...hannels-to-be-selected-if-dfs-is-ena.patch |  60 +-
 ...offchanok-on-DFS-channels-in-non-ETS.patch |  53 --
 ...rministic-channel-on-channel-switch.patch} |   6 +-
 ...-fix-channel-switch-error-during-CAC.patch |  66 ---
 ...rnel-driver-DFS-handler-in-userspace.patch |  48 --
 .../014-mesh-fixes-for-mesh-init-deinit.patch | 158 ------
 .../015-mesh-fix-DFS-deinit-init.patch        | 262 ---------
 ...sts-DFS-test-for-wpa_supplicant-mesh.patch |  94 ----
 .../patches/017-mesh-fix-mesh_oom-test.patch  |  24 -
 ...ve-mesh-freq-setting-to-own-function.patch |  93 ----
 ...020-ignore-4addr-mode-enabling-error.patch |  73 ---
 ...ix-sta-add-after-previous-connection.patch |  26 +
 ...use-of-uninitialized-stack-variables.patch |  25 +
 ...ewrite-neigh-code-to-not-depend-on-l.patch |  14 +-
 ...ssing-authentication-frames-in-block.patch |   8 +-
 .../hostapd/patches/050-build_fix.patch       |  20 +
 ...50-mesh-make-forwarding-configurable.patch | 219 --------
 ...-case-in-peer-addition-based-on-PD-R.patch |  45 --
 .../patches/110-notify-mgmt-frames.patch      | 116 ----
 .../patches/110-wolfssl-compile-fix.patch     |  10 -
 .../120-reconfigure-wps-credentials.patch     | 178 ------
 .../hostapd/patches/200-multicall.patch       |  80 +--
 .../services/hostapd/patches/300-noscan.patch |   6 +-
 .../hostapd/patches/301-mesh-noscan.patch     |  17 +-
 .../patches/310-rescan_immediately.patch      |   2 +-
 .../hostapd/patches/320-optional_rfkill.patch |   8 +-
 .../patches/330-nl80211_fix_set_freq.patch    |   2 +-
 .../patches/340-reload_freq_change.patch      |   6 +-
 .../341-mesh-ctrl-iface-channel-switch.patch  |   2 +-
 .../patches/350-nl80211_del_beacon_bss.patch  |  12 +-
 .../patches/360-ctrl_iface_reload.patch       |  10 +-
 .../hostapd/patches/370-ap_sta_support.patch  |  66 +--
 .../patches/380-disable_ctrl_iface_mib.patch  |  36 +-
 .../patches/390-wpa_ie_cap_workaround.patch   |   4 +-
 .../400-wps_single_auth_enc_type.patch        |   2 +-
 .../patches/420-indicate-features.patch       |   4 +-
 .../patches/430-hostapd_cli_ifdef.patch       |   4 +-
 ...dd-new-config-params-to-be-used-with.patch |  10 +-
 ...-use-new-parameters-during-ibss-join.patch |   4 +-
 .../patches/463-add-mcast_rate-to-11s.patch   |  10 +-
 .../patches/464-fix-mesh-obss-check.patch     |   2 +-
 .../patches/470-survey_data_fallback.patch    |  22 +-
 .../patches/500-lto-jobserver-support.patch   |  19 +-
 .../patches/590-rrm-wnm-statistics.patch      |  92 ++++
 .../hostapd/patches/600-ubus_support.patch    | 209 +++++--
 .../610-hostapd_cli_ujail_permission.patch    |  33 ++
 .../hostapd/patches/700-wifi-reload.patch     |  53 +-
 .../hostapd/patches/710-vlan_no_bridge.patch  |  24 +-
 .../patches/711-wds_bridge_force.patch        |   2 +-
 .../patches/720-iface_max_num_sta.patch       |  82 +++
 .../hostapd/patches/730-ft_iface.patch        |   6 +-
 .../hostapd/patches/740-snoop_iface.patch     |   4 +-
 ...750-qos_map_set_without_interworking.patch |  20 +-
 .../751-qos_map_ignore_when_unsupported.patch |  12 +
 ...ate-if-no-available-channel-is-found.patch |  37 --
 ...of-secondary-device-types-for-P2P-gr.patch |  33 --
 .../services/hostapd/src/src/ap/ubus.c        | 515 ++++++++++++++++--
 .../services/hostapd/src/src/ap/ubus.h        |  37 ++
 .../hostapd/src/src/utils/build_features.h    |   6 +-
 78 files changed, 1361 insertions(+), 2644 deletions(-)
 create mode 100644 package/network/services/hostapd/files/dhcp-get-server.sh
 delete mode 100644 package/network/services/hostapd/patches/001-HE-VHT-fix-frequency-setup-with-HE-enabled.patch
 rename package/network/services/hostapd/patches/{802-wolfssl-init-RNG-with-ECC-key.patch => 001-wolfssl-init-RNG-with-ECC-key.patch} (85%)
 delete mode 100644 package/network/services/hostapd/patches/002-mesh-fix-channel-init-order-disable-pri-sec-channel-.patch
 delete mode 100644 package/network/services/hostapd/patches/003-wpa_supplicant-handle-HT40-and-mode-downgrade-in-AP-.patch
 delete mode 100644 package/network/services/hostapd/patches/004-wpa_supplicant-fix-frequency-config-for-non-p2p-vht-.patch
 delete mode 100644 package/network/services/hostapd/patches/005-wpa_supplicant-enable-vht-and-he-in-default-config-p.patch
 delete mode 100644 package/network/services/hostapd/patches/006-hw_features-better-debug-messages-for-some-error-cas.patch
 delete mode 100644 package/network/services/hostapd/patches/007-dfs-use-helper-functions-for-vht-he-parameters.patch
 delete mode 100644 package/network/services/hostapd/patches/008-mesh-use-setup-completion-callback-to-complete-mesh-.patch
 delete mode 100644 package/network/services/hostapd/patches/009-mesh-update-ssid-frequency-as-pri-sec-channel-switch.patch
 delete mode 100644 package/network/services/hostapd/patches/011-mesh-do-not-set-offchanok-on-DFS-channels-in-non-ETS.patch
 rename package/network/services/hostapd/patches/{019-mesh-use-deterministic-channel-on-channel-switch.patch => 011-mesh-use-deterministic-channel-on-channel-switch.patch} (92%)
 delete mode 100644 package/network/services/hostapd/patches/012-mesh-fix-channel-switch-error-during-CAC.patch
 delete mode 100644 package/network/services/hostapd/patches/013-mesh-inform-kernel-driver-DFS-handler-in-userspace.patch
 delete mode 100644 package/network/services/hostapd/patches/014-mesh-fixes-for-mesh-init-deinit.patch
 delete mode 100644 package/network/services/hostapd/patches/015-mesh-fix-DFS-deinit-init.patch
 delete mode 100644 package/network/services/hostapd/patches/016-tests-DFS-test-for-wpa_supplicant-mesh.patch
 delete mode 100644 package/network/services/hostapd/patches/017-mesh-fix-mesh_oom-test.patch
 delete mode 100644 package/network/services/hostapd/patches/018-mesh-move-mesh-freq-setting-to-own-function.patch
 delete mode 100644 package/network/services/hostapd/patches/020-ignore-4addr-mode-enabling-error.patch
 create mode 100644 package/network/services/hostapd/patches/021-fix-sta-add-after-previous-connection.patch
 create mode 100644 package/network/services/hostapd/patches/022-hostapd-fix-use-of-uninitialized-stack-variables.patch
 create mode 100644 package/network/services/hostapd/patches/050-build_fix.patch
 delete mode 100644 package/network/services/hostapd/patches/050-mesh-make-forwarding-configurable.patch
 delete mode 100644 package/network/services/hostapd/patches/060-P2P-Fix-a-corner-case-in-peer-addition-based-on-PD-R.patch
 delete mode 100644 package/network/services/hostapd/patches/110-notify-mgmt-frames.patch
 delete mode 100644 package/network/services/hostapd/patches/110-wolfssl-compile-fix.patch
 delete mode 100644 package/network/services/hostapd/patches/120-reconfigure-wps-credentials.patch
 create mode 100644 package/network/services/hostapd/patches/590-rrm-wnm-statistics.patch
 create mode 100644 package/network/services/hostapd/patches/610-hostapd_cli_ujail_permission.patch
 create mode 100644 package/network/services/hostapd/patches/720-iface_max_num_sta.patch
 create mode 100644 package/network/services/hostapd/patches/751-qos_map_ignore_when_unsupported.patch
 delete mode 100644 package/network/services/hostapd/patches/800-dfs-enter-DFS-state-if-no-available-channel-is-found.patch
 delete mode 100644 package/network/services/hostapd/patches/801-P2P-Fix-copying-of-secondary-device-types-for-P2P-gr.patch

diff --git a/package/network/services/hostapd/Makefile b/package/network/services/hostapd/Makefile
index 783c10d587..584695786f 100644
--- a/package/network/services/hostapd/Makefile
+++ b/package/network/services/hostapd/Makefile
@@ -1,19 +1,17 @@
-# Copyright (C) 2006-2014 OpenWrt.org
-#
-# This is free software, licensed under the GNU General Public License v2.
-# See /LICENSE for more information.
+# SPDX-License-Identifier: GPL-2.0-only
 #
+# Copyright (C) 2006-2021 OpenWrt.org
 
 include $(TOPDIR)/rules.mk
 
 PKG_NAME:=hostapd
-PKG_RELEASE:=37
+PKG_RELEASE:=$(AUTORELEASE)
 
 PKG_SOURCE_URL:=http://w1.fi/hostap.git
 PKG_SOURCE_PROTO:=git
-PKG_SOURCE_DATE:=2020-06-08
-PKG_SOURCE_VERSION:=5a8b366233f5585e68a4ffbb604fbb4a848eb325
-PKG_MIRROR_HASH:=1b2a4947034142587a3f81eac2ea27dd64650e77f8943d973623b47533be2393
+PKG_SOURCE_DATE:=2022-01-16
+PKG_SOURCE_VERSION:=cff80b4f7d3c0a47c052e8187d671710f48939e4
+PKG_MIRROR_HASH:=712965bfa11a2e601d3e1c9a51a2cf3cffc6db89abafb3df3eb0cfd83c64705b
 
 PKG_MAINTAINER:=Felix Fietkau <nbd@nbd.name>
 PKG_LICENSE:=BSD-3-Clause
@@ -145,6 +143,7 @@ define Package/hostapd/Default
   TITLE:=IEEE 802.1x Authenticator
   URL:=http://hostap.epitest.fi/
   DEPENDS:=$(DRV_DEPENDS) +hostapd-common +libubus
+  EXTRA_DEPENDS:=hostapd-common (=$(PKG_VERSION)-$(PKG_RELEASE))
   USERID:=network=101:network=101
   PROVIDES:=hostapd
   CONFLICTS:=$(HOSTAPD_PROVIDERS)
@@ -229,6 +228,7 @@ define Package/wpad/Default
   SUBMENU:=WirelessAPD
   TITLE:=IEEE 802.1x Auth/Supplicant
   DEPENDS:=$(DRV_DEPENDS) +hostapd-common +libubus
+  EXTRA_DEPENDS:=hostapd-common (=$(PKG_VERSION)-$(PKG_RELEASE))
   USERID:=network=101:network=101
   URL:=http://hostap.epitest.fi/
   PROVIDES:=hostapd wpa-supplicant
@@ -344,6 +344,7 @@ define Package/wpa-supplicant/Default
   TITLE:=WPA Supplicant
   URL:=http://hostap.epitest.fi/wpa_supplicant/
   DEPENDS:=$(DRV_DEPENDS) +hostapd-common +libubus
+  EXTRA_DEPENDS:=hostapd-common (=$(PKG_VERSION)-$(PKG_RELEASE))
   USERID:=network=101:network=101
   PROVIDES:=wpa-supplicant
   CONFLICTS:=$(SUPPLICANT_PROVIDERS)
@@ -428,6 +429,7 @@ define Package/hostapd-utils
   TITLE:=IEEE 802.1x Authenticator (utils)
   URL:=http://hostap.epitest.fi/
   DEPENDS:=@$(subst $(space),||,$(foreach pkg,$(HOSTAPD_PROVIDERS),PACKAGE_$(pkg)))
+  VARIANT:=*
 endef
 
 define Package/hostapd-utils/description
@@ -441,6 +443,7 @@ define Package/wpa-cli
   SUBMENU:=WirelessAPD
   DEPENDS:=@$(subst $(space),||,$(foreach pkg,$(SUPPLICANT_PROVIDERS),PACKAGE_$(pkg)))
   TITLE:=WPA Supplicant command line control utility
+  VARIANT:=*
 endef
 
 define Package/eapol-test/Default
@@ -524,6 +527,7 @@ define Build/RunMake
 		LIBS_c="$(TARGET_LDFLAGS_C)" \
 		AR="$(TARGET_CROSS)gcc-ar" \
 		BCHECK= \
+		$(if $(findstring s,$(OPENWRT_VERBOSE)),V=1) \
 		$(2)
 endef
 
@@ -597,6 +601,7 @@ endef
 
 define Package/hostapd-common/install
 	$(INSTALL_DIR) $(1)/etc/capabilities $(1)/etc/rc.button $(1)/etc/hotplug.d/ieee80211 $(1)/etc/init.d $(1)/lib/netifd  $(1)/usr/share/acl.d
+	$(INSTALL_BIN) ./files/dhcp-get-server.sh $(1)/lib/netifd/dhcp-get-server.sh
 	$(INSTALL_DATA) ./files/hostapd.sh $(1)/lib/netifd/hostapd.sh
 	$(INSTALL_BIN) ./files/wpad.init $(1)/etc/init.d/wpad
 	$(INSTALL_BIN) ./files/wps-hotplug.sh $(1)/etc/rc.button/wps
@@ -678,6 +683,9 @@ ifeq ($(BUILD_VARIANT),supplicant-full-wolfssl)
   endef
 endif
 
+# Build hostapd-common before its dependents, to avoid
+# spurious rebuilds when building multiple variants.
+$(eval $(call BuildPackage,hostapd-common))
 $(eval $(call BuildPackage,hostapd))
 $(eval $(call BuildPackage,hostapd-basic))
 $(eval $(call BuildPackage,hostapd-basic-openssl))
@@ -704,7 +712,6 @@ $(eval $(call BuildPackage,wpa-supplicant-openssl))
 $(eval $(call BuildPackage,wpa-supplicant-wolfssl))
 $(eval $(call BuildPackage,wpa-cli))
 $(eval $(call BuildPackage,hostapd-utils))
-$(eval $(call BuildPackage,hostapd-common))
 $(eval $(call BuildPackage,eapol-test))
 $(eval $(call BuildPackage,eapol-test-openssl))
 $(eval $(call BuildPackage,eapol-test-wolfssl))
diff --git a/package/network/services/hostapd/files/dhcp-get-server.sh b/package/network/services/hostapd/files/dhcp-get-server.sh
new file mode 100644
index 0000000000..a1509ace2f
--- /dev/null
+++ b/package/network/services/hostapd/files/dhcp-get-server.sh
@@ -0,0 +1,2 @@
+#!/bin/sh
+[ "$1" = bound ] && echo "$serverid"
diff --git a/package/network/services/hostapd/files/hostapd-basic.config b/package/network/services/hostapd/files/hostapd-basic.config
index 33c38192b1..1f52546d57 100644
--- a/package/network/services/hostapd/files/hostapd-basic.config
+++ b/package/network/services/hostapd/files/hostapd-basic.config
@@ -386,6 +386,9 @@ CONFIG_TLS=internal
 # Airtime policy support
 CONFIG_AIRTIME_POLICY=y
 
+# Proxy ARP support
+#CONFIG_PROXYARP=y
+
 # Override default value for the wpa_disable_eapol_key_retries configuration
 # parameter. See that parameter in hostapd.conf for more details.
 #CFLAGS += -DDEFAULT_WPA_DISABLE_EAPOL_KEY_RETRIES=1
diff --git a/package/network/services/hostapd/files/hostapd-full.config b/package/network/services/hostapd/files/hostapd-full.config
index df272e443a..dbc2022550 100644
--- a/package/network/services/hostapd/files/hostapd-full.config
+++ b/package/network/services/hostapd/files/hostapd-full.config
@@ -60,7 +60,7 @@ CONFIG_RSN_PREAUTH=y
 CONFIG_EAP=y
 
 # EAP Re-authentication Protocol (ERP) in integrated EAP server
-#CONFIG_ERP=y
+CONFIG_ERP=y
 
 # EAP-MD5 for the integrated EAP server
 CONFIG_EAP_MD5=y
@@ -386,6 +386,9 @@ CONFIG_TAXONOMY=y
 # Airtime policy support
 CONFIG_AIRTIME_POLICY=y
 
+# Proxy ARP support
+CONFIG_PROXYARP=y
+
 # Override default value for the wpa_disable_eapol_key_retries configuration
 # parameter. See that parameter in hostapd.conf for more details.
 #CFLAGS += -DDEFAULT_WPA_DISABLE_EAPOL_KEY_RETRIES=1
diff --git a/package/network/services/hostapd/files/hostapd-mini.config b/package/network/services/hostapd/files/hostapd-mini.config
index b3050f7bbc..f2ed071ec0 100644
--- a/package/network/services/hostapd/files/hostapd-mini.config
+++ b/package/network/services/hostapd/files/hostapd-mini.config
@@ -386,6 +386,9 @@ CONFIG_TLS=internal
 # Airtime policy support
 #CONFIG_AIRTIME_POLICY=y
 
+# Proxy ARP support
+#CONFIG_PROXYARP=y
+
 # Override default value for the wpa_disable_eapol_key_retries configuration
 # parameter. See that parameter in hostapd.conf for more details.
 #CFLAGS += -DDEFAULT_WPA_DISABLE_EAPOL_KEY_RETRIES=1
diff --git a/package/network/services/hostapd/files/hostapd.sh b/package/network/services/hostapd/files/hostapd.sh
index b52667d09a..d9d5f34877 100644
--- a/package/network/services/hostapd/files/hostapd.sh
+++ b/package/network/services/hostapd/files/hostapd.sh
@@ -72,6 +72,15 @@ hostapd_append_wpa_key_mgmt() {
 		;;
 	esac
 
+	[ "$fils" -gt 0 ] && {
+		case "$auth_type" in
+			eap*)
+				append wpa_key_mgmt FILS-SHA256
+				[ "${ieee80211r:-0}" -gt 0 ] && append wpa_key_mgmt FT-FILS-SHA256
+			;;
+		esac
+	}
+
 	[ "$auth_osen" = "1" ] && append wpa_key_mgmt "OSEN"
 }
 
@@ -101,6 +110,9 @@ hostapd_common_add_device_config() {
 	config_add_boolean legacy_rates
 	config_add_int cell_density
 	config_add_int rts_threshold
+	config_add_int rssi_reject_assoc_rssi
+	config_add_int rssi_ignore_probe_request
+	config_add_int maxassoc
 
 	config_add_string acs_chan_bias
 	config_add_array hostapd_options
@@ -118,7 +130,7 @@ hostapd_prepare_device_config() {
 
 	json_get_vars country country3 country_ie beacon_int:100 dtim_period:2 doth require_mode legacy_rates \
 		acs_chan_bias local_pwr_constraint spectrum_mgmt_required airtime_mode cell_density \
-		rts_threshold beacon_rate
+		rts_threshold beacon_rate rssi_reject_assoc_rssi rssi_ignore_probe_request maxassoc
 
 	hostapd_set_log_options base_cfg
 
@@ -210,6 +222,8 @@ hostapd_prepare_device_config() {
 		hostapd_add_rate brlist "$br"
 	done
 
+	[ -n "$rssi_reject_assoc_rssi" ] && append base_cfg "rssi_reject_assoc_rssi=$rssi_reject_assoc_rssi" "$N"
+	[ -n "$rssi_ignore_probe_request" ] && append base_cfg "rssi_ignore_probe_request=$rssi_ignore_probe_request" "$N"
 	[ -n "$beacon_rate" ] && append base_cfg "beacon_rate=$beacon_rate" "$N"
 	[ -n "$rlist" ] && append base_cfg "supported_rates=$rlist" "$N"
 	[ -n "$brlist" ] && append base_cfg "basic_rates=$brlist" "$N"
@@ -217,6 +231,7 @@ hostapd_prepare_device_config() {
 	[ -n "$rts_threshold" ] && append base_cfg "rts_threshold=$rts_threshold" "$N"
 	append base_cfg "dtim_period=$dtim_period" "$N"
 	[ "$airtime_mode" -gt 0 ] && append base_cfg "airtime_mode=$airtime_mode" "$N"
+	[ -n "$maxassoc" ] && append base_cfg "iface_max_num_sta=$maxassoc" "$N"
 
 	json_get_values opts hostapd_options
 	for val in $opts; do
@@ -317,6 +332,7 @@ hostapd_common_add_bss_config() {
 	config_add_array supported_rates
 
 	config_add_boolean sae_require_mfp
+	config_add_int sae_pwe
 
 	config_add_string 'owe_transition_bssid:macaddr' 'owe_transition_ssid:string'
 
@@ -341,9 +357,10 @@ hostapd_common_add_bss_config() {
 	config_add_array airtime_sta_weight
 	config_add_int airtime_bss_weight airtime_bss_limit
 
-	config_add_boolean multicast_to_unicast per_sta_vif
+	config_add_boolean multicast_to_unicast proxy_arp per_sta_vif
 
 	config_add_array hostapd_bss_options
+	config_add_boolean default_disabled
 
 	config_add_boolean request_cui
 	config_add_array radius_auth_req_attr
@@ -351,6 +368,9 @@ hostapd_common_add_bss_config() {
 
 	config_add_int eap_server
 	config_add_string eap_user_file ca_cert server_cert private_key private_key_passwd server_id
+
+	config_add_boolean fils
+	config_add_string fils_dhcp
 }
 
 hostapd_set_vlan_file() {
@@ -488,11 +508,11 @@ append_hs20_conn_capab() {
 }
 
 append_radius_acct_req_attr() {
-	append bss_conf "radius_acct_req_attr=$1" "$N"
+	[ -n "$1" ] && append bss_conf "radius_acct_req_attr=$1" "$N"
 }
 
 append_radius_auth_req_attr() {
-	append bss_conf "radius_auth_req_attr=$1" "$N"
+	[ -n "$1" ] && append bss_conf "radius_auth_req_attr=$1" "$N"
 }
 
 append_airtime_sta_weight() {
@@ -518,13 +538,14 @@ hostapd_set_bss_options() {
 		macfilter ssid utf8_ssid wmm uapsd hidden short_preamble rsn_preauth \
 		iapp_interface eapol_version dynamic_vlan ieee80211w nasid \
 		acct_server acct_secret acct_port acct_interval \
-		bss_load_update_period chan_util_avg_period sae_require_mfp \
+		bss_load_update_period chan_util_avg_period sae_require_mfp sae_pwe \
 		multi_ap multi_ap_backhaul_ssid multi_ap_backhaul_key skip_inactivity_poll \
 		airtime_bss_weight airtime_bss_limit airtime_sta_weight \
-		multicast_to_unicast per_sta_vif \
+		multicast_to_unicast proxy_arp per_sta_vif \
 		eap_server eap_user_file ca_cert server_cert private_key private_key_passwd server_id \
-		vendor_elements
+		vendor_elements fils
 
+	set_default fils 0
 	set_default isolate 0
 	set_default maxassoc 0
 	set_default max_inactivity 0
@@ -546,6 +567,8 @@ hostapd_set_bss_options() {
 	set_default airtime_bss_limit 0
 	set_default eap_server 0
 
+	/usr/sbin/hostapd -vfils || fils=0
+
 	append bss_conf "ctrl_interface=/var/run/hostapd"
 	if [ "$isolate" -gt 0 ]; then
 		append bss_conf "ap_isolate=$isolate" "$N"
@@ -604,6 +627,7 @@ hostapd_set_bss_options() {
 		;;
 	esac
 	[ -n "$sae_require_mfp" ] && append bss_conf "sae_require_mfp=$sae_require_mfp" "$N"
+	[ -n "$sae_pwe" ] && append bss_conf "sae_pwe=$sae_pwe" "$N"
 
 	local vlan_possible=""
 
@@ -645,7 +669,9 @@ hostapd_set_bss_options() {
 				auth_server auth_secret auth_port \
 				dae_client dae_secret dae_port \
 				ownip radius_client_addr \
-				eap_reauth_period request_cui
+				eap_reauth_period request_cui \
+				erp_domain mobility_domain \
+				fils_realm fils_dhcp
 
 			# radius can provide VLAN ID for clients
 			vlan_possible=1
@@ -655,6 +681,30 @@ hostapd_set_bss_options() {
 			[ -n "$auth_port" ] || json_get_var auth_port port
 			[ -n "$auth_secret" ] || json_get_var auth_secret key
 
+			[ "$fils" -gt 0 ] && {
+				set_default erp_domain "$mobility_domain"
+				set_default erp_domain "$(echo "$ssid" | md5sum | head -c 8)"
+				set_default fils_realm "$erp_domain"
+
+				append bss_conf "erp_send_reauth_start=1" "$N"
+				append bss_conf "erp_domain=$erp_domain" "$N"
+				append bss_conf "fils_realm=$fils_realm" "$N"
+				append bss_conf "fils_cache_id=$(echo "$fils_realm" | md5sum | head -c 4)" "$N"
+
+				[ "$fils_dhcp" = "*" ] && {
+					json_get_values network network
+					fils_dhcp=
+					for net in $network; do
+						fils_dhcp="$(ifstatus "$net" | jsonfilter -e '@.data.dhcpserver')"
+						[ -n "$fils_dhcp" ] && break
+					done
+
+					[ -z "$fils_dhcp" -a -n "$network_bridge" -a -n "$network_ifname" ] && \
+						fils_dhcp="$(udhcpc -B -n -q -s /lib/netifd/dhcp-get-server.sh -t 1 -i "$network_ifname" 2>/dev/null)"
+				}
+				[ -n "$fils_dhcp" ] && append bss_conf "dhcp_server=$fils_dhcp" "$N"
+			}
+
 			set_default auth_port 1812
 			set_default dae_port 3799
 			set_default request_cui 0
@@ -844,6 +894,10 @@ hostapd_set_bss_options() {
 				done
 			fi
 		fi
+		if [ "$fils" -gt 0 ]; then
+			json_get_vars fils_realm
+			set_default fils_realm "$(echo "$ssid" | md5sum | head -c 8)"
+		fi
 
 		append bss_conf "wpa_disable_eapol_key_retries=$wpa_disable_eapol_key_retries" "$N"
 
@@ -868,7 +922,7 @@ hostapd_set_bss_options() {
 		fi
 
 		append bss_conf "okc=$auth_cache" "$N"
-		[ "$auth_cache" = 0 ] && append bss_conf "disable_pmksa_caching=1" "$N"
+		[ "$auth_cache" = 0 -a "$fils" = 0 ] && append bss_conf "disable_pmksa_caching=1" "$N"
 
 		# RSN -> allow management frame protection
 		case "$ieee80211w" in
@@ -1022,6 +1076,7 @@ hostapd_set_bss_options() {
 
 	if [ "$eap_server" = "1" ]; then
 		append bss_conf "eap_server=1" "$N"
+		append bss_conf "eap_server_erp=1" "$N"
 		[ -n "$eap_user_file" ] && append bss_conf "eap_user_file=$eap_user_file" "$N"
 		[ -n "$ca_cert" ] && append bss_conf "ca_cert=$ca_cert" "$N"
 		[ -n "$server_cert" ] && append bss_conf "server_cert=$server_cert" "$N"
@@ -1034,6 +1089,10 @@ hostapd_set_bss_options() {
 	if [ "$multicast_to_unicast" -gt 0 ]; then
 		append bss_conf "multicast_to_unicast=$multicast_to_unicast" "$N"
 	fi
+	set_default proxy_arp 0
+	if [ "$proxy_arp" -gt 0 ]; then
+		append bss_conf "proxy_arp=$proxy_arp" "$N"
+	fi
 
 	set_default per_sta_vif 0
 	if [ "$per_sta_vif" -gt 0 ]; then
@@ -1184,8 +1243,9 @@ wpa_supplicant_add_network() {
 	json_get_vars \
 		ssid bssid key \
 		basic_rate mcast_rate \
-		ieee80211w ieee80211r \
-		multi_ap
+		ieee80211w ieee80211r fils \
+		multi_ap \
+		default_disabled
 
 	case "$auth_type" in
 		sae|owe|eap192|eap-eap192)
@@ -1198,6 +1258,7 @@ wpa_supplicant_add_network() {
 
 	set_default ieee80211r 0
 	set_default multi_ap 0
+	set_default default_disabled 0
 
 	local key_mgmt='NONE'
 	local network_data=
@@ -1229,7 +1290,10 @@ wpa_supplicant_add_network() {
 		scan_ssid=""
 	}
 
-	[ "$multi_ap" = 1 -a "$_w_mode" = "sta" ] && append network_data "multi_ap_backhaul_sta=1" "$N$T"
+	[ "$_w_mode" = "sta" ] && {
+		[ "$multi_ap" = 1 ] && append network_data "multi_ap_backhaul_sta=1" "$N$T"
+		[ "$default_disabled" = 1 ] && append network_data "disabled=1" "$N$T"
+	}
 
 	case "$auth_type" in
 		none) ;;
@@ -1271,6 +1335,7 @@ wpa_supplicant_add_network() {
 
 			json_get_vars eap_type identity anonymous_identity ca_cert ca_cert_usesystem
 
+			[ "$fils" -gt 0 ] && append network_data "erp=1" "$N$T"
 			if [ "$ca_cert_usesystem" -eq "1" -a -f "/etc/ssl/certs/ca-certificates.crt" ]; then
 				append network_data "ca_cert=\"/etc/ssl/certs/ca-certificates.crt\"" "$N$T"
 			else
diff --git a/package/network/services/hostapd/files/wpa_supplicant-full.config b/package/network/services/hostapd/files/wpa_supplicant-full.config
index b3e85d073d..de3302c875 100644
--- a/package/network/services/hostapd/files/wpa_supplicant-full.config
+++ b/package/network/services/hostapd/files/wpa_supplicant-full.config
@@ -578,7 +578,7 @@ CONFIG_HS20=y
 #CONFIG_MBO=y
 
 # Fast Initial Link Setup (FILS) (IEEE 802.11ai)
-#CONFIG_FILS=y
+CONFIG_FILS=y
 # FILS shared key authentication with PFS
 #CONFIG_FILS_SK_PFS=y
 
diff --git a/package/network/services/hostapd/files/wpa_supplicant-p2p.config b/package/network/services/hostapd/files/wpa_supplicant-p2p.config
index b00847a256..48302bb4c3 100644
--- a/package/network/services/hostapd/files/wpa_supplicant-p2p.config
+++ b/package/network/services/hostapd/files/wpa_supplicant-p2p.config
@@ -578,7 +578,7 @@ CONFIG_P2P=y
 #CONFIG_MBO=y
 
 # Fast Initial Link Setup (FILS) (IEEE 802.11ai)
-#CONFIG_FILS=y
+CONFIG_FILS=y
 # FILS shared key authentication with PFS
 #CONFIG_FILS_SK_PFS=y
 
diff --git a/package/network/services/hostapd/files/wps-hotplug.sh b/package/network/services/hostapd/files/wps-hotplug.sh
index d00939d769..073bdd1868 100644
--- a/package/network/services/hostapd/files/wps-hotplug.sh
+++ b/package/network/services/hostapd/files/wps-hotplug.sh
@@ -38,13 +38,20 @@ wps_catch_credentials() {
 	done
 }
 
-if [ "$ACTION" = "pressed" -a "$BUTTON" = "wps" ]; then
-	wps_done=0
-	ubusobjs="$( ubus -S list hostapd.* )"
-	for ubusobj in $ubusobjs; do
-		ubus -S call $ubusobj wps_start && wps_done=1
-	done
-	[ $wps_done = 0 ] || return 0
+if [ "$ACTION" = "released" ] && [ "$BUTTON" = "wps" ]; then
+	# If the button was pressed for 3 seconds or more, trigger WPS on
+	# wpa_supplicant only, no matter if hostapd is running or not.  If
+	# was pressed for less than 3 seconds, try triggering on
+	# hostapd. If there is no hostapd instance to trigger it on or WPS
+	# is not enabled on them, trigger it on wpa_supplicant.
+	if [ "$SEEN" -lt 3 ] ; then
+		wps_done=0
+		ubusobjs="$( ubus -S list hostapd.* )"
+		for ubusobj in $ubusobjs; do
+			ubus -S call $ubusobj wps_start && wps_done=1
+		done
+		[ $wps_done = 0 ] || return 0
+	fi
 	wps_done=0
 	ubusobjs="$( ubus -S list wpa_supplicant.* )"
 	for ubusobj in $ubusobjs; do
diff --git a/package/network/services/hostapd/patches/001-HE-VHT-fix-frequency-setup-with-HE-enabled.patch b/package/network/services/hostapd/patches/001-HE-VHT-fix-frequency-setup-with-HE-enabled.patch
deleted file mode 100644
index 37c17c50af..0000000000
--- a/package/network/services/hostapd/patches/001-HE-VHT-fix-frequency-setup-with-HE-enabled.patch
+++ /dev/null
@@ -1,196 +0,0 @@
-From 91976250359b263a44861aebe553b20627fe487e Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 13:53:17 +0200
-Subject: [PATCH 01/19] HE/VHT: fix frequency setup with HE enabled
-
-Some places in the code base were not using the
-wrappers like hostapd_set_oper_centr_freq_seg0_idx
-and friends. This could lead to errors, for example when
-joining 80 MHz mesh networks. Fix this, by enforcing
-usage of these wrappers.
-
-wpa_supplicant_conf_ap_ht now checks for HE capability
-before dealing with VHT in order for these wrappers to work,
-as they first check HE support in the config.
-
-While doing these changes, I've noticed that the extra
-channel setup code for mesh networks in wpa_supplicant/mesh.c
-should not be necessary anymore and dropped it.
-wpa_supplicant_conf_ap_ht should handle this setup already.
-
-Acked-by: John Crispin <john@phrozen.org>
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- src/ap/dfs.c          |  8 ++++----
- wpa_supplicant/ap.c   | 40 +++++++++++++++++++++++-----------------
- wpa_supplicant/mesh.c | 24 ------------------------
- 3 files changed, 27 insertions(+), 45 deletions(-)
-
---- a/src/ap/dfs.c
-+++ b/src/ap/dfs.c
-@@ -1028,7 +1028,7 @@ static int hostapd_dfs_start_channel_swi
- 	unsigned int i;
- 	int err = 1;
- 	struct hostapd_hw_modes *cmode = iface->current_mode;
--	u8 current_vht_oper_chwidth = iface->conf->vht_oper_chwidth;
-+	u8 current_vht_oper_chwidth = hostapd_get_oper_chwidth(iface->conf);
- 
- 	wpa_printf(MSG_DEBUG, "%s called (CAC active: %s, CSA active: %s)",
- 		   __func__, iface->cac_started ? "yes" : "no",
-@@ -1089,8 +1089,8 @@ static int hostapd_dfs_start_channel_swi
- 		"freq=%d chan=%d sec_chan=%d", channel->freq,
- 		channel->chan, secondary_channel);
- 
--	new_vht_oper_chwidth = iface->conf->vht_oper_chwidth;
--	iface->conf->vht_oper_chwidth = current_vht_oper_chwidth;
-+	new_vht_oper_chwidth = hostapd_get_oper_chwidth(iface->conf);
-+	hostapd_set_oper_chwidth(iface->conf, current_vht_oper_chwidth);
- 
- 	/* Setup CSA request */
- 	os_memset(&csa_settings, 0, sizeof(csa_settings));
-@@ -1130,7 +1130,7 @@ static int hostapd_dfs_start_channel_swi
- 		iface->freq = channel->freq;
- 		iface->conf->channel = channel->chan;
- 		iface->conf->secondary_channel = secondary_channel;
--		iface->conf->vht_oper_chwidth = new_vht_oper_chwidth;
-+		hostapd_set_oper_chwidth(iface->conf, new_vht_oper_chwidth);
- 		hostapd_set_oper_centr_freq_seg0_idx(iface->conf,
- 						     oper_centr_freq_seg0_idx);
- 		hostapd_set_oper_centr_freq_seg1_idx(iface->conf,
---- a/wpa_supplicant/ap.c
-+++ b/wpa_supplicant/ap.c
-@@ -52,6 +52,7 @@ static void wpas_conf_ap_vht(struct wpa_
- #ifdef CONFIG_P2P
- 	u8 center_chan = 0;
- 	u8 channel = conf->channel;
-+	u8 freq_seg_idx;
- #endif /* CONFIG_P2P */
- 
- 	if (!conf->secondary_channel)
-@@ -59,19 +60,21 @@ static void wpas_conf_ap_vht(struct wpa_
- 
- 	/* Use the maximum oper channel width if it's given. */
- 	if (ssid->max_oper_chwidth)
--		conf->vht_oper_chwidth = ssid->max_oper_chwidth;
-+		hostapd_set_oper_chwidth(conf, ssid->max_oper_chwidth);
- 
- 	ieee80211_freq_to_chan(ssid->vht_center_freq2,
--			       &conf->vht_oper_centr_freq_seg1_idx);
-+			       &freq_seg_idx);
-+	hostapd_set_oper_centr_freq_seg1_idx(conf, freq_seg_idx);
- 
- 	if (!ssid->p2p_group) {
- 		if (!ssid->vht_center_freq1 ||
--		    conf->vht_oper_chwidth == CHANWIDTH_USE_HT)
-+		    hostapd_get_oper_chwidth(conf) == CHANWIDTH_USE_HT)
- 			goto no_vht;
- 		ieee80211_freq_to_chan(ssid->vht_center_freq1,
--				       &conf->vht_oper_centr_freq_seg0_idx);
-+				       &freq_seg_idx);
-+		hostapd_set_oper_centr_freq_seg0_idx(conf, freq_seg_idx);
- 		wpa_printf(MSG_DEBUG, "VHT seg0 index %d for AP",
--			   conf->vht_oper_centr_freq_seg0_idx);
-+			   hostapd_get_oper_centr_freq_seg0_idx(conf));
- 		return;
- 	}
- 
-@@ -96,14 +99,14 @@ static void wpas_conf_ap_vht(struct wpa_
- 		 * try oper_cwidth 160 MHz first then VHT 80 MHz, if 160 MHz is
- 		 * not supported.
- 		 */
--		conf->vht_oper_chwidth = CHANWIDTH_160MHZ;
-+		hostapd_set_oper_chwidth(conf, CHANWIDTH_160MHZ);
- 		center_chan = wpas_p2p_get_vht160_center(wpa_s, mode, channel);
- 		if (center_chan) {
- 			wpa_printf(MSG_DEBUG,
- 				   "VHT center channel %u for auto-selected 160 MHz bandwidth",
- 				   center_chan);
- 		} else {
--			conf->vht_oper_chwidth = CHANWIDTH_80MHZ;
-+			hostapd_set_oper_chwidth(conf, CHANWIDTH_80MHZ);
- 			center_chan = wpas_p2p_get_vht80_center(wpa_s, mode,
- 								channel);
- 			wpa_printf(MSG_DEBUG,
-@@ -115,9 +118,9 @@ static void wpas_conf_ap_vht(struct wpa_
- 	if (!center_chan)
- 		goto no_vht;
- 
--	conf->vht_oper_centr_freq_seg0_idx = center_chan;
-+	hostapd_set_oper_centr_freq_seg0_idx(conf, center_chan);
- 	wpa_printf(MSG_DEBUG, "VHT seg0 index %d for P2P GO",
--		   conf->vht_oper_centr_freq_seg0_idx);
-+		   hostapd_get_oper_centr_freq_seg0_idx(conf));
- 	return;
- #endif /* CONFIG_P2P */
- 
-@@ -125,9 +128,9 @@ no_vht:
- 	wpa_printf(MSG_DEBUG,
- 		   "No VHT higher bandwidth support for the selected channel %d",
- 		   conf->channel);
--	conf->vht_oper_centr_freq_seg0_idx =
--		conf->channel + conf->secondary_channel * 2;
--	conf->vht_oper_chwidth = CHANWIDTH_USE_HT;
-+	hostapd_set_oper_centr_freq_seg0_idx(conf,
-+					     conf->channel + conf->secondary_channel * 2);
-+	hostapd_set_oper_chwidth(conf, CHANWIDTH_USE_HT);
- }
- 
- 
-@@ -231,16 +234,19 @@ int wpa_supplicant_conf_ap_ht(struct wpa
- 				 HT_CAP_INFO_TX_STBC |
- 				 HT_CAP_INFO_MAX_AMSDU_SIZE);
- 
-+			/* check this before VHT, because setting oper chan
-+			 * width and friends is the same call for HE and VHT
-+			 * and checks if conf->ieee8021ax == 1 */
-+			if (mode->he_capab[wpas_mode_to_ieee80211_mode(
-+					    ssid->mode)].he_supported &&
-+			    ssid->he)
-+				conf->ieee80211ax = 1;
-+
- 			if (mode->vht_capab && ssid->vht) {
- 				conf->ieee80211ac = 1;
- 				conf->vht_capab |= mode->vht_capab;
- 				wpas_conf_ap_vht(wpa_s, ssid, conf, mode);
- 			}
--
--			if (mode->he_capab[wpas_mode_to_ieee80211_mode(
--					    ssid->mode)].he_supported &&
--			    ssid->he)
--				conf->ieee80211ax = 1;
- 		}
- 	}
- 
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -333,30 +333,6 @@ static int wpa_supplicant_mesh_init(stru
- 			   frequency);
- 		goto out_free;
- 	}
--	if (ssid->ht40)
--		conf->secondary_channel = ssid->ht40;
--	if (conf->hw_mode == HOSTAPD_MODE_IEEE80211A && ssid->vht) {
--		if (ssid->max_oper_chwidth != DEFAULT_MAX_OPER_CHWIDTH)
--			conf->vht_oper_chwidth = ssid->max_oper_chwidth;
--		switch (conf->vht_oper_chwidth) {
--		case CHANWIDTH_80MHZ:
--		case CHANWIDTH_80P80MHZ:
--			ieee80211_freq_to_chan(
--				frequency,
--				&conf->vht_oper_centr_freq_seg0_idx);
--			conf->vht_oper_centr_freq_seg0_idx += ssid->ht40 * 2;
--			break;
--		case CHANWIDTH_160MHZ:
--			ieee80211_freq_to_chan(
--				frequency,
--				&conf->vht_oper_centr_freq_seg0_idx);
--			conf->vht_oper_centr_freq_seg0_idx += ssid->ht40 * 2;
--			conf->vht_oper_centr_freq_seg0_idx += 40 / 5;
--			break;
--		}
--		ieee80211_freq_to_chan(ssid->vht_center_freq2,
--				       &conf->vht_oper_centr_freq_seg1_idx);
--	}
- 
- 	if (ssid->mesh_basic_rates == NULL) {
- 		/*
diff --git a/package/network/services/hostapd/patches/802-wolfssl-init-RNG-with-ECC-key.patch b/package/network/services/hostapd/patches/001-wolfssl-init-RNG-with-ECC-key.patch
similarity index 85%
rename from package/network/services/hostapd/patches/802-wolfssl-init-RNG-with-ECC-key.patch
rename to package/network/services/hostapd/patches/001-wolfssl-init-RNG-with-ECC-key.patch
index 84fc1c9351..994aa30626 100644
--- a/package/network/services/hostapd/patches/802-wolfssl-init-RNG-with-ECC-key.patch
+++ b/package/network/services/hostapd/patches/001-wolfssl-init-RNG-with-ECC-key.patch
@@ -16,7 +16,7 @@ Signed-off-by: David Bauer <mail@david-bauer.net>
 
 --- a/src/crypto/crypto_wolfssl.c
 +++ b/src/crypto/crypto_wolfssl.c
-@@ -1303,6 +1303,7 @@ int ecc_projective_add_point(ecc_point *
+@@ -1307,6 +1307,7 @@ int ecc_projective_add_point(ecc_point *
  
  struct crypto_ec {
  	ecc_key key;
@@ -24,7 +24,7 @@ Signed-off-by: David Bauer <mail@david-bauer.net>
  	mp_int a;
  	mp_int prime;
  	mp_int order;
-@@ -1357,6 +1358,8 @@ struct crypto_ec * crypto_ec_init(int gr
+@@ -1361,6 +1362,8 @@ struct crypto_ec * crypto_ec_init(int gr
  		return NULL;
  
  	if (wc_ecc_init(&e->key) != 0 ||
@@ -33,7 +33,7 @@ Signed-off-by: David Bauer <mail@david-bauer.net>
  	    wc_ecc_set_curve(&e->key, 0, curve_id) != 0 ||
  	    mp_init(&e->a) != MP_OKAY ||
  	    mp_init(&e->prime) != MP_OKAY ||
-@@ -1388,6 +1391,7 @@ void crypto_ec_deinit(struct crypto_ec*
+@@ -1392,6 +1395,7 @@ void crypto_ec_deinit(struct crypto_ec*
  	mp_clear(&e->order);
  	mp_clear(&e->prime);
  	mp_clear(&e->a);
diff --git a/package/network/services/hostapd/patches/002-mesh-fix-channel-init-order-disable-pri-sec-channel-.patch b/package/network/services/hostapd/patches/002-mesh-fix-channel-init-order-disable-pri-sec-channel-.patch
deleted file mode 100644
index c7101b1dbc..0000000000
--- a/package/network/services/hostapd/patches/002-mesh-fix-channel-init-order-disable-pri-sec-channel-.patch
+++ /dev/null
@@ -1,126 +0,0 @@
-From d869c753b79a1423c2bd9b0afdfa0d89d55a930c Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 13:53:18 +0200
-Subject: [PATCH 02/19] mesh: fix channel init order, disable pri/sec channel
- switch
-
-wpa_supplicant_conf_ap_ht has to happen before hostapd_setup_interface
-in order for its configuration settings to have effect on interface
-configuration.
-
-Disable primary and secondary channel switch because of missing tie
-breaking rule/frames in mesh networks. A rather long comment about
-this issue is placed in mesh.c in the corresponding place.
-
-In consequence, remove mesh coex test, which contradicts this change.
-
-I was not able to reproduce the memory corruption during
-mesh_secure_ocv_mix_legacy, which lead to a revert of a similar patch
-in the past.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- tests/hwsim/test_wpas_mesh.py | 50 -----------------------------------
- wpa_supplicant/mesh.c         | 25 ++++++++++++++++--
- 2 files changed, 23 insertions(+), 52 deletions(-)
-
---- a/tests/hwsim/test_wpas_mesh.py
-+++ b/tests/hwsim/test_wpas_mesh.py
-@@ -933,56 +933,6 @@ def _test_wpas_mesh_open_5ghz(dev, apdev
-     dev[0].dump_monitor()
-     dev[1].dump_monitor()
- 
--def test_wpas_mesh_open_5ghz_coex(dev, apdev):
--    """Mesh network on 5 GHz band and 20/40 coex change"""
--    try:
--        _test_wpas_mesh_open_5ghz_coex(dev, apdev)
--    finally:
--        dev[0].request("MESH_GROUP_REMOVE " + dev[0].ifname)
--        dev[1].request("MESH_GROUP_REMOVE " + dev[1].ifname)
--        set_world_reg(apdev0=apdev[0], dev0=dev[0])
--        dev[0].flush_scan_cache()
--        dev[1].flush_scan_cache()
--
--def _test_wpas_mesh_open_5ghz_coex(dev, apdev):
--    check_mesh_support(dev[0])
--    subprocess.call(['iw', 'reg', 'set', 'US'])
--
--    # Start a 20 MHz BSS on channel 40 that would be the secondary channel of
--    # HT40+ mesh on channel 36.
--    params = {"ssid": "test-ht40",
--              "hw_mode": "a",
--              "channel": "40",
--              "country_code": "US"}
--    hapd = hostapd.add_ap(apdev[0], params)
--    bssid = hapd.own_addr()
--
--    for i in range(2):
--        for j in range(5):
--            ev = dev[i].wait_event(["CTRL-EVENT-REGDOM-CHANGE"], timeout=5)
--            if ev is None:
--                raise Exception("No regdom change event")
--            if "alpha2=US" in ev:
--                break
--        dev[i].scan_for_bss(bssid, freq=5200)
--        add_open_mesh_network(dev[i], freq="5180")
--
--    check_mesh_joined_connected(dev)
--
--    freq = dev[0].get_status_field("freq")
--    if freq != "5200":
--        raise Exception("Unexpected STATUS freq=" + freq)
--    sig = dev[0].request("SIGNAL_POLL").splitlines()
--    if "FREQUENCY=5200" not in sig:
--        raise Exception("Unexpected SIGNAL_POLL output: " + str(sig))
--
--    hapd.disable()
--    dev[0].mesh_group_remove()
--    dev[1].mesh_group_remove()
--    check_mesh_group_removed(dev[0])
--    check_mesh_group_removed(dev[1])
--    dev[0].dump_monitor()
--    dev[1].dump_monitor()
- 
- def test_wpas_mesh_open_ht40(dev, apdev):
-     """Mesh and HT40 support difference"""
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -363,6 +363,29 @@ static int wpa_supplicant_mesh_init(stru
- 		conf->basic_rates[rate_len] = -1;
- 	}
- 
-+	/* While it can enhance performance to switch the primary channel, which
-+	 * is also the secondary channel of another network at the same time),
-+	 * to the other primary channel, problems exist with this in mesh networks.
-+	 *
-+	 * Example with problems:
-+	 *     - 3 mesh nodes M1-M3, freq (5200, 5180)
-+	 *     - other node O1, e.g. AP mode, freq (5180, 5200),
-+	 * Locations: O1 M1      M2      M3
-+	 *
-+	 * M3 can only send frames to M1 over M2, no direct connection is possible
-+	 * Start O1, M1 and M3 first, M1 or O1 will switch channels to align with
-+	 * each other. M3 does not swap, because M1 or O1 cannot be reached.
-+	 * M2 is started afterwards and can either connect to M3 or M1 because of
-+	 * this primary secondary channel switch.
-+	 *
-+	 * Solutions: (1) central coordination -> not always possible
-+	 *            (2) disable pri/sec channel switch in mesh networks
-+	 *
-+	 * In AP mode, when all nodes can work independently, this poses of course
-+	 * no problem, therefore disable it only in mesh mode.`*/
-+	conf->no_pri_sec_switch = 1;
-+	wpa_supplicant_conf_ap_ht(wpa_s, ssid, conf);
-+
- 	if (wpa_drv_init_mesh(wpa_s)) {
- 		wpa_msg(wpa_s, MSG_ERROR, "Failed to init mesh in driver");
- 		return -1;
-@@ -374,8 +397,6 @@ static int wpa_supplicant_mesh_init(stru
- 		return -1;
- 	}
- 
--	wpa_supplicant_conf_ap_ht(wpa_s, ssid, conf);
--
- 	return 0;
- out_free:
- 	wpa_supplicant_mesh_deinit(wpa_s);
diff --git a/package/network/services/hostapd/patches/003-wpa_supplicant-handle-HT40-and-mode-downgrade-in-AP-.patch b/package/network/services/hostapd/patches/003-wpa_supplicant-handle-HT40-and-mode-downgrade-in-AP-.patch
deleted file mode 100644
index f42620042d..0000000000
--- a/package/network/services/hostapd/patches/003-wpa_supplicant-handle-HT40-and-mode-downgrade-in-AP-.patch
+++ /dev/null
@@ -1,102 +0,0 @@
-From 978a59514ccde994b5c06e1cbb49cc8cebe6381c Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 13:53:19 +0200
-Subject: [PATCH 03/19] wpa_supplicant: handle HT40 and mode downgrade in AP
- mode
-
-This patch adds some missing pieces to the interface configuration
-of AP/mesh mode in wpa_supplicant.
- - check for secondary channel and HT40 capability
- - try to downgrade to 11b if 11g is not available
-Especially with the HT40 check, this code now performs all settings,
-which the deleted/duplicated mesh code did.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- wpa_supplicant/ap.c | 49 ++++++++++++++++++++++++++++++++++++---------
- 1 file changed, 40 insertions(+), 9 deletions(-)
-
---- a/wpa_supplicant/ap.c
-+++ b/wpa_supplicant/ap.c
-@@ -134,6 +134,23 @@ no_vht:
- }
- 
- 
-+static struct hostapd_hw_modes *wpa_supplicant_find_hw_mode(struct wpa_supplicant *wpa_s,
-+							    enum hostapd_hw_mode hw_mode)
-+{
-+	struct hostapd_hw_modes *mode = NULL;
-+	int i;
-+
-+	for (i = 0; i < wpa_s->hw.num_modes; i++) {
-+		if (wpa_s->hw.modes[i].mode == hw_mode) {
-+			mode = &wpa_s->hw.modes[i];
-+			break;
-+		}
-+	}
-+
-+	return mode;
-+}
-+
-+
- int wpa_supplicant_conf_ap_ht(struct wpa_supplicant *wpa_s,
- 			      struct wpa_ssid *ssid,
- 			      struct hostapd_config *conf)
-@@ -147,9 +164,6 @@ int wpa_supplicant_conf_ap_ht(struct wpa
- 		return -1;
- 	}
- 
--	/* TODO: enable HT40 if driver supports it;
--	 * drop to 11b if driver does not support 11g */
--
- 	/*
- 	 * Enable HT20 if the driver supports it, by setting conf->ieee80211n
- 	 * and a mask of allowed capabilities within conf->ht_capab.
-@@ -158,17 +172,27 @@ int wpa_supplicant_conf_ap_ht(struct wpa
- 	 */
- 	if (wpa_s->hw.modes) {
- 		struct hostapd_hw_modes *mode = NULL;
--		int i, no_ht = 0;
-+		int no_ht = 0;
- 
- 		wpa_printf(MSG_DEBUG,
- 			   "Determining HT/VHT options based on driver capabilities (freq=%u chan=%u)",
- 			   ssid->frequency, conf->channel);
- 
--		for (i = 0; i < wpa_s->hw.num_modes; i++) {
--			if (wpa_s->hw.modes[i].mode == conf->hw_mode) {
--				mode = &wpa_s->hw.modes[i];
--				break;
--			}
-+		mode = wpa_supplicant_find_hw_mode(wpa_s, conf->hw_mode);
-+
-+		/* may drop drop to 11b if driver does not support 11g */
-+		if (!mode && conf->hw_mode == HOSTAPD_MODE_IEEE80211G) {
-+			conf->hw_mode = HOSTAPD_MODE_IEEE80211B;
-+			wpa_printf(MSG_INFO,
-+			   "Try downgrade to IEEE 802.11b as 802.11g is not "
-+			   "supported by the current hardware");
-+			mode = wpa_supplicant_find_hw_mode(wpa_s, conf->hw_mode);
-+		}
-+
-+		if (!mode) {
-+			wpa_printf(MSG_ERROR,
-+			   "No match between requested and supported hw modes found");
-+			return -1;
- 		}
- 
- #ifdef CONFIG_HT_OVERRIDES
-@@ -193,6 +217,13 @@ int wpa_supplicant_conf_ap_ht(struct wpa
- 				      HT_CAP_INFO_SUPP_CHANNEL_WIDTH_SET),
- 				   ssid->ht40);
- 			conf->ieee80211n = 1;
-+
-+			if (ssid->ht40 &&
-+			    mode->ht_capab & HT_CAP_INFO_SUPP_CHANNEL_WIDTH_SET)
-+				conf->secondary_channel = ssid->ht40;
-+			else
-+				conf->secondary_channel = 0;
-+
- #ifdef CONFIG_P2P
- 			if (ssid->p2p_group &&
- 			    conf->hw_mode == HOSTAPD_MODE_IEEE80211A &&
diff --git a/package/network/services/hostapd/patches/004-wpa_supplicant-fix-frequency-config-for-non-p2p-vht-.patch b/package/network/services/hostapd/patches/004-wpa_supplicant-fix-frequency-config-for-non-p2p-vht-.patch
deleted file mode 100644
index e8682af644..0000000000
--- a/package/network/services/hostapd/patches/004-wpa_supplicant-fix-frequency-config-for-non-p2p-vht-.patch
+++ /dev/null
@@ -1,63 +0,0 @@
-From 7f7325dae1d03a3964d4e91940d8369f3fed7b43 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 13:53:20 +0200
-Subject: [PATCH 04/19] wpa_supplicant: fix frequency config for non p2p vht/he
- cases
-
-Fix compile without CONFIG_P2P and only set secondary channel seg idx
-if we use a mode supporting a sec channel for vht/he.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- wpa_supplicant/ap.c | 23 +++++++++++++----------
- 1 file changed, 13 insertions(+), 10 deletions(-)
-
---- a/wpa_supplicant/ap.c
-+++ b/wpa_supplicant/ap.c
-@@ -52,8 +52,8 @@ static void wpas_conf_ap_vht(struct wpa_
- #ifdef CONFIG_P2P
- 	u8 center_chan = 0;
- 	u8 channel = conf->channel;
--	u8 freq_seg_idx;
- #endif /* CONFIG_P2P */
-+	u8 freq_seg_idx;
- 
- 	if (!conf->secondary_channel)
- 		goto no_vht;
-@@ -62,24 +62,27 @@ static void wpas_conf_ap_vht(struct wpa_
- 	if (ssid->max_oper_chwidth)
- 		hostapd_set_oper_chwidth(conf, ssid->max_oper_chwidth);
- 
--	ieee80211_freq_to_chan(ssid->vht_center_freq2,
--			       &freq_seg_idx);
--	hostapd_set_oper_centr_freq_seg1_idx(conf, freq_seg_idx);
--
- 	if (!ssid->p2p_group) {
--		if (!ssid->vht_center_freq1 ||
--		    hostapd_get_oper_chwidth(conf) == CHANWIDTH_USE_HT)
-+		if (!ssid->vht_center_freq1)
- 			goto no_vht;
- 		ieee80211_freq_to_chan(ssid->vht_center_freq1,
- 				       &freq_seg_idx);
- 		hostapd_set_oper_centr_freq_seg0_idx(conf, freq_seg_idx);
--		wpa_printf(MSG_DEBUG, "VHT seg0 index %d for AP",
--			   hostapd_get_oper_centr_freq_seg0_idx(conf));
-+
-+		if (hostapd_get_oper_chwidth(conf) == CHANWIDTH_80P80MHZ) {
-+			ieee80211_freq_to_chan(ssid->vht_center_freq2,
-+					       &freq_seg_idx);
-+			hostapd_set_oper_centr_freq_seg1_idx(conf, freq_seg_idx);
-+		}
-+
-+		wpa_printf(MSG_DEBUG, "VHT seg0 index %d and seg1 index %d for AP",
-+			   hostapd_get_oper_centr_freq_seg0_idx(conf),
-+			   hostapd_get_oper_centr_freq_seg1_idx(conf));
- 		return;
- 	}
- 
- #ifdef CONFIG_P2P
--	switch (conf->vht_oper_chwidth) {
-+	switch (hostapd_get_oper_chwidth(conf)) {
- 	case CHANWIDTH_80MHZ:
- 	case CHANWIDTH_80P80MHZ:
- 		center_chan = wpas_p2p_get_vht80_center(wpa_s, mode, channel);
diff --git a/package/network/services/hostapd/patches/005-wpa_supplicant-enable-vht-and-he-in-default-config-p.patch b/package/network/services/hostapd/patches/005-wpa_supplicant-enable-vht-and-he-in-default-config-p.patch
deleted file mode 100644
index 25d74252cd..0000000000
--- a/package/network/services/hostapd/patches/005-wpa_supplicant-enable-vht-and-he-in-default-config-p.patch
+++ /dev/null
@@ -1,25 +0,0 @@
-From ff7fb3fa0831c8521327d777c5607a3b7d8736b8 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 13:53:21 +0200
-Subject: [PATCH 05/19] wpa_supplicant: enable vht and he in default config
- parameters
-
-Enable VHT and HE as default config parameters in order for
-wpa_supplicant AP mode to use it, if hw support is given.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- wpa_supplicant/config.c | 2 ++
- 1 file changed, 2 insertions(+)
-
---- a/wpa_supplicant/config.c
-+++ b/wpa_supplicant/config.c
-@@ -3036,6 +3036,8 @@ void wpa_config_set_network_defaults(str
- 	ssid->wpa_deny_ptk0_rekey = PTK0_REKEY_ALLOW_ALWAYS;
- 	ssid->bg_scan_period = DEFAULT_BG_SCAN_PERIOD;
- 	ssid->ht = 1;
-+	ssid->vht = 1;
-+	ssid->he = 1;
- #ifdef IEEE8021X_EAPOL
- 	ssid->eapol_flags = DEFAULT_EAPOL_FLAGS;
- 	ssid->eap_workaround = DEFAULT_EAP_WORKAROUND;
diff --git a/package/network/services/hostapd/patches/006-hw_features-better-debug-messages-for-some-error-cas.patch b/package/network/services/hostapd/patches/006-hw_features-better-debug-messages-for-some-error-cas.patch
deleted file mode 100644
index 31b1ac0d38..0000000000
--- a/package/network/services/hostapd/patches/006-hw_features-better-debug-messages-for-some-error-cas.patch
+++ /dev/null
@@ -1,83 +0,0 @@
-From 6522dcbbcf71abcb80cce84b93b4a9a5cfcd4fca Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 13:53:22 +0200
-Subject: [PATCH 06/19] hw_features: better debug messages for some error cases
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- src/common/hw_features_common.c | 29 ++++++++++++++++++++++-------
- 1 file changed, 22 insertions(+), 7 deletions(-)
-
---- a/src/common/hw_features_common.c
-+++ b/src/common/hw_features_common.c
-@@ -540,13 +540,18 @@ int hostapd_set_freq_params(struct hosta
- 		if (center_segment1 ||
- 		    (center_segment0 != 0 &&
- 		     5000 + center_segment0 * 5 != data->center_freq1 &&
--		     2407 + center_segment0 * 5 != data->center_freq1))
-+		     2407 + center_segment0 * 5 != data->center_freq1)) {
-+			wpa_printf(MSG_ERROR, "20/40 MHz: center segment 0 (=%i) and center freq 1 (=%i) not in sync",
-+				   center_segment0, data->center_freq1);
- 			return -1;
-+		}
- 		break;
- 	case CHANWIDTH_80P80MHZ:
- 		if (center_segment1 == center_segment0 + 4 ||
--		    center_segment1 == center_segment0 - 4)
-+		    center_segment1 == center_segment0 - 4) {
-+			wpa_printf(MSG_ERROR, "80+80 MHz: center segment 1 only 20 MHz apart");
- 			return -1;
-+		}
- 		data->center_freq2 = 5000 + center_segment1 * 5;
- 		/* fall through */
- 	case CHANWIDTH_80MHZ:
-@@ -555,8 +560,10 @@ int hostapd_set_freq_params(struct hosta
- 		     center_segment1) ||
- 		    (oper_chwidth == CHANWIDTH_80P80MHZ &&
- 		     !center_segment1) ||
--		    !sec_channel_offset)
-+		    !sec_channel_offset) {
-+			wpa_printf(MSG_ERROR, "80/80+80 MHz: center segment 1 wrong or no second channel offset");
- 			return -1;
-+		}
- 		if (!center_segment0) {
- 			if (channel <= 48)
- 				center_segment0 = 42;
-@@ -582,16 +589,22 @@ int hostapd_set_freq_params(struct hosta
- 			    center_segment0 == channel - 2 ||
- 			    center_segment0 == channel - 6)
- 				data->center_freq1 = 5000 + center_segment0 * 5;
--			else
-+			else {
-+				wpa_printf(MSG_ERROR, "Wrong coupling between HT and VHT/HE channel setting");
- 				return -1;
-+			}
- 		}
- 		break;
- 	case CHANWIDTH_160MHZ:
- 		data->bandwidth = 160;
--		if (center_segment1)
-+		if (center_segment1) {
-+			wpa_printf(MSG_ERROR, "160 MHz: center segment 1 should not be set");
- 			return -1;
--		if (!sec_channel_offset)
-+		}
-+		if (!sec_channel_offset) {
-+			wpa_printf(MSG_ERROR, "160 MHz: second channel offset not set");
- 			return -1;
-+		}
- 		/*
- 		 * Note: HT/VHT config and params are coupled. Check if
- 		 * HT40 channel band is in VHT160 channel band configuration.
-@@ -605,8 +618,10 @@ int hostapd_set_freq_params(struct hosta
- 		    center_segment0 == channel - 10 ||
- 		    center_segment0 == channel - 14)
- 			data->center_freq1 = 5000 + center_segment0 * 5;
--		else
-+		else {
-+			wpa_printf(MSG_ERROR, "160 MHz: HT40 channel band is not in 160 MHz band");
- 			return -1;
-+		}
- 		break;
- 	}
- 
diff --git a/package/network/services/hostapd/patches/007-dfs-use-helper-functions-for-vht-he-parameters.patch b/package/network/services/hostapd/patches/007-dfs-use-helper-functions-for-vht-he-parameters.patch
deleted file mode 100644
index 3481c52eef..0000000000
--- a/package/network/services/hostapd/patches/007-dfs-use-helper-functions-for-vht-he-parameters.patch
+++ /dev/null
@@ -1,27 +0,0 @@
-From 6eacc14904b6f09a1490e697c01adf5dc56c4905 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 13:53:23 +0200
-Subject: [PATCH 07/19] dfs: use helper functions for vht/he parameters
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- src/ap/dfs.c | 6 ++++--
- 1 file changed, 4 insertions(+), 2 deletions(-)
-
---- a/src/ap/dfs.c
-+++ b/src/ap/dfs.c
-@@ -955,10 +955,12 @@ dfs_downgrade_bandwidth(struct hostapd_i
- 		if (*skip_radar) {
- 			*skip_radar = 0;
- 		} else {
--			if (iface->conf->vht_oper_chwidth == CHANWIDTH_USE_HT)
-+			int oper_chwidth = hostapd_get_oper_chwidth(iface->conf);
-+
-+			if (oper_chwidth == CHANWIDTH_USE_HT)
- 				break;
- 			*skip_radar = 1;
--			iface->conf->vht_oper_chwidth--;
-+			hostapd_set_oper_chwidth(iface->conf, oper_chwidth - 1);
- 		}
- 	}
- 
diff --git a/package/network/services/hostapd/patches/008-mesh-use-setup-completion-callback-to-complete-mesh-.patch b/package/network/services/hostapd/patches/008-mesh-use-setup-completion-callback-to-complete-mesh-.patch
deleted file mode 100644
index 28c283d035..0000000000
--- a/package/network/services/hostapd/patches/008-mesh-use-setup-completion-callback-to-complete-mesh-.patch
+++ /dev/null
@@ -1,108 +0,0 @@
-From 11e5bbe58eebdb10793eec374b6c8ccc7daf7ec8 Mon Sep 17 00:00:00 2001
-From: Peter Oh <peter.oh@bowerswilkins.com>
-Date: Tue, 30 Jun 2020 14:18:56 +0200
-Subject: [PATCH 08/19] mesh: use setup completion callback to complete mesh
- join
-
-mesh join function is the last function to be called during
-mesh join process, but it's been called a bit earlier than
-it's supposed to be, so that some mesh parameter values
-such as VHT capabilities not applied correct when mesh join
-is in process.
-Moreover current design of mesh join that is called directly
-after mesh initialization isn't suitable for DFS channels to use,
-since mesh join process should be paused until DFS CAC is
-done and resumed after it's done.
-The callback will be called by hostapd_setup_interface_complete_sync.
-There is possiblity that completing mesh init fails, so add error
-handle codes.
-
-Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
----
- src/ap/hostapd.c      | 11 ++++++++++-
- wpa_supplicant/mesh.c | 12 ++++++++++--
- 2 files changed, 20 insertions(+), 3 deletions(-)
-
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -434,6 +434,8 @@ static void hostapd_free_hapd_data(struc
- #ifdef CONFIG_MESH
- 	wpabuf_free(hapd->mesh_pending_auth);
- 	hapd->mesh_pending_auth = NULL;
-+	/* handling setup failure is already done */
-+	hapd->setup_complete_cb = NULL;
- #endif /* CONFIG_MESH */
- 
- 	hostapd_clean_rrm(hapd);
-@@ -2156,6 +2158,13 @@ dfs_offload:
- 	if (hapd->setup_complete_cb)
- 		hapd->setup_complete_cb(hapd->setup_complete_cb_ctx);
- 
-+#ifdef CONFIG_MESH
-+	if (delay_apply_cfg && iface->mconf == NULL) {
-+		wpa_printf(MSG_ERROR, "Error while completing mesh init");
-+		goto fail;
-+	}
-+#endif /* CONFIG_MESH */
-+
- 	wpa_printf(MSG_DEBUG, "%s: Setup of interface done.",
- 		   iface->bss[0]->conf->iface);
- 	if (iface->interfaces && iface->interfaces->terminate_on_error > 0)
-@@ -2299,7 +2308,7 @@ int hostapd_setup_interface(struct hosta
- 	ret = setup_interface(iface);
- 	if (ret) {
- 		wpa_printf(MSG_ERROR, "%s: Unable to setup interface.",
--			   iface->bss[0]->conf->iface);
-+			iface->conf ? iface->conf->bss[0]->iface : "N/A");
- 		return -1;
- 	}
- 
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -193,7 +193,6 @@ static int wpas_mesh_init_rsn(struct wpa
- 	return !wpa_s->mesh_rsn ? -1 : 0;
- }
- 
--
- static int wpas_mesh_complete(struct wpa_supplicant *wpa_s)
- {
- 	struct hostapd_iface *ifmsh = wpa_s->ifmsh;
-@@ -244,6 +243,13 @@ static int wpas_mesh_complete(struct wpa
- }
- 
- 
-+static void wpas_mesh_complete_cb(void *arg)
-+{
-+	struct wpa_supplicant *wpa_s = arg;
-+	wpas_mesh_complete(wpa_s);
-+}
-+
-+
- static int wpa_supplicant_mesh_init(struct wpa_supplicant *wpa_s,
- 				    struct wpa_ssid *ssid,
- 				    struct hostapd_freq_params *freq)
-@@ -267,6 +273,7 @@ static int wpa_supplicant_mesh_init(stru
- 	if (!ifmsh)
- 		return -ENOMEM;
- 
-+	ifmsh->owner = wpa_s;
- 	ifmsh->drv_flags = wpa_s->drv_flags;
- 	ifmsh->drv_flags2 = wpa_s->drv_flags2;
- 	ifmsh->num_bss = 1;
-@@ -285,6 +292,8 @@ static int wpa_supplicant_mesh_init(stru
- 	bss->drv_priv = wpa_s->drv_priv;
- 	bss->iface = ifmsh;
- 	bss->mesh_sta_free_cb = mesh_mpm_free_sta;
-+	bss->setup_complete_cb = wpas_mesh_complete_cb;
-+	bss->setup_complete_cb_ctx = wpa_s;
- 	frequency = ssid->frequency;
- 	if (frequency != freq->freq &&
- 	    frequency == freq->freq + freq->sec_channel_offset * 20) {
-@@ -523,7 +532,6 @@ int wpa_supplicant_join_mesh(struct wpa_
- 		goto out;
- 	}
- 
--	ret = wpas_mesh_complete(wpa_s);
- out:
- 	return ret;
- }
diff --git a/package/network/services/hostapd/patches/009-mesh-update-ssid-frequency-as-pri-sec-channel-switch.patch b/package/network/services/hostapd/patches/009-mesh-update-ssid-frequency-as-pri-sec-channel-switch.patch
deleted file mode 100644
index b48de67636..0000000000
--- a/package/network/services/hostapd/patches/009-mesh-update-ssid-frequency-as-pri-sec-channel-switch.patch
+++ /dev/null
@@ -1,26 +0,0 @@
-From 87c5e8883898e7eb8e9637e212350c1925a22654 Mon Sep 17 00:00:00 2001
-From: Peter Oh <peter.oh@bowerswilkins.com>
-Date: Tue, 30 Jun 2020 14:18:57 +0200
-Subject: [PATCH 09/19] mesh: update ssid->frequency as pri/sec channel switch
-
-ssid->frequency is one of variables used to gets channel
-number from given frequency. Leave it as unchanged when
-pri/sec channel switched will cause picking up wrong
-channel number after applying secondary channel offset
-for HT40 and leads failing interface bring-up.
-
-Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
----
- wpa_supplicant/mesh.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -299,6 +299,7 @@ static int wpa_supplicant_mesh_init(stru
- 	    frequency == freq->freq + freq->sec_channel_offset * 20) {
- 		wpa_printf(MSG_DEBUG, "mesh: pri/sec channels switched");
- 		frequency = freq->freq;
-+		ssid->frequency = frequency;
- 	}
- 	wpa_s->assoc_freq = frequency;
- 	wpa_s->current_ssid = ssid;
diff --git a/package/network/services/hostapd/patches/010-mesh-Allow-DFS-channels-to-be-selected-if-dfs-is-ena.patch b/package/network/services/hostapd/patches/010-mesh-Allow-DFS-channels-to-be-selected-if-dfs-is-ena.patch
index 8afeba93ed..16d24d1000 100644
--- a/package/network/services/hostapd/patches/010-mesh-Allow-DFS-channels-to-be-selected-if-dfs-is-ena.patch
+++ b/package/network/services/hostapd/patches/010-mesh-Allow-DFS-channels-to-be-selected-if-dfs-is-ena.patch
@@ -14,16 +14,37 @@ Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
 
 --- a/wpa_supplicant/wpa_supplicant.c
 +++ b/wpa_supplicant/wpa_supplicant.c
-@@ -2349,6 +2349,8 @@ void ibss_mesh_setup_freq(struct wpa_sup
+@@ -2409,7 +2409,7 @@ static int drv_supports_vht(struct wpa_s
+ }
+ 
+ 
+-static bool ibss_mesh_is_80mhz_avail(int channel, struct hostapd_hw_modes *mode)
++static bool ibss_mesh_is_80mhz_avail(int channel, struct hostapd_hw_modes *mode, bool dfs_enabled)
+ {
+ 	int i;
+ 
+@@ -2418,7 +2418,10 @@ static bool ibss_mesh_is_80mhz_avail(int
+ 
+ 		chan = hw_get_channel_chan(mode, i, NULL);
+ 		if (!chan ||
+-		    chan->flag & (HOSTAPD_CHAN_DISABLED | HOSTAPD_CHAN_NO_IR))
++		    chan->flag & HOSTAPD_CHAN_DISABLED)
++			return false;
++		
++		if (!dfs_enabled && chan->flag & (HOSTAPD_CHAN_RADAR | HOSTAPD_CHAN_NO_IR))
+ 			return false;
+ 	}
+ 
+@@ -2447,6 +2450,8 @@ void ibss_mesh_setup_freq(struct wpa_sup
  	int chwidth, seg0, seg1;
  	u32 vht_caps = 0;
- 	int is_24ghz;
-+	int dfs_enabled = wpa_s->conf->country[0] &&
-+			 (wpa_s->drv_flags & WPA_DRIVER_FLAGS_RADAR);
+ 	bool is_24ghz, is_6ghz;
++	bool dfs_enabled = wpa_s->conf->country[0] &&
++			   (wpa_s->drv_flags & WPA_DRIVER_FLAGS_RADAR);
  
  	freq->freq = ssid->frequency;
  
-@@ -2436,8 +2438,11 @@ void ibss_mesh_setup_freq(struct wpa_sup
+@@ -2543,8 +2548,11 @@ void ibss_mesh_setup_freq(struct wpa_sup
  		return;
  
  	/* Check primary channel flags */
@@ -36,7 +57,7 @@ Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
  
  	freq->channel = pri_chan->chan;
  
-@@ -2470,8 +2475,11 @@ void ibss_mesh_setup_freq(struct wpa_sup
+@@ -2577,8 +2585,11 @@ void ibss_mesh_setup_freq(struct wpa_sup
  		return;
  
  	/* Check secondary channel flags */
@@ -49,20 +70,25 @@ Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
  
  	if (ht40 == -1) {
  		if (!(pri_chan->flag & HOSTAPD_CHAN_HT40MINUS))
-@@ -2564,8 +2572,11 @@ skip_ht40:
- 			return;
+@@ -2667,7 +2678,7 @@ skip_to_6ghz:
+ 		return;
  
- 		/* Back to HT configuration if channel not usable */
--		if (chan->flag & (HOSTAPD_CHAN_DISABLED | HOSTAPD_CHAN_NO_IR))
-+		if (chan->flag & HOSTAPD_CHAN_DISABLED)
- 			return;
-+		if (chan->flag & (HOSTAPD_CHAN_RADAR | HOSTAPD_CHAN_NO_IR))
-+			if (!dfs_enabled)
-+				return;
- 	}
+ 	/* Back to HT configuration if channel not usable */
+-	if (!ibss_mesh_is_80mhz_avail(channel, mode))
++	if (!ibss_mesh_is_80mhz_avail(channel, mode, dfs_enabled))
+ 		return;
  
  	chwidth = CHANWIDTH_80MHZ;
-@@ -2585,10 +2596,12 @@ skip_ht40:
+@@ -2681,7 +2692,7 @@ skip_to_6ghz:
+ 		 * above; check the remaining four 20 MHz channels for the total
+ 		 * of 160 MHz bandwidth.
+ 		 */
+-		if (!ibss_mesh_is_80mhz_avail(channel + 16, mode))
++		if (!ibss_mesh_is_80mhz_avail(channel + 16, mode, dfs_enabled))
+ 			return;
+ 
+ 		for (j = 0; j < ARRAY_SIZE(bw160); j++) {
+@@ -2711,10 +2722,12 @@ skip_to_6ghz:
  				if (!chan)
  					continue;
  
diff --git a/package/network/services/hostapd/patches/011-mesh-do-not-set-offchanok-on-DFS-channels-in-non-ETS.patch b/package/network/services/hostapd/patches/011-mesh-do-not-set-offchanok-on-DFS-channels-in-non-ETS.patch
deleted file mode 100644
index d491f7c4bc..0000000000
--- a/package/network/services/hostapd/patches/011-mesh-do-not-set-offchanok-on-DFS-channels-in-non-ETS.patch
+++ /dev/null
@@ -1,53 +0,0 @@
-From af8dcbc87466ed6472850a4f1cfe252652cb3d26 Mon Sep 17 00:00:00 2001
-From: Peter Oh <peter.oh@bowerswilkins.com>
-Date: Tue, 30 Jun 2020 14:18:59 +0200
-Subject: [PATCH 11/19] mesh: do not set offchanok on DFS channels in non-ETSI
-
-mac80211 does not allow mgmt tx to use off channel on
-DFS channels in non-ETSI domain, because it will invalidate
-CAC result on current operating channel.
-(mac80211 commit: 34373d12f3cbb74960a73431138ef619d857996f)
-Hence don't set offchanok for mgmt tx in case of DFS channels
-in non-ETSI.
-
-Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
----
- src/drivers/driver_nl80211.c | 19 +++++++++++++++++++
- 1 file changed, 19 insertions(+)
-
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -7788,7 +7788,11 @@ static int wpa_driver_nl80211_send_actio
- 	int ret = -1;
- 	u8 *buf;
- 	struct ieee80211_hdr *hdr;
-+	struct hostapd_hw_modes *modes;
- 	int offchanok = 1;
-+	u16 num_modes, flags;
-+	u8 dfs_domain;
-+	int i;
- 
- 	if (is_ap_interface(drv->nlmode) && (int) freq == bss->freq &&
- 	    bss->beacon_set)
-@@ -7817,6 +7821,21 @@ static int wpa_driver_nl80211_send_actio
- 		os_memset(bss->rand_addr, 0, ETH_ALEN);
- 	}
- 
-+	if (is_mesh_interface(drv->nlmode)) {
-+		modes = nl80211_get_hw_feature_data(bss, &num_modes,
-+						    &flags, &dfs_domain);
-+		if (dfs_domain != HOSTAPD_DFS_REGION_ETSI &&
-+		    ieee80211_is_dfs(bss->freq, modes, num_modes))
-+			offchanok = 0;
-+		if (modes) {
-+			for (i = 0; i < num_modes; i++) {
-+				os_free(modes[i].channels);
-+				os_free(modes[i].rates);
-+			}
-+			os_free(modes);
-+		}
-+	}
-+
- 	if (is_ap_interface(drv->nlmode) &&
- 	    (!(drv->capa.flags & WPA_DRIVER_FLAGS_OFFCHANNEL_TX) ||
- 	     (int) freq == bss->freq || drv->device_ap_sme ||
diff --git a/package/network/services/hostapd/patches/019-mesh-use-deterministic-channel-on-channel-switch.patch b/package/network/services/hostapd/patches/011-mesh-use-deterministic-channel-on-channel-switch.patch
similarity index 92%
rename from package/network/services/hostapd/patches/019-mesh-use-deterministic-channel-on-channel-switch.patch
rename to package/network/services/hostapd/patches/011-mesh-use-deterministic-channel-on-channel-switch.patch
index 8e38a8e53c..1faeacf766 100644
--- a/package/network/services/hostapd/patches/019-mesh-use-deterministic-channel-on-channel-switch.patch
+++ b/package/network/services/hostapd/patches/011-mesh-use-deterministic-channel-on-channel-switch.patch
@@ -29,7 +29,7 @@ Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
  
  
  static int dfs_get_used_n_chans(struct hostapd_iface *iface, int *seg1)
-@@ -480,9 +481,14 @@ dfs_get_valid_channel(struct hostapd_ifa
+@@ -483,9 +484,14 @@ dfs_get_valid_channel(struct hostapd_ifa
  	int num_available_chandefs;
  	int chan_idx, chan_idx2;
  	int sec_chan_idx_80p80 = -1;
@@ -44,7 +44,7 @@ Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
  	wpa_printf(MSG_DEBUG, "DFS: Selecting random channel");
  	*secondary_channel = 0;
  	*oper_centr_freq_seg0_idx = 0;
-@@ -502,8 +508,20 @@ dfs_get_valid_channel(struct hostapd_ifa
+@@ -505,8 +511,20 @@ dfs_get_valid_channel(struct hostapd_ifa
  	if (num_available_chandefs == 0)
  		return NULL;
  
@@ -68,7 +68,7 @@ Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
  	if (!chan) {
 --- a/src/drivers/driver_nl80211.c
 +++ b/src/drivers/driver_nl80211.c
-@@ -9473,6 +9473,10 @@ static int nl80211_switch_channel(void *
+@@ -9895,6 +9895,10 @@ static int nl80211_switch_channel(void *
  	if (ret)
  		goto error;
  
diff --git a/package/network/services/hostapd/patches/012-mesh-fix-channel-switch-error-during-CAC.patch b/package/network/services/hostapd/patches/012-mesh-fix-channel-switch-error-during-CAC.patch
deleted file mode 100644
index f324d81ae3..0000000000
--- a/package/network/services/hostapd/patches/012-mesh-fix-channel-switch-error-during-CAC.patch
+++ /dev/null
@@ -1,66 +0,0 @@
-From ab6995f15aae17af93507dd2344615f91672a31a Mon Sep 17 00:00:00 2001
-From: Peter Oh <peter.oh@bowerswilkins.com>
-Date: Tue, 30 Jun 2020 14:19:00 +0200
-Subject: [PATCH 12/19] mesh: fix channel switch error during CAC
-
-Mesh interface has used its channel parameters that configured
-during its initialization even after channel switched due to
-DFS radar detection during CAC which caused channel switch error.
-This change fixes the error by updating its channel parameters
-when channel's been changed from initial one.
-
-Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
----
- wpa_supplicant/mesh.c | 34 ++++++++++++++++++++++++++++++++++
- 1 file changed, 34 insertions(+)
-
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -13,6 +13,7 @@
- #include "utils/uuid.h"
- #include "common/ieee802_11_defs.h"
- #include "common/wpa_ctrl.h"
-+#include "common/hw_features_common.h"
- #include "ap/sta_info.h"
- #include "ap/hostapd.h"
- #include "ap/ieee802_11.h"
-@@ -206,6 +207,39 @@ static int wpas_mesh_complete(struct wpa
- 		return -1;
- 	}
- 
-+	/*
-+	 * inspect if channel's been changed since initialized.
-+	 * i.e. DFS radar detection
-+	 */
-+	if (ifmsh->freq != params->freq.freq) {
-+		wpa_s->assoc_freq = ifmsh->freq;
-+		ssid->frequency = ifmsh->freq;
-+		struct he_capabilities *he_capab = NULL;
-+
-+		if (ifmsh->current_mode)
-+			he_capab = &ifmsh->current_mode->he_capab[IEEE80211_MODE_MESH];
-+
-+		if (hostapd_set_freq_params(&params->freq,
-+				ifmsh->conf->hw_mode,
-+				ifmsh->freq,
-+				ifmsh->conf->channel,
-+				ifmsh->conf->enable_edmg,
-+				ifmsh->conf->edmg_channel,
-+				ifmsh->conf->ieee80211n,
-+				ifmsh->conf->ieee80211ac,
-+				ifmsh->conf->ieee80211ax,
-+				ifmsh->conf->secondary_channel,
-+				hostapd_get_oper_chwidth(ifmsh->conf),
-+				hostapd_get_oper_centr_freq_seg0_idx(ifmsh->conf),
-+				hostapd_get_oper_centr_freq_seg1_idx(ifmsh->conf),
-+				ifmsh->conf->vht_capab,
-+				he_capab)) {
-+			wpa_printf(MSG_ERROR, "Error updating mesh frequency params.");
-+			wpa_supplicant_mesh_deinit(wpa_s);
-+			return -1;
-+		}
-+	}
-+
- 	if (ifmsh->mconf->security != MESH_CONF_SEC_NONE &&
- 	    wpas_mesh_init_rsn(wpa_s)) {
- 		wpa_printf(MSG_ERROR,
diff --git a/package/network/services/hostapd/patches/013-mesh-inform-kernel-driver-DFS-handler-in-userspace.patch b/package/network/services/hostapd/patches/013-mesh-inform-kernel-driver-DFS-handler-in-userspace.patch
deleted file mode 100644
index fb4e68636e..0000000000
--- a/package/network/services/hostapd/patches/013-mesh-inform-kernel-driver-DFS-handler-in-userspace.patch
+++ /dev/null
@@ -1,48 +0,0 @@
-From f1118eca5b1a63a4acb2a11ceea15dc4bc259c77 Mon Sep 17 00:00:00 2001
-From: Peter Oh <peter.oh@bowerswilkins.com>
-Date: Tue, 30 Jun 2020 14:19:01 +0200
-Subject: [PATCH 13/19] mesh: inform kernel driver DFS handler in userspace
-
-NL80211_ATTR_HANDLE_DFS is required by kerenel space
-to enable DFS channels that indicates DFS handler
-resides in userspace.
-
-Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
----
- src/drivers/driver.h         | 1 +
- src/drivers/driver_nl80211.c | 3 +++
- wpa_supplicant/mesh.c        | 1 +
- 3 files changed, 5 insertions(+)
-
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -1542,6 +1542,7 @@ struct wpa_driver_mesh_join_params {
- #define WPA_DRIVER_MESH_FLAG_SAE_AUTH	0x00000004
- #define WPA_DRIVER_MESH_FLAG_AMPE	0x00000008
- 	unsigned int flags;
-+	u8 handle_dfs;
- };
- 
- struct wpa_driver_set_key_params {
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -10070,6 +10070,9 @@ static int nl80211_join_mesh(struct i802
- 
- 	wpa_printf(MSG_DEBUG, "  * flags=%08X", params->flags);
- 
-+	if (params->handle_dfs)
-+		if (nla_put_flag(msg, NL80211_ATTR_HANDLE_DFS))
-+			goto fail;
- 	container = nla_nest_start(msg, NL80211_ATTR_MESH_SETUP);
- 	if (!container)
- 		goto fail;
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -355,6 +355,7 @@ static int wpa_supplicant_mesh_init(stru
- 		conf->country[0] = wpa_s->conf->country[0];
- 		conf->country[1] = wpa_s->conf->country[1];
- 		conf->country[2] = ' ';
-+		wpa_s->mesh_params->handle_dfs = 1;
- 	}
- 
- 	bss->iconf = conf;
diff --git a/package/network/services/hostapd/patches/014-mesh-fixes-for-mesh-init-deinit.patch b/package/network/services/hostapd/patches/014-mesh-fixes-for-mesh-init-deinit.patch
deleted file mode 100644
index fe12d401e4..0000000000
--- a/package/network/services/hostapd/patches/014-mesh-fixes-for-mesh-init-deinit.patch
+++ /dev/null
@@ -1,158 +0,0 @@
-From 30bdefd7559d57eae8c3c7e6f721ecf7be929bf2 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 14:19:02 +0200
-Subject: [PATCH 14/19] mesh: fixes for mesh init/deinit
-
-Send mesh group started notification after join completion
-callback is called.
-
-Implement outstanding TODO, to leave the mesh network on deinit.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- wpa_supplicant/mesh.c           | 32 ++++++++++++++++++++------------
- wpa_supplicant/mesh.h           |  6 ++++--
- wpa_supplicant/wpa_supplicant.c |  8 ++------
- 3 files changed, 26 insertions(+), 20 deletions(-)
-
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -30,20 +30,20 @@
- 
- static void wpa_supplicant_mesh_deinit(struct wpa_supplicant *wpa_s)
- {
--	wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh);
-+	wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh, true);
- 	wpa_s->ifmsh = NULL;
- 	wpa_s->current_ssid = NULL;
- 	os_free(wpa_s->mesh_rsn);
- 	wpa_s->mesh_rsn = NULL;
- 	os_free(wpa_s->mesh_params);
- 	wpa_s->mesh_params = NULL;
--	/* TODO: leave mesh (stop beacon). This will happen on link down
--	 * anyway, so it's not urgent */
-+	wpa_supplicant_leave_mesh(wpa_s, false);
- }
- 
- 
- void wpa_supplicant_mesh_iface_deinit(struct wpa_supplicant *wpa_s,
--				      struct hostapd_iface *ifmsh)
-+				      struct hostapd_iface *ifmsh,
-+				      bool also_clear_hostapd)
- {
- 	if (!ifmsh)
- 		return;
-@@ -64,8 +64,10 @@ void wpa_supplicant_mesh_iface_deinit(st
- 	}
- 
- 	/* take care of shared data */
--	hostapd_interface_deinit(ifmsh);
--	hostapd_interface_free(ifmsh);
-+	if (also_clear_hostapd) {
-+		hostapd_interface_deinit(ifmsh);
-+		hostapd_interface_free(ifmsh);
-+	}
- }
- 
- 
-@@ -244,8 +246,7 @@ static int wpas_mesh_complete(struct wpa
- 	    wpas_mesh_init_rsn(wpa_s)) {
- 		wpa_printf(MSG_ERROR,
- 			   "mesh: RSN initialization failed - deinit mesh");
--		wpa_supplicant_mesh_deinit(wpa_s);
--		wpa_drv_leave_mesh(wpa_s);
-+		wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh, false);
- 		return -1;
- 	}
- 
-@@ -270,9 +271,15 @@ static int wpas_mesh_complete(struct wpa
- 	/* hostapd sets the interface down until we associate */
- 	wpa_drv_set_operstate(wpa_s, 1);
- 
--	if (!ret)
-+	if (!ret) {
- 		wpa_supplicant_set_state(wpa_s, WPA_COMPLETED);
- 
-+		wpa_msg(wpa_s, MSG_INFO, MESH_GROUP_STARTED "ssid=\"%s\" id=%d",
-+			wpa_ssid_txt(ssid->ssid, ssid->ssid_len),
-+			ssid->id);
-+		wpas_notify_mesh_group_started(wpa_s, ssid);
-+	}
-+
- 	return ret;
- }
- 
-@@ -563,7 +570,7 @@ int wpa_supplicant_join_mesh(struct wpa_
- 	wpa_s->mesh_params = params;
- 	if (wpa_supplicant_mesh_init(wpa_s, ssid, &params->freq)) {
- 		wpa_msg(wpa_s, MSG_ERROR, "Failed to init mesh");
--		wpa_drv_leave_mesh(wpa_s);
-+		wpa_supplicant_leave_mesh(wpa_s, true);
- 		ret = -1;
- 		goto out;
- 	}
-@@ -573,14 +580,15 @@ out:
- }
- 
- 
--int wpa_supplicant_leave_mesh(struct wpa_supplicant *wpa_s)
-+int wpa_supplicant_leave_mesh(struct wpa_supplicant *wpa_s, bool need_deinit)
- {
- 	int ret = 0;
- 
- 	wpa_msg(wpa_s, MSG_INFO, "leaving mesh");
- 
- 	/* Need to send peering close messages first */
--	wpa_supplicant_mesh_deinit(wpa_s);
-+	if (need_deinit)
-+		wpa_supplicant_mesh_deinit(wpa_s);
- 
- 	ret = wpa_drv_leave_mesh(wpa_s);
- 	if (ret)
---- a/wpa_supplicant/mesh.h
-+++ b/wpa_supplicant/mesh.h
-@@ -11,9 +11,11 @@
- 
- int wpa_supplicant_join_mesh(struct wpa_supplicant *wpa_s,
- 			     struct wpa_ssid *ssid);
--int wpa_supplicant_leave_mesh(struct wpa_supplicant *wpa_s);
-+int wpa_supplicant_leave_mesh(struct wpa_supplicant *wpa_s,
-+			      bool need_deinit);
- void wpa_supplicant_mesh_iface_deinit(struct wpa_supplicant *wpa_s,
--				      struct hostapd_iface *ifmsh);
-+				      struct hostapd_iface *ifmsh,
-+				      bool also_clear_hostapd);
- int wpas_mesh_scan_result_text(const u8 *ies, size_t ies_len, char *buf,
- 			       char *end);
- int wpas_mesh_add_interface(struct wpa_supplicant *wpa_s, char *ifname,
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -2225,10 +2225,6 @@ void wpa_supplicant_associate(struct wpa
- 			return;
- 		}
- 		wpa_s->current_bss = bss;
--		wpa_msg(wpa_s, MSG_INFO, MESH_GROUP_STARTED "ssid=\"%s\" id=%d",
--			wpa_ssid_txt(ssid->ssid, ssid->ssid_len),
--			ssid->id);
--		wpas_notify_mesh_group_started(wpa_s, ssid);
- #else /* CONFIG_MESH */
- 		wpa_msg(wpa_s, MSG_ERROR,
- 			"mesh mode support not included in the build");
-@@ -3938,7 +3934,7 @@ void wpa_supplicant_deauthenticate(struc
- 			wpa_s->ifname);
- 		wpas_notify_mesh_group_removed(wpa_s, mconf->meshid,
- 					       mconf->meshid_len, reason_code);
--		wpa_supplicant_leave_mesh(wpa_s);
-+		wpa_supplicant_leave_mesh(wpa_s, true);
- 	}
- #endif /* CONFIG_MESH */
- 
-@@ -6551,7 +6547,7 @@ static void wpa_supplicant_deinit_iface(
- 
- #ifdef CONFIG_MESH
- 	if (wpa_s->ifmsh) {
--		wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh);
-+		wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh, true);
- 		wpa_s->ifmsh = NULL;
- 	}
- #endif /* CONFIG_MESH */
diff --git a/package/network/services/hostapd/patches/015-mesh-fix-DFS-deinit-init.patch b/package/network/services/hostapd/patches/015-mesh-fix-DFS-deinit-init.patch
deleted file mode 100644
index c540dd6786..0000000000
--- a/package/network/services/hostapd/patches/015-mesh-fix-DFS-deinit-init.patch
+++ /dev/null
@@ -1,262 +0,0 @@
-From d017f5d98a143c46c3c3fcb0e6507ca0b2bebdb0 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 14:19:03 +0200
-Subject: [PATCH 15/19] mesh: fix DFS deinit/init
-
-The hostapd DFS code deinitializes and initializes the
-AP interface, if a clean channel switch is not possible.
-In this case the AP code paths would deinit the driver, for
-example nl80211, without wpa_supplicant code paths getting
-notice of this.
-
-Therefore add callbacks for wpa_supplicant mesh methods,
-which are called on init/deinit of the AP bss. These
-callbacks are then used to handle the reset in the mesh
-code.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- src/ap/dfs.c          |  2 +-
- src/ap/hostapd.c      | 17 ++++++--
- src/ap/hostapd.h      |  6 +++
- wpa_supplicant/mesh.c | 90 +++++++++++++++++++++++++++++++++++++------
- 4 files changed, 100 insertions(+), 15 deletions(-)
-
---- a/src/ap/dfs.c
-+++ b/src/ap/dfs.c
-@@ -1112,7 +1112,7 @@ static int hostapd_dfs_start_channel_swi
- 				      oper_centr_freq_seg0_idx,
- 				      oper_centr_freq_seg1_idx,
- 				      cmode->vht_capab,
--				      &cmode->he_capab[IEEE80211_MODE_AP]);
-+				      &cmode->he_capab[iface->conf->hw_mode]);
- 
- 	if (err) {
- 		wpa_printf(MSG_ERROR, "DFS failed to calculate CSA freq params");
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -354,7 +354,7 @@ static int hostapd_broadcast_wep_set(str
- #endif /* CONFIG_WEP */
- 
- 
--static void hostapd_free_hapd_data(struct hostapd_data *hapd)
-+void hostapd_free_hapd_data(struct hostapd_data *hapd)
- {
- 	os_free(hapd->probereq_cb);
- 	hapd->probereq_cb = NULL;
-@@ -498,7 +498,7 @@ static void sta_track_deinit(struct host
- }
- 
- 
--static void hostapd_cleanup_iface_partial(struct hostapd_iface *iface)
-+void hostapd_cleanup_iface_partial(struct hostapd_iface *iface)
- {
- 	wpa_printf(MSG_DEBUG, "%s(%p)", __func__, iface);
- #ifdef NEED_AP_MLME
-@@ -626,7 +626,7 @@ static int hostapd_flush_old_stations(st
- }
- 
- 
--static void hostapd_bss_deinit_no_free(struct hostapd_data *hapd)
-+void hostapd_bss_deinit_no_free(struct hostapd_data *hapd)
- {
- 	hostapd_free_stas(hapd);
- 	hostapd_flush_old_stations(hapd, WLAN_REASON_DEAUTH_LEAVING);
-@@ -2690,6 +2690,13 @@ int hostapd_enable_iface(struct hostapd_
- {
- 	size_t j;
- 
-+	if (hapd_iface == NULL)
-+		return -1;
-+
-+	if (hapd_iface->enable_iface_cb != NULL) {
-+		return hapd_iface->enable_iface_cb(hapd_iface);
-+	}
-+
- 	if (hapd_iface->bss[0]->drv_priv != NULL) {
- 		wpa_printf(MSG_ERROR, "Interface %s already enabled",
- 			   hapd_iface->conf->bss[0]->iface);
-@@ -2751,6 +2758,10 @@ int hostapd_disable_iface(struct hostapd
- 	if (hapd_iface == NULL)
- 		return -1;
- 
-+	if (hapd_iface->disable_iface_cb != NULL) {
-+		return hapd_iface->disable_iface_cb(hapd_iface);
-+	}
-+
- 	if (hapd_iface->bss[0]->drv_priv == NULL) {
- 		wpa_printf(MSG_INFO, "Interface %s already disabled",
- 			   hapd_iface->conf->bss[0]->iface);
---- a/src/ap/hostapd.h
-+++ b/src/ap/hostapd.h
-@@ -589,6 +589,9 @@ struct hostapd_iface {
- 
- 	/* Previous WMM element information */
- 	struct hostapd_wmm_ac_params prev_wmm[WMM_AC_NUM];
-+
-+	int (*enable_iface_cb)(struct hostapd_iface *iface);
-+	int (*disable_iface_cb)(struct hostapd_iface *iface);
- };
- 
- /* hostapd.c */
-@@ -617,6 +620,9 @@ void hostapd_interface_deinit_free(struc
- int hostapd_enable_iface(struct hostapd_iface *hapd_iface);
- int hostapd_reload_iface(struct hostapd_iface *hapd_iface);
- int hostapd_disable_iface(struct hostapd_iface *hapd_iface);
-+void hostapd_bss_deinit_no_free(struct hostapd_data *hapd);
-+void hostapd_free_hapd_data(struct hostapd_data *hapd);
-+void hostapd_cleanup_iface_partial(struct hostapd_iface *iface);
- int hostapd_add_iface(struct hapd_interfaces *ifaces, char *buf);
- int hostapd_remove_iface(struct hapd_interfaces *ifaces, char *buf);
- void hostapd_channel_list_updated(struct hostapd_iface *iface, int initiator);
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -28,15 +28,20 @@
- #include "mesh.h"
- 
- 
--static void wpa_supplicant_mesh_deinit(struct wpa_supplicant *wpa_s)
-+static void wpa_supplicant_mesh_deinit(struct wpa_supplicant *wpa_s, bool also_clear_hostapd)
- {
--	wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh, true);
--	wpa_s->ifmsh = NULL;
--	wpa_s->current_ssid = NULL;
-+	wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh, also_clear_hostapd);
-+
-+	if (also_clear_hostapd) {
-+		wpa_s->ifmsh = NULL;
-+		wpa_s->current_ssid = NULL;
-+		os_free(wpa_s->mesh_params);
-+		wpa_s->mesh_params = NULL;
-+	}
-+
- 	os_free(wpa_s->mesh_rsn);
- 	wpa_s->mesh_rsn = NULL;
--	os_free(wpa_s->mesh_params);
--	wpa_s->mesh_params = NULL;
-+
- 	wpa_supplicant_leave_mesh(wpa_s, false);
- }
- 
-@@ -237,7 +242,7 @@ static int wpas_mesh_complete(struct wpa
- 				ifmsh->conf->vht_capab,
- 				he_capab)) {
- 			wpa_printf(MSG_ERROR, "Error updating mesh frequency params.");
--			wpa_supplicant_mesh_deinit(wpa_s);
-+			wpa_supplicant_mesh_deinit(wpa_s, true);
- 			return -1;
- 		}
- 	}
-@@ -246,7 +251,7 @@ static int wpas_mesh_complete(struct wpa
- 	    wpas_mesh_init_rsn(wpa_s)) {
- 		wpa_printf(MSG_ERROR,
- 			   "mesh: RSN initialization failed - deinit mesh");
--		wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh, false);
-+		wpa_supplicant_mesh_deinit(wpa_s, false);
- 		return -1;
- 	}
- 
-@@ -291,6 +296,67 @@ static void wpas_mesh_complete_cb(void *
- }
- 
- 
-+static int wpa_supplicant_mesh_enable_iface_cb(struct hostapd_iface *ifmsh)
-+{
-+	struct wpa_supplicant *wpa_s = ifmsh->owner;
-+	struct hostapd_data *bss;
-+
-+	ifmsh->mconf = mesh_config_create(wpa_s, wpa_s->current_ssid);
-+
-+	bss = ifmsh->bss[0];
-+	bss->msg_ctx = wpa_s;
-+	os_memcpy(bss->own_addr, wpa_s->own_addr, ETH_ALEN);
-+	bss->driver = wpa_s->driver;
-+	bss->drv_priv = wpa_s->drv_priv;
-+	bss->iface = ifmsh;
-+	bss->mesh_sta_free_cb = mesh_mpm_free_sta;
-+	bss->setup_complete_cb = wpas_mesh_complete_cb;
-+	bss->setup_complete_cb_ctx = wpa_s;
-+
-+	bss->conf->start_disabled = 1;
-+	bss->conf->mesh = MESH_ENABLED;
-+	bss->conf->ap_max_inactivity = wpa_s->conf->mesh_max_inactivity;
-+
-+	if (wpa_drv_init_mesh(wpa_s)) {
-+		wpa_msg(wpa_s, MSG_ERROR, "Failed to init mesh in driver");
-+		return -1;
-+	}
-+
-+	if (hostapd_setup_interface(ifmsh)) {
-+		wpa_printf(MSG_ERROR,
-+			   "Failed to initialize hostapd interface for mesh");
-+		return -1;
-+	}
-+
-+	return 0;
-+}
-+
-+
-+static int wpa_supplicant_mesh_disable_iface_cb(struct hostapd_iface *ifmsh)
-+{
-+	struct wpa_supplicant *wpa_s = ifmsh->owner;
-+	int j;
-+
-+	wpa_supplicant_mesh_deinit(wpa_s, false);
-+
-+#ifdef NEED_AP_MLME
-+	for (j = 0; j < ifmsh->num_bss; j++)
-+		hostapd_cleanup_cs_params(ifmsh->bss[j]);
-+#endif /* NEED_AP_MLME */
-+
-+	/* same as hostapd_interface_deinit without deinitializing ctrl-iface */
-+	for (j = 0; j < ifmsh->num_bss; j++) {
-+		struct hostapd_data *hapd = ifmsh->bss[j];
-+		hostapd_bss_deinit_no_free(hapd);
-+		hostapd_free_hapd_data(hapd);
-+	}
-+
-+	hostapd_cleanup_iface_partial(ifmsh);
-+
-+	return 0;
-+}
-+
-+
- static int wpa_supplicant_mesh_init(struct wpa_supplicant *wpa_s,
- 				    struct wpa_ssid *ssid,
- 				    struct hostapd_freq_params *freq)
-@@ -318,6 +384,8 @@ static int wpa_supplicant_mesh_init(stru
- 	ifmsh->drv_flags = wpa_s->drv_flags;
- 	ifmsh->drv_flags2 = wpa_s->drv_flags2;
- 	ifmsh->num_bss = 1;
-+	ifmsh->enable_iface_cb = wpa_supplicant_mesh_enable_iface_cb;
-+	ifmsh->disable_iface_cb = wpa_supplicant_mesh_disable_iface_cb;
- 	ifmsh->bss = os_calloc(wpa_s->ifmsh->num_bss,
- 			       sizeof(struct hostapd_data *));
- 	if (!ifmsh->bss)
-@@ -451,7 +519,7 @@ static int wpa_supplicant_mesh_init(stru
- 
- 	return 0;
- out_free:
--	wpa_supplicant_mesh_deinit(wpa_s);
-+	wpa_supplicant_mesh_deinit(wpa_s, true);
- 	return -ENOMEM;
- }
- 
-@@ -499,7 +567,7 @@ int wpa_supplicant_join_mesh(struct wpa_
- 		goto out;
- 	}
- 
--	wpa_supplicant_mesh_deinit(wpa_s);
-+	wpa_supplicant_mesh_deinit(wpa_s, true);
- 
- 	wpa_s->pairwise_cipher = WPA_CIPHER_NONE;
- 	wpa_s->group_cipher = WPA_CIPHER_NONE;
-@@ -588,7 +656,7 @@ int wpa_supplicant_leave_mesh(struct wpa
- 
- 	/* Need to send peering close messages first */
- 	if (need_deinit)
--		wpa_supplicant_mesh_deinit(wpa_s);
-+		wpa_supplicant_mesh_deinit(wpa_s, true);
- 
- 	ret = wpa_drv_leave_mesh(wpa_s);
- 	if (ret)
diff --git a/package/network/services/hostapd/patches/016-tests-DFS-test-for-wpa_supplicant-mesh.patch b/package/network/services/hostapd/patches/016-tests-DFS-test-for-wpa_supplicant-mesh.patch
deleted file mode 100644
index b6a51b2f35..0000000000
--- a/package/network/services/hostapd/patches/016-tests-DFS-test-for-wpa_supplicant-mesh.patch
+++ /dev/null
@@ -1,94 +0,0 @@
-From 6ee4e70d469b8ce05013ed524eea32ea303e6563 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 14:19:04 +0200
-Subject: [PATCH 16/19] tests: DFS test for wpa_supplicant mesh
-
-Add a test with uses a DFS channel, waits for CAC
-afterwards successfull mesh join and then triggers
-a radar event and check if the mesh comes up again
-on the same device.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- tests/hwsim/test_wpas_mesh.py | 56 +++++++++++++++++++++++++++++++++--
- 1 file changed, 54 insertions(+), 2 deletions(-)
-
---- a/tests/hwsim/test_wpas_mesh.py
-+++ b/tests/hwsim/test_wpas_mesh.py
-@@ -80,8 +80,23 @@ def check_mesh_scan(dev, params, other_s
-     if '[MESH]' not in bss['flags']:
-         raise Exception("BSS output did not include MESH flag")
- 
--def check_mesh_group_added(dev):
--    ev = dev.wait_event(["MESH-GROUP-STARTED"])
-+def check_dfs_started(dev, timeout=10):
-+    ev = dev.wait_event(["DFS-CAC-START"], timeout=timeout)
-+    if ev is None:
-+        raise Exception("Test exception: CAC did not start")
-+
-+def check_dfs_finished(dev, timeout=70):
-+    ev = dev.wait_event(["DFS-CAC-COMPLETED"], timeout=timeout)
-+    if ev is None:
-+        raise Exception("Test exception: CAC did not finish")
-+
-+def check_mesh_radar_handling_finished(dev, timeout=75):
-+    ev = dev.wait_event(["CTRL-EVENT-CHANNEL-SWITCH", "MESH-GROUP-STARTED"], timeout=timeout)
-+    if ev is None:
-+        raise Exception("Test exception: Couldn't join mesh")
-+
-+def check_mesh_group_added(dev, timeout=10):
-+    ev = dev.wait_event(["MESH-GROUP-STARTED"], timeout=timeout)
-     if ev is None:
-         raise Exception("Test exception: Couldn't join mesh")
- 
-@@ -91,6 +106,10 @@ def check_mesh_group_removed(dev):
-     if ev is None:
-         raise Exception("Test exception: Couldn't leave mesh")
- 
-+def check_regdom_change(dev, timeout=10):
-+    ev = dev.wait_event(["CTRL-EVENT-REGDOM-CHANGE"], timeout=timeout)
-+    if ev is None:
-+        raise Exception("Test exception: No regdom change happened.")
- 
- def check_mesh_peer_connected(dev, timeout=10):
-     ev = dev.wait_event(["MESH-PEER-CONNECTED"], timeout=timeout)
-@@ -167,6 +186,39 @@ def test_wpas_mesh_group_remove(dev):
-     check_mesh_group_removed(dev[0])
-     dev[0].mesh_group_remove()
- 
-+def dfs_simulate_radar(dev):
-+    logger.info("Trigger a simulated radar event")
-+    phyname = dev.get_driver_status_field("phyname")
-+    radar_file = '/sys/kernel/debug/ieee80211/' + phyname + '/hwsim/dfs_simulate_radar'
-+    with open(radar_file, 'w') as f:
-+        f.write('1')
-+
-+@long_duration_test
-+def test_wpas_mesh_peer_connected_dfs(dev):
-+    """wpa_supplicant MESH peer connected"""
-+    dev[0].set("country", "DE")
-+    dev[1].set("country", "DE")
-+
-+    check_regdom_change(dev[0])
-+    check_regdom_change(dev[1])
-+
-+    check_mesh_support(dev[0])
-+    add_open_mesh_network(dev[0], freq="5500", beacon_int=160)
-+    add_open_mesh_network(dev[1], freq="5500", beacon_int=160)
-+    check_dfs_started(dev[0])
-+    check_dfs_finished(dev[0])
-+    check_mesh_joined_connected(dev, timeout0=10)
-+
-+    dfs_simulate_radar(dev[0])
-+
-+    check_mesh_radar_handling_finished(dev[0], timeout=75)
-+
-+    dev[0].set("country", "00")
-+    dev[1].set("country", "00")
-+
-+    check_regdom_change(dev[0])
-+    check_regdom_change(dev[1])
-+
- def test_wpas_mesh_peer_connected(dev):
-     """wpa_supplicant MESH peer connected"""
-     check_mesh_support(dev[0])
diff --git a/package/network/services/hostapd/patches/017-mesh-fix-mesh_oom-test.patch b/package/network/services/hostapd/patches/017-mesh-fix-mesh_oom-test.patch
deleted file mode 100644
index cc566c7de2..0000000000
--- a/package/network/services/hostapd/patches/017-mesh-fix-mesh_oom-test.patch
+++ /dev/null
@@ -1,24 +0,0 @@
-From 928da9a270deaf4409aee4d87a33a6f61b56c136 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 14:19:05 +0200
-Subject: [PATCH 17/19] mesh: fix mesh_oom test
-
-Only change freq params, if ifmsh->freq is set initially, which only
-happens if hostapd_get_hw_features in setup_interface2 succeeds.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- wpa_supplicant/mesh.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -218,7 +218,7 @@ static int wpas_mesh_complete(struct wpa
- 	 * inspect if channel's been changed since initialized.
- 	 * i.e. DFS radar detection
- 	 */
--	if (ifmsh->freq != params->freq.freq) {
-+	if (ifmsh->freq > 0 && ifmsh->freq != params->freq.freq) {
- 		wpa_s->assoc_freq = ifmsh->freq;
- 		ssid->frequency = ifmsh->freq;
- 		struct he_capabilities *he_capab = NULL;
diff --git a/package/network/services/hostapd/patches/018-mesh-move-mesh-freq-setting-to-own-function.patch b/package/network/services/hostapd/patches/018-mesh-move-mesh-freq-setting-to-own-function.patch
deleted file mode 100644
index 1dd7d37411..0000000000
--- a/package/network/services/hostapd/patches/018-mesh-move-mesh-freq-setting-to-own-function.patch
+++ /dev/null
@@ -1,93 +0,0 @@
-From 1eab0e62920f443f8814bad846f6439843223b69 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 14:19:06 +0200
-Subject: [PATCH 18/19] mesh: move mesh freq setting to own function
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- wpa_supplicant/mesh.c | 59 ++++++++++++++++++++++++++-----------------
- 1 file changed, 36 insertions(+), 23 deletions(-)
-
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -201,6 +201,40 @@ static int wpas_mesh_init_rsn(struct wpa
- 	return !wpa_s->mesh_rsn ? -1 : 0;
- }
- 
-+
-+static int wpas_mesh_update_freq_params(struct wpa_supplicant *wpa_s)
-+{
-+	struct wpa_driver_mesh_join_params *params = wpa_s->mesh_params;
-+	struct hostapd_iface *ifmsh = wpa_s->ifmsh;
-+	struct he_capabilities *he_capab = NULL;
-+
-+	if (ifmsh->current_mode)
-+		he_capab = &ifmsh->current_mode->he_capab[IEEE80211_MODE_MESH];
-+
-+	if (hostapd_set_freq_params(&params->freq,
-+			ifmsh->conf->hw_mode,
-+			ifmsh->freq,
-+			ifmsh->conf->channel,
-+			ifmsh->conf->enable_edmg,
-+			ifmsh->conf->edmg_channel,
-+			ifmsh->conf->ieee80211n,
-+			ifmsh->conf->ieee80211ac,
-+			ifmsh->conf->ieee80211ax,
-+			ifmsh->conf->secondary_channel,
-+			hostapd_get_oper_chwidth(ifmsh->conf),
-+			hostapd_get_oper_centr_freq_seg0_idx(ifmsh->conf),
-+			hostapd_get_oper_centr_freq_seg1_idx(ifmsh->conf),
-+			ifmsh->conf->vht_capab,
-+			he_capab)) {
-+		wpa_printf(MSG_ERROR, "Error updating mesh frequency params.");
-+		wpa_supplicant_mesh_deinit(wpa_s, true);
-+		return -1;
-+	}
-+
-+	return 0;
-+}
-+
-+
- static int wpas_mesh_complete(struct wpa_supplicant *wpa_s)
- {
- 	struct hostapd_iface *ifmsh = wpa_s->ifmsh;
-@@ -221,30 +255,8 @@ static int wpas_mesh_complete(struct wpa
- 	if (ifmsh->freq > 0 && ifmsh->freq != params->freq.freq) {
- 		wpa_s->assoc_freq = ifmsh->freq;
- 		ssid->frequency = ifmsh->freq;
--		struct he_capabilities *he_capab = NULL;
--
--		if (ifmsh->current_mode)
--			he_capab = &ifmsh->current_mode->he_capab[IEEE80211_MODE_MESH];
--
--		if (hostapd_set_freq_params(&params->freq,
--				ifmsh->conf->hw_mode,
--				ifmsh->freq,
--				ifmsh->conf->channel,
--				ifmsh->conf->enable_edmg,
--				ifmsh->conf->edmg_channel,
--				ifmsh->conf->ieee80211n,
--				ifmsh->conf->ieee80211ac,
--				ifmsh->conf->ieee80211ax,
--				ifmsh->conf->secondary_channel,
--				hostapd_get_oper_chwidth(ifmsh->conf),
--				hostapd_get_oper_centr_freq_seg0_idx(ifmsh->conf),
--				hostapd_get_oper_centr_freq_seg1_idx(ifmsh->conf),
--				ifmsh->conf->vht_capab,
--				he_capab)) {
--			wpa_printf(MSG_ERROR, "Error updating mesh frequency params.");
--			wpa_supplicant_mesh_deinit(wpa_s, true);
-+		if (wpas_mesh_update_freq_params(wpa_s) != 0)
- 			return -1;
--		}
- 	}
- 
- 	if (ifmsh->mconf->security != MESH_CONF_SEC_NONE &&
-@@ -518,6 +530,7 @@ static int wpa_supplicant_mesh_init(stru
- 	}
- 
- 	return 0;
-+
- out_free:
- 	wpa_supplicant_mesh_deinit(wpa_s, true);
- 	return -ENOMEM;
diff --git a/package/network/services/hostapd/patches/020-ignore-4addr-mode-enabling-error.patch b/package/network/services/hostapd/patches/020-ignore-4addr-mode-enabling-error.patch
deleted file mode 100644
index f6751829a5..0000000000
--- a/package/network/services/hostapd/patches/020-ignore-4addr-mode-enabling-error.patch
+++ /dev/null
@@ -1,73 +0,0 @@
-From c7cca9b08f3e1e49c4a4a59ec66c47d91448e6ae Mon Sep 17 00:00:00 2001
-From: Jouni Malinen <j@w1.fi>
-Date: Sat, 13 Feb 2021 23:59:28 +0200
-Subject: [PATCH] nl80211: Ignore 4addr mode enabling error if it was already
- enabled
-
-nl80211_set_4addr_mode() could fail when trying to enable 4addr mode on
-an interface that is in a bridge and has 4addr mode already enabled.
-This operation would not have been necessary in the first place and this
-failure results in disconnecting, e.g., when roaming from one backhaul
-BSS to another BSS with Multi AP.
-
-Avoid this issue by ignoring the nl80211 command failure in the case
-where 4addr mode is being enabled while it has already been enabled.
-
-Signed-off-by: Jouni Malinen <j@w1.fi>
----
- src/drivers/driver_nl80211.c | 23 +++++++++++++++++++++++
- 1 file changed, 23 insertions(+)
-
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -617,6 +617,7 @@ struct wiphy_idx_data {
- 	int wiphy_idx;
- 	enum nl80211_iftype nlmode;
- 	u8 *macaddr;
-+	u8 use_4addr;
- };
- 
- 
-@@ -639,6 +640,9 @@ static int netdev_info_handler(struct nl
- 		os_memcpy(info->macaddr, nla_data(tb[NL80211_ATTR_MAC]),
- 			  ETH_ALEN);
- 
-+	if (tb[NL80211_ATTR_4ADDR])
-+		info->use_4addr = nla_get_u8(tb[NL80211_ATTR_4ADDR]);
-+
- 	return NL_SKIP;
- }
- 
-@@ -691,6 +695,20 @@ static int nl80211_get_macaddr(struct i8
- }
- 
- 
-+static int nl80211_get_4addr(struct i802_bss *bss)
-+{
-+	struct nl_msg *msg;
-+	struct wiphy_idx_data data = {
-+		.use_4addr = 0,
-+	};
-+
-+	if (!(msg = nl80211_cmd_msg(bss, 0, NL80211_CMD_GET_INTERFACE)) ||
-+	    send_and_recv_msgs(bss->drv, msg, netdev_info_handler, &data))
-+		return -1;
-+	return data.use_4addr;
-+}
-+
-+
- static int nl80211_register_beacons(struct wpa_driver_nl80211_data *drv,
- 				    struct nl80211_wiphy_data *w)
- {
-@@ -11508,6 +11526,11 @@ static int nl80211_set_4addr_mode(void *
- 
- 	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
- 	msg = NULL;
-+	if (ret && val && nl80211_get_4addr(bss) == 1) {
-+		wpa_printf(MSG_DEBUG,
-+			   "nl80211: 4addr mode was already enabled");
-+		ret = 0;
-+	}
- 	if (!ret) {
- 		if (bridge_ifname[0] && val &&
- 		    i802_check_bridge(drv, bss, bridge_ifname, bss->ifname) < 0)
diff --git a/package/network/services/hostapd/patches/021-fix-sta-add-after-previous-connection.patch b/package/network/services/hostapd/patches/021-fix-sta-add-after-previous-connection.patch
new file mode 100644
index 0000000000..ac02ec5ab7
--- /dev/null
+++ b/package/network/services/hostapd/patches/021-fix-sta-add-after-previous-connection.patch
@@ -0,0 +1,26 @@
+--- a/src/ap/ieee802_11.c
++++ b/src/ap/ieee802_11.c
+@@ -4944,6 +4944,13 @@ static int add_associated_sta(struct hos
+ 	 * drivers to accept the STA parameter configuration. Since this is
+ 	 * after a new FT-over-DS exchange, a new TK has been derived, so key
+ 	 * reinstallation is not a concern for this case.
++	 *
++	 * If the STA was associated and authorized earlier, but came for a new
++	 * connection (!added_unassoc + !reassoc), remove the existing STA entry
++	 * so that it can be re-added. This case is rarely seen when the AP could
++	 * not receive the deauth/disassoc frame from the STA. And the STA comes
++	 * back with new connection within a short period or before the inactive
++	 * STA entry is removed from the list.
+ 	 */
+ 	wpa_printf(MSG_DEBUG, "Add associated STA " MACSTR
+ 		   " (added_unassoc=%d auth_alg=%u ft_over_ds=%u reassoc=%d authorized=%d ft_tk=%d fils_tk=%d)",
+@@ -4957,7 +4964,8 @@ static int add_associated_sta(struct hos
+ 	    (!(sta->flags & WLAN_STA_AUTHORIZED) ||
+ 	     (reassoc && sta->ft_over_ds && sta->auth_alg == WLAN_AUTH_FT) ||
+ 	     (!wpa_auth_sta_ft_tk_already_set(sta->wpa_sm) &&
+-	      !wpa_auth_sta_fils_tk_already_set(sta->wpa_sm)))) {
++	      !wpa_auth_sta_fils_tk_already_set(sta->wpa_sm)) ||
++	     (!reassoc && (sta->flags & WLAN_STA_AUTHORIZED)))) {
+ 		hostapd_drv_sta_remove(hapd, sta->addr);
+ 		wpa_auth_sm_event(sta->wpa_sm, WPA_DRV_STA_REMOVED);
+ 		set = 0;
diff --git a/package/network/services/hostapd/patches/022-hostapd-fix-use-of-uninitialized-stack-variables.patch b/package/network/services/hostapd/patches/022-hostapd-fix-use-of-uninitialized-stack-variables.patch
new file mode 100644
index 0000000000..c7da33f029
--- /dev/null
+++ b/package/network/services/hostapd/patches/022-hostapd-fix-use-of-uninitialized-stack-variables.patch
@@ -0,0 +1,25 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Thu, 8 Jul 2021 16:33:03 +0200
+Subject: [PATCH] hostapd: fix use of uninitialized stack variables
+
+When a CSA is performed on an 80 MHz channel, hostapd_change_config_freq
+unconditionally calls hostapd_set_oper_centr_freq_seg0/1_idx with seg0/1
+filled by ieee80211_freq_to_chan.
+However, if ieee80211_freq_to_chan fails (because the freq is 0 or invalid),
+seg0/1 remains uninitialized and filled with stack garbage, causing errors
+such as "hostapd: 80 MHz: center segment 1 configured"
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/src/ap/hostapd.c
++++ b/src/ap/hostapd.c
+@@ -3431,7 +3431,7 @@ static int hostapd_change_config_freq(st
+ 				      struct hostapd_freq_params *old_params)
+ {
+ 	int channel;
+-	u8 seg0, seg1;
++	u8 seg0 = 0, seg1 = 0;
+ 	struct hostapd_hw_modes *mode;
+ 
+ 	if (!params->channel) {
diff --git a/package/network/services/hostapd/patches/030-driver_nl80211-rewrite-neigh-code-to-not-depend-on-l.patch b/package/network/services/hostapd/patches/030-driver_nl80211-rewrite-neigh-code-to-not-depend-on-l.patch
index f65362fe96..ade0b11311 100644
--- a/package/network/services/hostapd/patches/030-driver_nl80211-rewrite-neigh-code-to-not-depend-on-l.patch
+++ b/package/network/services/hostapd/patches/030-driver_nl80211-rewrite-neigh-code-to-not-depend-on-l.patch
@@ -20,7 +20,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  #include <linux/rtnetlink.h>
  #include <netpacket/packet.h>
  #include <linux/errqueue.h>
-@@ -4965,26 +4962,29 @@ fail:
+@@ -5300,26 +5297,29 @@ fail:
  
  static void rtnl_neigh_delete_fdb_entry(struct i802_bss *bss, const u8 *addr)
  {
@@ -64,7 +64,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  	if (err < 0) {
  		wpa_printf(MSG_DEBUG, "nl80211: bridge FDB entry delete for "
  			   MACSTR " ifindex=%d failed: %s", MAC2STR(addr),
-@@ -4994,9 +4994,8 @@ static void rtnl_neigh_delete_fdb_entry(
+@@ -5329,9 +5329,8 @@ static void rtnl_neigh_delete_fdb_entry(
  			   MACSTR, MAC2STR(addr));
  	}
  
@@ -76,7 +76,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  }
  
  
-@@ -7337,7 +7336,6 @@ static void *i802_init(struct hostapd_da
+@@ -7714,7 +7713,6 @@ static void *i802_init(struct hostapd_da
  	    (params->num_bridge == 0 || !params->bridge[0]))
  		add_ifidx(drv, br_ifindex, drv->ifindex);
  
@@ -84,7 +84,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  	if (bss->added_if_into_bridge || bss->already_in_bridge) {
  		int err;
  
-@@ -7354,7 +7352,6 @@ static void *i802_init(struct hostapd_da
+@@ -7731,7 +7729,6 @@ static void *i802_init(struct hostapd_da
  			goto failed;
  		}
  	}
@@ -92,7 +92,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  
  	if (drv->capa.flags2 & WPA_DRIVER_FLAGS2_CONTROL_PORT_RX) {
  		wpa_printf(MSG_DEBUG,
-@@ -10238,13 +10235,14 @@ static int wpa_driver_br_add_ip_neigh(vo
+@@ -10678,13 +10675,14 @@ static int wpa_driver_br_add_ip_neigh(vo
  				      const u8 *ipaddr, int prefixlen,
  				      const u8 *addr)
  {
@@ -112,7 +112,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  	int res;
  
  	if (!ipaddr || prefixlen == 0 || !addr)
-@@ -10263,85 +10261,66 @@ static int wpa_driver_br_add_ip_neigh(vo
+@@ -10703,85 +10701,66 @@ static int wpa_driver_br_add_ip_neigh(vo
  	}
  
  	if (version == 4) {
@@ -220,7 +220,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  		addrsize = 16;
  	} else {
  		return -EINVAL;
-@@ -10359,41 +10338,30 @@ static int wpa_driver_br_delete_ip_neigh
+@@ -10799,41 +10778,30 @@ static int wpa_driver_br_delete_ip_neigh
  		return -1;
  	}
  
diff --git a/package/network/services/hostapd/patches/040-mesh-allow-processing-authentication-frames-in-block.patch b/package/network/services/hostapd/patches/040-mesh-allow-processing-authentication-frames-in-block.patch
index 55dd980cd7..6d9fd81acf 100644
--- a/package/network/services/hostapd/patches/040-mesh-allow-processing-authentication-frames-in-block.patch
+++ b/package/network/services/hostapd/patches/040-mesh-allow-processing-authentication-frames-in-block.patch
@@ -16,7 +16,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 
 --- a/src/ap/ieee802_11.c
 +++ b/src/ap/ieee802_11.c
-@@ -2527,15 +2527,6 @@ static void handle_auth(struct hostapd_d
+@@ -3761,15 +3761,6 @@ static void handle_auth(struct hostapd_d
  				       seq_ctrl);
  			return;
  		}
@@ -29,6 +29,6 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 -			return;
 -		}
 -#endif /* CONFIG_MESH */
- 	} else {
- #ifdef CONFIG_MESH
- 		if (hapd->conf->mesh & MESH_ENABLED) {
+ #ifdef CONFIG_PASN
+ 		if (auth_alg == WLAN_AUTH_PASN &&
+ 		    (sta->flags & WLAN_STA_ASSOC)) {
diff --git a/package/network/services/hostapd/patches/050-build_fix.patch b/package/network/services/hostapd/patches/050-build_fix.patch
new file mode 100644
index 0000000000..2652a83316
--- /dev/null
+++ b/package/network/services/hostapd/patches/050-build_fix.patch
@@ -0,0 +1,20 @@
+--- a/hostapd/Makefile
++++ b/hostapd/Makefile
+@@ -323,6 +323,7 @@ ifdef CONFIG_FILS
+ CFLAGS += -DCONFIG_FILS
+ OBJS += ../src/ap/fils_hlp.o
+ NEED_SHA384=y
++NEED_HMAC_SHA384_KDF=y
+ NEED_AES_SIV=y
+ ifdef CONFIG_FILS_SK_PFS
+ CFLAGS += -DCONFIG_FILS_SK_PFS
+--- a/wpa_supplicant/Makefile
++++ b/wpa_supplicant/Makefile
+@@ -312,6 +312,7 @@ endif
+ ifdef CONFIG_FILS
+ CFLAGS += -DCONFIG_FILS
+ NEED_SHA384=y
++NEED_HMAC_SHA384_KDF=y
+ NEED_AES_SIV=y
+ ifdef CONFIG_FILS_SK_PFS
+ CFLAGS += -DCONFIG_FILS_SK_PFS
diff --git a/package/network/services/hostapd/patches/050-mesh-make-forwarding-configurable.patch b/package/network/services/hostapd/patches/050-mesh-make-forwarding-configurable.patch
deleted file mode 100644
index 4d64ec8287..0000000000
--- a/package/network/services/hostapd/patches/050-mesh-make-forwarding-configurable.patch
+++ /dev/null
@@ -1,219 +0,0 @@
-From 90fe6429624fc48bc0e5d2d7eeecb7498708b5e3 Mon Sep 17 00:00:00 2001
-From: Daniel Golle <daniel@makrotopia.org>
-Date: Wed, 18 Apr 2018 19:24:31 +0200
-Subject: [PATCH 18/18] mesh: make forwarding configurable
-
-Allow mesh_fwding to be specified in a mesh bss config, pass that
-to the driver (only nl80211 implemented for now) and announce
-forwarding capability accordingly.
-
-Signed-off-by: Daniel Golle <daniel@makrotopia.org>
----
- src/ap/ap_config.h                 | 2 ++
- src/drivers/driver.h               | 2 ++
- src/drivers/driver_nl80211.c       | 3 +++
- wpa_supplicant/config.c            | 4 ++++
- wpa_supplicant/config.h            | 9 +++++++++
- wpa_supplicant/config_file.c       | 4 ++++
- wpa_supplicant/config_ssid.h       | 5 +++++
- wpa_supplicant/mesh.c              | 6 ++++++
- wpa_supplicant/mesh_mpm.c          | 4 ++--
- wpa_supplicant/wpa_supplicant.conf | 3 +++
- 10 files changed, 40 insertions(+), 2 deletions(-)
-
---- a/src/ap/ap_config.h
-+++ b/src/ap/ap_config.h
-@@ -51,6 +51,7 @@ struct mesh_conf {
- 	int dot11MeshRetryTimeout; /* msec */
- 	int dot11MeshConfirmTimeout; /* msec */
- 	int dot11MeshHoldingTimeout; /* msec */
-+	int mesh_fwding;
- };
- 
- #define MAX_STA_COUNT 2007
-@@ -701,6 +702,7 @@ struct hostapd_bss_config {
- 
- #define MESH_ENABLED BIT(0)
- 	int mesh;
-+	int mesh_fwding;
- 
- 	u8 radio_measurements[RRM_CAPABILITIES_IE_LEN];
- 
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -1515,6 +1515,7 @@ struct wpa_driver_mesh_bss_params {
- #define WPA_DRIVER_MESH_CONF_FLAG_MAX_PEER_LINKS	0x00000004
- #define WPA_DRIVER_MESH_CONF_FLAG_HT_OP_MODE		0x00000008
- #define WPA_DRIVER_MESH_CONF_FLAG_RSSI_THRESHOLD	0x00000010
-+#define WPA_DRIVER_MESH_CONF_FLAG_FORWARDING		0x00000020
- 	/*
- 	 * TODO: Other mesh configuration parameters would go here.
- 	 * See NL80211_MESHCONF_* for all the mesh config parameters.
-@@ -1524,6 +1525,7 @@ struct wpa_driver_mesh_bss_params {
- 	int peer_link_timeout;
- 	int max_peer_links;
- 	int rssi_threshold;
-+	int forwarding;
- 	u16 ht_opmode;
- };
- 
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -10038,6 +10038,9 @@ static int nl80211_put_mesh_config(struc
- 	if (((params->flags & WPA_DRIVER_MESH_CONF_FLAG_AUTO_PLINKS) &&
- 	     nla_put_u8(msg, NL80211_MESHCONF_AUTO_OPEN_PLINKS,
- 			params->auto_plinks)) ||
-+	    ((params->flags & WPA_DRIVER_MESH_CONF_FLAG_FORWARDING) &&
-+	     nla_put_u8(msg, NL80211_MESHCONF_FORWARDING,
-+			params->forwarding)) ||
- 	    ((params->flags & WPA_DRIVER_MESH_CONF_FLAG_MAX_PEER_LINKS) &&
- 	     nla_put_u16(msg, NL80211_MESHCONF_MAX_PEER_LINKS,
- 			 params->max_peer_links)) ||
---- a/wpa_supplicant/config.c
-+++ b/wpa_supplicant/config.c
-@@ -2473,6 +2473,7 @@ static const struct parse_data ssid_fiel
- #ifdef CONFIG_MESH
- 	{ INT_RANGE(mode, 0, 5) },
- 	{ INT_RANGE(no_auto_peer, 0, 1) },
-+	{ INT_RANGE(mesh_fwding, 0, 1) },
- 	{ INT_RANGE(mesh_rssi_threshold, -255, 1) },
- #else /* CONFIG_MESH */
- 	{ INT_RANGE(mode, 0, 4) },
-@@ -3049,6 +3050,7 @@ void wpa_config_set_network_defaults(str
- 	ssid->dot11MeshRetryTimeout = DEFAULT_MESH_RETRY_TIMEOUT;
- 	ssid->dot11MeshConfirmTimeout = DEFAULT_MESH_CONFIRM_TIMEOUT;
- 	ssid->dot11MeshHoldingTimeout = DEFAULT_MESH_HOLDING_TIMEOUT;
-+	ssid->mesh_fwding = DEFAULT_MESH_FWDING;
- 	ssid->mesh_rssi_threshold = DEFAULT_MESH_RSSI_THRESHOLD;
- #endif /* CONFIG_MESH */
- #ifdef CONFIG_HT_OVERRIDES
-@@ -4276,6 +4278,7 @@ struct wpa_config * wpa_config_alloc_emp
- 	config->user_mpm = DEFAULT_USER_MPM;
- 	config->max_peer_links = DEFAULT_MAX_PEER_LINKS;
- 	config->mesh_max_inactivity = DEFAULT_MESH_MAX_INACTIVITY;
-+	config->mesh_fwding = DEFAULT_MESH_FWDING;
- 	config->dot11RSNASAERetransPeriod =
- 		DEFAULT_DOT11_RSNA_SAE_RETRANS_PERIOD;
- 	config->fast_reauth = DEFAULT_FAST_REAUTH;
-@@ -4914,6 +4917,7 @@ static const struct global_parse_data gl
- 	{ INT(user_mpm), 0 },
- 	{ INT_RANGE(max_peer_links, 0, 255), 0 },
- 	{ INT(mesh_max_inactivity), 0 },
-+	{ INT_RANGE(mesh_fwding, 0, 1), 0 },
- 	{ INT(dot11RSNASAERetransPeriod), 0 },
- #endif /* CONFIG_MESH */
- 	{ INT(disable_scan_offload), 0 },
---- a/wpa_supplicant/config.h
-+++ b/wpa_supplicant/config.h
-@@ -18,6 +18,7 @@
- #define DEFAULT_USER_MPM 1
- #define DEFAULT_MAX_PEER_LINKS 99
- #define DEFAULT_MESH_MAX_INACTIVITY 300
-+#define DEFAULT_MESH_FWDING 1
- /*
-  * The default dot11RSNASAERetransPeriod is defined as 40 ms in the standard,
-  * but use 1000 ms in practice to avoid issues on low power CPUs.
-@@ -1351,6 +1352,14 @@ struct wpa_config {
- 	int mesh_max_inactivity;
- 
- 	/**
-+	 * mesh_fwding - Mesh network layer-2 forwarding
-+	 *
-+	 * This controls whether to enable layer-2 forwarding.
-+	 * By default: 1: enabled
-+	 */
-+	int mesh_fwding;
-+
-+	/**
- 	 * dot11RSNASAERetransPeriod - Timeout to retransmit SAE Auth frame
- 	 *
- 	 * This timeout value is used in mesh STA to retransmit
---- a/wpa_supplicant/config_file.c
-+++ b/wpa_supplicant/config_file.c
-@@ -866,6 +866,7 @@ static void wpa_config_write_network(FIL
- #endif /* IEEE8021X_EAPOL */
- 	INT(mode);
- 	INT(no_auto_peer);
-+	INT(mesh_fwding);
- 	INT(frequency);
- 	INT(enable_edmg);
- 	INT(edmg_channel);
-@@ -1527,6 +1528,9 @@ static void wpa_config_write_global(FILE
- 		fprintf(f, "mesh_max_inactivity=%d\n",
- 			config->mesh_max_inactivity);
- 
-+	if (config->mesh_fwding != DEFAULT_MESH_FWDING)
-+		fprintf(f, "mesh_fwding=%d\n", config->mesh_fwding);
-+
- 	if (config->dot11RSNASAERetransPeriod !=
- 	    DEFAULT_DOT11_RSNA_SAE_RETRANS_PERIOD)
- 		fprintf(f, "dot11RSNASAERetransPeriod=%d\n",
---- a/wpa_supplicant/config_ssid.h
-+++ b/wpa_supplicant/config_ssid.h
-@@ -546,6 +546,11 @@ struct wpa_ssid {
- 	int dot11MeshConfirmTimeout; /* msec */
- 	int dot11MeshHoldingTimeout; /* msec */
- 
-+	/**
-+	 * Mesh network layer-2 forwarding
-+	 */
-+	int mesh_fwding;
-+
- 	int ht;
- 	int ht40;
- 
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -137,6 +137,7 @@ static struct mesh_conf * mesh_config_cr
- 	conf->mesh_cc_id = 0;
- 	conf->mesh_sp_id = MESH_SYNC_METHOD_NEIGHBOR_OFFSET;
- 	conf->mesh_auth_id = (conf->security & MESH_CONF_SEC_AUTH) ? 1 : 0;
-+	conf->mesh_fwding = ssid->mesh_fwding;
- 	conf->dot11MeshMaxRetries = ssid->dot11MeshMaxRetries;
- 	conf->dot11MeshRetryTimeout = ssid->dot11MeshRetryTimeout;
- 	conf->dot11MeshConfirmTimeout = ssid->dot11MeshConfirmTimeout;
-@@ -434,6 +435,7 @@ static int wpa_supplicant_mesh_init(stru
- 	bss->conf->start_disabled = 1;
- 	bss->conf->mesh = MESH_ENABLED;
- 	bss->conf->ap_max_inactivity = wpa_s->conf->mesh_max_inactivity;
-+	bss->conf->mesh_fwding = wpa_s->conf->mesh_fwding;
- 
- 	if (ieee80211_is_dfs(ssid->frequency, wpa_s->hw.modes,
- 			     wpa_s->hw.num_modes) && wpa_s->conf->country[0]) {
-@@ -647,6 +649,10 @@ int wpa_supplicant_join_mesh(struct wpa_
- 	}
- 	params->conf.peer_link_timeout = wpa_s->conf->mesh_max_inactivity;
- 
-+	/* always explicitely set forwarding to on or off for now */
-+	params->conf.flags |= WPA_DRIVER_MESH_CONF_FLAG_FORWARDING;
-+	params->conf.forwarding = ssid->mesh_fwding;
-+
- 	os_free(wpa_s->mesh_params);
- 	wpa_s->mesh_params = params;
- 	if (wpa_supplicant_mesh_init(wpa_s, ssid, &params->freq)) {
---- a/wpa_supplicant/mesh_mpm.c
-+++ b/wpa_supplicant/mesh_mpm.c
-@@ -303,9 +303,9 @@ static void mesh_mpm_send_plink_action(s
- 		info = (bss->num_plinks > 63 ? 63 : bss->num_plinks) << 1;
- 		/* TODO: Add Connected to Mesh Gate/AS subfields */
- 		wpabuf_put_u8(buf, info);
--		/* always forwarding & accepting plinks for now */
-+		/* set forwarding & always accepting plinks for now */
- 		wpabuf_put_u8(buf, MESH_CAP_ACCEPT_ADDITIONAL_PEER |
--			      MESH_CAP_FORWARDING);
-+			      (conf->mesh_fwding ? MESH_CAP_FORWARDING : 0));
- 	} else {	/* Peer closing frame */
- 		/* IE: Mesh ID */
- 		wpabuf_put_u8(buf, WLAN_EID_MESH_ID);
---- a/wpa_supplicant/wpa_supplicant.conf
-+++ b/wpa_supplicant/wpa_supplicant.conf
-@@ -150,6 +150,9 @@ ap_scan=1
- # This timeout value is used in mesh STA to clean up inactive stations.
- #mesh_max_inactivity=300
- 
-+# Enable 802.11s layer-2 routing and forwarding
-+#mesh_fwding=1
-+
- # cert_in_cb - Whether to include a peer certificate dump in events
- # This controls whether peer certificates for authentication server and
- # its certificate chain are included in EAP peer certificate events. This is
diff --git a/package/network/services/hostapd/patches/060-P2P-Fix-a-corner-case-in-peer-addition-based-on-PD-R.patch b/package/network/services/hostapd/patches/060-P2P-Fix-a-corner-case-in-peer-addition-based-on-PD-R.patch
deleted file mode 100644
index 1202ff3725..0000000000
--- a/package/network/services/hostapd/patches/060-P2P-Fix-a-corner-case-in-peer-addition-based-on-PD-R.patch
+++ /dev/null
@@ -1,45 +0,0 @@
-From 8460e3230988ef2ec13ce6b69b687e941f6cdb32 Mon Sep 17 00:00:00 2001
-From: Jouni Malinen <jouni@codeaurora.org>
-Date: Tue, 8 Dec 2020 23:52:50 +0200
-Subject: [PATCH] P2P: Fix a corner case in peer addition based on PD Request
-
-p2p_add_device() may remove the oldest entry if there is no room in the
-peer table for a new peer. This would result in any pointer to that
-removed entry becoming stale. A corner case with an invalid PD Request
-frame could result in such a case ending up using (read+write) freed
-memory. This could only by triggered when the peer table has reached its
-maximum size and the PD Request frame is received from the P2P Device
-Address of the oldest remaining entry and the frame has incorrect P2P
-Device Address in the payload.
-
-Fix this by fetching the dev pointer again after having called
-p2p_add_device() so that the stale pointer cannot be used.
-
-Fixes: 17bef1e97a50 ("P2P: Add peer entry based on Provision Discovery Request")
-Signed-off-by: Jouni Malinen <jouni@codeaurora.org>
----
- src/p2p/p2p_pd.c | 12 +++++-------
- 1 file changed, 5 insertions(+), 7 deletions(-)
-
---- a/src/p2p/p2p_pd.c
-+++ b/src/p2p/p2p_pd.c
-@@ -595,14 +595,12 @@ void p2p_process_prov_disc_req(struct p2
- 			goto out;
- 		}
- 
-+		dev = p2p_get_device(p2p, sa);
- 		if (!dev) {
--			dev = p2p_get_device(p2p, sa);
--			if (!dev) {
--				p2p_dbg(p2p,
--					"Provision Discovery device not found "
--					MACSTR, MAC2STR(sa));
--				goto out;
--			}
-+			p2p_dbg(p2p,
-+				"Provision Discovery device not found "
-+				MACSTR, MAC2STR(sa));
-+			goto out;
- 		}
- 	} else if (msg.wfd_subelems) {
- 		wpabuf_free(dev->info.wfd_subelems);
diff --git a/package/network/services/hostapd/patches/110-notify-mgmt-frames.patch b/package/network/services/hostapd/patches/110-notify-mgmt-frames.patch
deleted file mode 100644
index c3a66a7115..0000000000
--- a/package/network/services/hostapd/patches/110-notify-mgmt-frames.patch
+++ /dev/null
@@ -1,116 +0,0 @@
-From 53f8fdb534d5222a0e852e38afde3f49832ace06 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rapha=C3=ABl=20M=C3=A9lotte?= <raphael.melotte@mind.be>
-Date: Thu, 26 Nov 2020 09:27:40 +0100
-Subject: [PATCH] hostapd: Add an option to notify management frames on
- ctrl_iface
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-In some contexts (e.g. Multi-AP) it can be useful to have access to
-some of the management frames in upper layers (e.g. to be able to
-process the content of association requests externally).
-
-Add 'notify_mgmt_frames'. When enabled, it will notify the ctrl_iface
-when a management frame arrives using 'AP_MGMT_FRAME_RECEIVED'.
-
-Note that to avoid completely flooding the ctrl_iface, not all
-management frames are included (e.g. beacons are excluded).
-
-Signed-off-by: Raphaël Mélotte <raphael.melotte@mind.be>
----
- hostapd/config_file.c |  2 ++
- hostapd/hostapd.conf  |  4 ++++
- src/ap/ap_config.h    |  2 ++
- src/ap/ieee802_11.c   | 25 +++++++++++++++++++++++++
- src/common/wpa_ctrl.h |  3 +++
- 5 files changed, 36 insertions(+)
-
---- a/hostapd/config_file.c
-+++ b/hostapd/config_file.c
-@@ -4456,6 +4456,8 @@ static int hostapd_config_fill(struct ho
- 		bss->multicast_to_unicast = atoi(pos);
- 	} else if (os_strcmp(buf, "broadcast_deauth") == 0) {
- 		bss->broadcast_deauth = atoi(pos);
-+	} else if (os_strcmp(buf, "notify_mgmt_frames") == 0) {
-+		conf->notify_mgmt_frames = atoi(pos);
- #ifdef CONFIG_DPP
- 	} else if (os_strcmp(buf, "dpp_name") == 0) {
- 		os_free(bss->dpp_name);
---- a/hostapd/hostapd.conf
-+++ b/hostapd/hostapd.conf
-@@ -571,6 +571,10 @@ wmm_ac_vo_acm=0
- # Default: 1 (enabled)
- #broadcast_deauth=1
- 
-+# Get notifications for management frames:
-+# Default: 0 (disabled)
-+#notify_mgmt_frames=0
-+
- ##### IEEE 802.11n related configuration ######################################
- 
- # ieee80211n: Whether IEEE 802.11n (HT) is enabled
---- a/src/ap/ap_config.h
-+++ b/src/ap/ap_config.h
-@@ -1060,6 +1060,8 @@ struct hostapd_config {
- 	unsigned int airtime_update_interval;
- #define AIRTIME_MODE_MAX (__AIRTIME_MODE_MAX - 1)
- #endif /* CONFIG_AIRTIME_POLICY */
-+
-+	u8 notify_mgmt_frames;
- };
- 
- 
---- a/src/ap/ieee802_11.c
-+++ b/src/ap/ieee802_11.c
-@@ -4869,6 +4869,28 @@ static int handle_action(struct hostapd_
- 	return 1;
- }
- 
-+/**
-+ * notify_mgmt_frame - notify of management frames on the control interface.
-+ * @hapd: hostapd BSS data structure (the BSS to which the management frame was
-+ * sent to)
-+ * @buf: management frame data (starting from IEEE 802.11 header)
-+ * @len: length of frame data in octets
-+ *
-+ * Notify the control interface of any management frame.
-+ */
-+static void notify_mgmt_frame(struct hostapd_data *hapd, const u8 *buf,
-+			      size_t len)
-+{
-+
-+	int hex_len = len * 2 + 1;
-+	char *hex = os_malloc(hex_len);
-+
-+	if (hex) {
-+		wpa_snprintf_hex(hex, hex_len, buf, len);
-+		wpa_msg_ctrl(hapd->msg_ctx, MSG_INFO, AP_MGMT_FRAME_RECEIVED "buf=%s", hex);
-+		os_free(hex);
-+	}
-+}
- 
- /**
-  * ieee802_11_mgmt - process incoming IEEE 802.11 management frames
-@@ -4960,6 +4982,9 @@ int ieee802_11_mgmt(struct hostapd_data
- 	if (hapd->iconf->track_sta_max_num)
- 		sta_track_add(hapd->iface, mgmt->sa, ssi_signal);
- 
-+	if (hapd->iconf->notify_mgmt_frames)
-+		notify_mgmt_frame(hapd, buf, len);
-+
- 	switch (stype) {
- 	case WLAN_FC_STYPE_AUTH:
- 		wpa_printf(MSG_DEBUG, "mgmt::auth");
---- a/src/common/wpa_ctrl.h
-+++ b/src/common/wpa_ctrl.h
-@@ -396,6 +396,9 @@ extern "C" {
- #define BIT(x) (1U << (x))
- #endif
- 
-+/* Event triggered for received management frame */
-+#define AP_MGMT_FRAME_RECEIVED "AP-MGMT-FRAME-RECEIVED "
-+
- /* BSS command information masks */
- 
- #define WPA_BSS_MASK_ALL		0xFFFDFFFF
diff --git a/package/network/services/hostapd/patches/110-wolfssl-compile-fix.patch b/package/network/services/hostapd/patches/110-wolfssl-compile-fix.patch
deleted file mode 100644
index a7b5409602..0000000000
--- a/package/network/services/hostapd/patches/110-wolfssl-compile-fix.patch
+++ /dev/null
@@ -1,10 +0,0 @@
---- a/src/crypto/tls_wolfssl.c
-+++ b/src/crypto/tls_wolfssl.c
-@@ -19,6 +19,7 @@
- #include <wolfssl/ssl.h>
- #include <wolfssl/error-ssl.h>
- #include <wolfssl/wolfcrypt/asn.h>
-+#include <wolfssl/openssl/x509v3.h>
- 
- #if defined(EAP_FAST) || defined(EAP_FAST_DYNAMIC) || defined(EAP_SERVER_FAST)
- #define HAVE_AESGCM
diff --git a/package/network/services/hostapd/patches/120-reconfigure-wps-credentials.patch b/package/network/services/hostapd/patches/120-reconfigure-wps-credentials.patch
deleted file mode 100644
index 1826b6685b..0000000000
--- a/package/network/services/hostapd/patches/120-reconfigure-wps-credentials.patch
+++ /dev/null
@@ -1,178 +0,0 @@
-From b389a77a0f6dccf495dbce5be9476000f6ec06a2 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rapha=C3=ABl=20M=C3=A9lotte?= <raphael.melotte@mind.be>
-Date: Wed, 9 Dec 2020 19:55:53 +0100
-Subject: [PATCH] wps: reconfigure credentials on reload
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-When new credentials are configured and hostapd is reconfigured using
-SIGHUP (or reload on the ctrl_iface), also update the wps credentials.
-
-Before these changes, when WPS is triggered the registar always serves
-the credentials that were configured when hostapd started.
-
-Signed-off-by: Raphaël Mélotte <raphael.melotte@mind.be>
----
- src/ap/wps_hostapd.c    | 86 +++++++++++++++++++++++++++++++++++++++--
- src/wps/wps.h           |  6 +++
- src/wps/wps_registrar.c | 29 ++++++++++++++
- 3 files changed, 118 insertions(+), 3 deletions(-)
-
---- a/src/ap/wps_hostapd.c
-+++ b/src/ap/wps_hostapd.c
-@@ -1375,6 +1375,43 @@ static void hostapd_wps_nfc_clear(struct
- #endif /* CONFIG_WPS_NFC */
- }
- 
-+int hostapd_wps_update_multi_ap(struct hostapd_data *hapd,
-+				struct wps_registrar *reg) {
-+	struct hostapd_bss_config *conf = hapd->conf;
-+	u8 *multi_ap_backhaul_network_key = NULL;
-+	size_t multi_ap_backhaul_network_key_len = 0;
-+	int ret = -1;
-+
-+	if ((conf->multi_ap & FRONTHAUL_BSS) &&
-+	    conf->multi_ap_backhaul_ssid.ssid_len) {
-+		if (conf->multi_ap_backhaul_ssid.wpa_passphrase) {
-+			multi_ap_backhaul_network_key =
-+				(u8 *) os_strdup(conf->multi_ap_backhaul_ssid.wpa_passphrase);
-+			if (multi_ap_backhaul_network_key == NULL)
-+				return -1;
-+			multi_ap_backhaul_network_key_len =
-+				os_strlen(conf->multi_ap_backhaul_ssid.wpa_passphrase);
-+		} else if (conf->multi_ap_backhaul_ssid.wpa_psk) {
-+			multi_ap_backhaul_network_key = os_malloc(2 * PMK_LEN + 1);
-+			if (multi_ap_backhaul_network_key == NULL)
-+				return -1;
-+			wpa_snprintf_hex((char *) multi_ap_backhaul_network_key,
-+					 2 * PMK_LEN + 1,
-+					 conf->multi_ap_backhaul_ssid.wpa_psk->psk,
-+					 PMK_LEN);
-+			multi_ap_backhaul_network_key_len = 2 * PMK_LEN;
-+		}
-+		ret = wps_registrar_update_multi_ap(reg,
-+						    conf->multi_ap_backhaul_ssid.ssid,
-+						    conf->multi_ap_backhaul_ssid.ssid_len,
-+						    multi_ap_backhaul_network_key,
-+						    multi_ap_backhaul_network_key_len);
-+		os_free(multi_ap_backhaul_network_key);
-+	}
-+	return ret;
-+}
-+
-+
- 
- void hostapd_deinit_wps(struct hostapd_data *hapd)
- {
-@@ -1409,11 +1446,54 @@ void hostapd_update_wps(struct hostapd_d
- 	hapd->wps->upc = hapd->conf->upc;
- #endif /* CONFIG_WPS_UPNP */
- 
--	hostapd_wps_set_vendor_ext(hapd, hapd->wps);
--	hostapd_wps_set_application_ext(hapd, hapd->wps);
-+	struct wps_context *wps = hapd->wps;
-+	struct hostapd_bss_config *conf = hapd->conf;
-+
-+	os_memcpy(wps->ssid, conf->ssid.ssid, conf->ssid.ssid_len);
-+	wps->ssid_len = conf->ssid.ssid_len;
-+
-+	/* Clear wps settings, then fill them again */
-+	os_free(wps->network_key);
-+	wps->network_key = NULL;
-+	wps->network_key_len = 0;
-+	wps->psk_set = 0;
-+	if (conf->ssid.wpa_psk_file) {
-+		/* Use per-device PSKs */
-+	} else if (conf->ssid.wpa_passphrase) {
-+		wps->network_key = (u8 *) os_strdup(conf->ssid.wpa_passphrase);
-+		if (wps->network_key == NULL)
-+			return;
-+		wps->network_key_len = os_strlen(conf->ssid.wpa_passphrase);
-+	} else if (conf->ssid.wpa_psk) {
-+		wps->network_key = os_malloc(2 * PMK_LEN + 1);
-+		if (wps->network_key == NULL)
-+			return;
-+		wpa_snprintf_hex((char *) wps->network_key, 2 * PMK_LEN + 1,
-+				 conf->ssid.wpa_psk->psk, PMK_LEN);
-+		wps->network_key_len = 2 * PMK_LEN;
-+#ifdef CONFIG_WEP
-+	} else if (conf->ssid.wep.keys_set && conf->ssid.wep.key[0]) {
-+		wps->network_key = os_malloc(conf->ssid.wep.len[0]);
-+		if (wps->network_key == NULL)
-+			return;
-+		os_memcpy(wps->network_key, conf->ssid.wep.key[0],
-+			  conf->ssid.wep.len[0]);
-+		wps->network_key_len = conf->ssid.wep.len[0];
-+#endif /* CONFIG_WEP */
-+	}
-+
-+	if (conf->ssid.wpa_psk) {
-+		os_memcpy(wps->psk, conf->ssid.wpa_psk->psk, PMK_LEN);
-+		wps->psk_set = 1;
-+	}
-+
-+	hostapd_wps_update_multi_ap(hapd, wps->registrar);
-+
-+	hostapd_wps_set_vendor_ext(hapd, wps);
-+	hostapd_wps_set_application_ext(hapd, wps);
- 
- 	if (hapd->conf->wps_state)
--		wps_registrar_update_ie(hapd->wps->registrar);
-+		wps_registrar_update_ie(wps->registrar);
- 	else
- 		hostapd_deinit_wps(hapd);
- }
---- a/src/wps/wps.h
-+++ b/src/wps/wps.h
-@@ -938,6 +938,12 @@ struct wpabuf * wps_build_nfc_handover_s
- 					       struct wpabuf *nfc_dh_pubkey,
- 					       struct wpabuf *nfc_dev_pw);
- 
-+int wps_registrar_update_multi_ap(struct wps_registrar *reg,
-+				  const u8 *multi_ap_backhaul_ssid,
-+				  size_t multi_ap_backhaul_ssid_len,
-+				  const u8 *multi_ap_backhaul_network_key,
-+				  size_t multi_ap_backhaul_network_key_len);
-+
- /* ndef.c */
- struct wpabuf * ndef_parse_wifi(const struct wpabuf *buf);
- struct wpabuf * ndef_build_wifi(const struct wpabuf *buf);
---- a/src/wps/wps_registrar.c
-+++ b/src/wps/wps_registrar.c
-@@ -3669,6 +3669,35 @@ int wps_registrar_config_ap(struct wps_r
- }
- 
- 
-+int wps_registrar_update_multi_ap(struct wps_registrar *reg,
-+				  const u8 *multi_ap_backhaul_ssid,
-+				  size_t multi_ap_backhaul_ssid_len,
-+				  const u8 *multi_ap_backhaul_network_key,
-+				  size_t multi_ap_backhaul_network_key_len)
-+{
-+	if (multi_ap_backhaul_ssid != NULL) {
-+		os_memcpy(reg->multi_ap_backhaul_ssid,
-+			  multi_ap_backhaul_ssid,
-+			  multi_ap_backhaul_ssid_len);
-+		reg->multi_ap_backhaul_ssid_len =
-+			multi_ap_backhaul_ssid_len;
-+	}
-+	os_free(reg->multi_ap_backhaul_network_key);
-+	reg->multi_ap_backhaul_network_key = NULL;
-+	reg->multi_ap_backhaul_network_key_len = 0;
-+
-+	if (multi_ap_backhaul_network_key != NULL) {
-+		reg->multi_ap_backhaul_network_key =
-+			os_memdup(multi_ap_backhaul_network_key,
-+				  multi_ap_backhaul_network_key_len);
-+		if (reg->multi_ap_backhaul_network_key == NULL)
-+			return -1;
-+		reg->multi_ap_backhaul_network_key_len =
-+			multi_ap_backhaul_network_key_len;
-+	}
-+	return 0;
-+}
-+
- #ifdef CONFIG_WPS_NFC
- 
- int wps_registrar_add_nfc_pw_token(struct wps_registrar *reg,
diff --git a/package/network/services/hostapd/patches/200-multicall.patch b/package/network/services/hostapd/patches/200-multicall.patch
index 9119a24c55..ad82e020f6 100644
--- a/package/network/services/hostapd/patches/200-multicall.patch
+++ b/package/network/services/hostapd/patches/200-multicall.patch
@@ -1,14 +1,14 @@
 --- a/hostapd/Makefile
 +++ b/hostapd/Makefile
-@@ -31,6 +31,7 @@ CFLAGS += -I$(abspath ../src/utils)
- export BINDIR ?= /usr/local/bin/
+@@ -1,6 +1,7 @@
+ ALL=hostapd hostapd_cli
+ CONFIG_FILE = .config
  
- -include .config
 +-include $(if $(MULTICALL), ../wpa_supplicant/.config)
+ include ../src/build.rules
  
- ifndef CONFIG_NO_GITVER
- # Add VERSION_STR postfix for builds from a git repository
-@@ -204,7 +205,8 @@ endif
+ ifdef LIBS
+@@ -199,7 +200,8 @@ endif
  
  ifdef CONFIG_NO_VLAN
  CFLAGS += -DCONFIG_NO_VLAN
@@ -18,7 +18,7 @@
  OBJS += ../src/ap/vlan_init.o
  OBJS += ../src/ap/vlan_ifconfig.o
  OBJS += ../src/ap/vlan.o
-@@ -354,10 +356,14 @@ CFLAGS += -DCONFIG_MBO
+@@ -350,10 +352,14 @@ CFLAGS += -DCONFIG_MBO
  OBJS += ../src/ap/mbo_ap.o
  endif
  
@@ -36,9 +36,9 @@
  LIBS += $(DRV_AP_LIBS)
  
  ifdef CONFIG_L2_PACKET
-@@ -1311,6 +1317,12 @@ install: $(addprefix $(DESTDIR)$(BINDIR)
- 
- BCHECK=../src/drivers/build.hostapd
+@@ -1281,6 +1287,12 @@ install: $(addprefix $(DESTDIR)$(BINDIR)
+ _OBJS_VAR := OBJS
+ include ../src/objs.mk
  
 +hostapd_multi.a: $(BCHECK) $(OBJS)
 +	$(Q)$(CC) -c -o hostapd_multi.o -Dmain=hostapd_main $(CFLAGS) main.c
@@ -46,12 +46,12 @@
 +	@rm -f $@
 +	@$(AR) cr $@ hostapd_multi.o $(OBJS)
 +
- hostapd: $(BCHECK) $(OBJS)
+ hostapd: $(OBJS)
  	$(Q)$(CC) $(LDFLAGS) -o hostapd $(OBJS) $(LIBS)
  	@$(E) "  LD " $@
-@@ -1374,6 +1386,12 @@ SOBJS += ../src/crypto/sha256-kdf.o
- SOBJS += ../src/crypto/sha384-kdf.o
- SOBJS += ../src/crypto/sha512-kdf.o
+@@ -1355,6 +1367,12 @@ include ../src/objs.mk
+ _OBJS_VAR := SOBJS
+ include ../src/objs.mk
  
 +dump_cflags:
 +	@printf "%s " "$(CFLAGS)"
@@ -64,15 +64,15 @@
  	@$(E) "  LD " $@
 --- a/wpa_supplicant/Makefile
 +++ b/wpa_supplicant/Makefile
-@@ -27,6 +27,7 @@ CFLAGS += -I$(abspath ../src)
- CFLAGS += -I$(abspath ../src/utils)
+@@ -17,6 +17,7 @@ endif
+ EXTRA_TARGETS=dynamic_eap_methods
  
- -include .config
+ CONFIG_FILE=.config
 +-include $(if $(MULTICALL),../hostapd/.config)
+ include ../src/build.rules
  
- ifndef CONFIG_NO_GITVER
- # Add VERSION_STR postfix for builds from a git repository
-@@ -369,7 +370,9 @@ endif
+ ifdef LIBS
+@@ -363,7 +364,9 @@ endif
  ifdef CONFIG_IBSS_RSN
  NEED_RSN_AUTHENTICATOR=y
  CFLAGS += -DCONFIG_IBSS_RSN
@@ -82,7 +82,7 @@
  OBJS += ibss_rsn.o
  endif
  
-@@ -890,6 +893,10 @@ ifdef CONFIG_DYNAMIC_EAP_METHODS
+@@ -900,6 +903,10 @@ ifdef CONFIG_DYNAMIC_EAP_METHODS
  CFLAGS += -DCONFIG_DYNAMIC_EAP_METHODS
  LIBS += -ldl -rdynamic
  endif
@@ -93,7 +93,7 @@
  endif
  
  ifdef CONFIG_AP
-@@ -897,9 +904,11 @@ NEED_EAP_COMMON=y
+@@ -907,9 +914,11 @@ NEED_EAP_COMMON=y
  NEED_RSN_AUTHENTICATOR=y
  CFLAGS += -DCONFIG_AP
  OBJS += ap.o
@@ -105,7 +105,7 @@
  OBJS += ../src/ap/hostapd.o
  OBJS += ../src/ap/wpa_auth_glue.o
  OBJS += ../src/ap/utils.o
-@@ -979,6 +988,12 @@ endif
+@@ -989,6 +998,12 @@ endif
  ifdef CONFIG_HS20
  OBJS += ../src/ap/hs20.o
  endif
@@ -118,7 +118,7 @@
  endif
  
  ifdef CONFIG_MBO
-@@ -987,7 +1002,9 @@ CFLAGS += -DCONFIG_MBO
+@@ -997,7 +1012,9 @@ CFLAGS += -DCONFIG_MBO
  endif
  
  ifdef NEED_RSN_AUTHENTICATOR
@@ -128,10 +128,10 @@
  NEED_AES_WRAP=y
  OBJS += ../src/ap/wpa_auth.o
  OBJS += ../src/ap/wpa_auth_ie.o
-@@ -1897,6 +1914,12 @@ wpa_priv: $(BCHECK) $(OBJS_priv)
- 
- $(OBJS_c) $(OBJS_t) $(OBJS_t2) $(OBJS) $(BCHECK) $(EXTRA_progs): .config
+@@ -1891,6 +1908,12 @@ wpa_priv: $(BCHECK) $(OBJS_priv)
  
+ _OBJS_VAR := OBJS
+ include ../src/objs.mk
 +wpa_supplicant_multi.a: .config $(BCHECK) $(OBJS) $(EXTRA_progs)
 +	$(Q)$(CC) -c -o wpa_supplicant_multi.o -Dmain=wpa_supplicant_main $(CFLAGS) main.c
 +	@$(E) "  CC " $<
@@ -141,7 +141,7 @@
  wpa_supplicant: $(BCHECK) $(OBJS) $(EXTRA_progs)
  	$(Q)$(LDO) $(LDFLAGS) -o wpa_supplicant $(OBJS) $(LIBS) $(EXTRALIBS)
  	@$(E) "  LD " $@
-@@ -1997,6 +2020,12 @@ endif
+@@ -2023,6 +2046,12 @@ eap_gpsk.so: $(SRC_EAP_GPSK)
  	$(Q)sed -e 's|\@BINDIR\@|$(BINDIR)|g' $< >$@
  	@$(E) "  sed" $<
  
@@ -156,7 +156,7 @@
  wpa_cli.exe: wpa_cli
 --- a/src/drivers/driver.h
 +++ b/src/drivers/driver.h
-@@ -5886,8 +5886,8 @@ union wpa_event_data {
+@@ -6033,8 +6033,8 @@ union wpa_event_data {
   * Driver wrapper code should call this function whenever an event is received
   * from the driver.
   */
@@ -167,7 +167,7 @@
  
  /**
   * wpa_supplicant_event_global - Report a driver event for wpa_supplicant
-@@ -5899,7 +5899,7 @@ void wpa_supplicant_event(void *ctx, enu
+@@ -6046,7 +6046,7 @@ void wpa_supplicant_event(void *ctx, enu
   * Same as wpa_supplicant_event(), but we search for the interface in
   * wpa_global.
   */
@@ -178,7 +178,7 @@
  /*
 --- a/src/ap/drv_callbacks.c
 +++ b/src/ap/drv_callbacks.c
-@@ -1789,8 +1789,8 @@ err:
+@@ -1842,8 +1842,8 @@ err:
  #endif /* CONFIG_OWE */
  
  
@@ -189,7 +189,7 @@
  {
  	struct hostapd_data *hapd = ctx;
  #ifndef CONFIG_NO_STDOUT_DEBUG
-@@ -2035,7 +2035,7 @@ void wpa_supplicant_event(void *ctx, enu
+@@ -2088,7 +2088,7 @@ void wpa_supplicant_event(void *ctx, enu
  }
  
  
@@ -231,7 +231,7 @@
  	os_memset(&global, 0, sizeof(global));
 --- a/wpa_supplicant/events.c
 +++ b/wpa_supplicant/events.c
-@@ -4579,8 +4579,8 @@ static void wpas_event_unprot_beacon(str
+@@ -4891,8 +4891,8 @@ static void wpas_event_unprot_beacon(str
  }
  
  
@@ -242,7 +242,7 @@
  {
  	struct wpa_supplicant *wpa_s = ctx;
  	int resched;
-@@ -5398,7 +5398,7 @@ void wpa_supplicant_event(void *ctx, enu
+@@ -5745,7 +5745,7 @@ void wpa_supplicant_event(void *ctx, enu
  }
  
  
@@ -253,7 +253,7 @@
  	struct wpa_supplicant *wpa_s;
 --- a/wpa_supplicant/wpa_supplicant.c
 +++ b/wpa_supplicant/wpa_supplicant.c
-@@ -6594,7 +6594,6 @@ struct wpa_interface * wpa_supplicant_ma
+@@ -7043,7 +7043,6 @@ struct wpa_interface * wpa_supplicant_ma
  	return NULL;
  }
  
@@ -261,7 +261,7 @@
  /**
   * wpa_supplicant_match_existing - Match existing interfaces
   * @global: Pointer to global data from wpa_supplicant_init()
-@@ -6631,6 +6630,11 @@ static int wpa_supplicant_match_existing
+@@ -7078,6 +7077,11 @@ static int wpa_supplicant_match_existing
  
  #endif /* CONFIG_MATCH_IFACE */
  
@@ -273,7 +273,7 @@
  
  /**
   * wpa_supplicant_add_iface - Add a new network interface
-@@ -6887,6 +6891,8 @@ struct wpa_global * wpa_supplicant_init(
+@@ -7334,6 +7338,8 @@ struct wpa_global * wpa_supplicant_init(
  #ifndef CONFIG_NO_WPA_MSG
  	wpa_msg_register_ifname_cb(wpa_supplicant_msg_ifname_cb);
  #endif /* CONFIG_NO_WPA_MSG */
@@ -296,7 +296,7 @@
  
  #ifdef CONFIG_WPS
  static int gen_uuid(const char *txt_addr)
-@@ -684,6 +689,8 @@ int main(int argc, char *argv[])
+@@ -683,6 +688,8 @@ int main(int argc, char *argv[])
  		return -1;
  #endif /* CONFIG_DPP */
  
@@ -333,7 +333,7 @@
  
  const struct wpa_driver_ops *const wpa_drivers[] = { NULL };
  
-@@ -1292,6 +1297,10 @@ static void usage(void)
+@@ -1291,6 +1296,10 @@ static void usage(void)
  	       "option several times.\n");
  }
  
@@ -344,7 +344,7 @@
  
  int main(int argc, char *argv[])
  {
-@@ -1312,6 +1321,8 @@ int main(int argc, char *argv[])
+@@ -1311,6 +1320,8 @@ int main(int argc, char *argv[])
  	if (os_program_init())
  		return -1;
  
diff --git a/package/network/services/hostapd/patches/300-noscan.patch b/package/network/services/hostapd/patches/300-noscan.patch
index 638b76f84e..01a33d0d03 100644
--- a/package/network/services/hostapd/patches/300-noscan.patch
+++ b/package/network/services/hostapd/patches/300-noscan.patch
@@ -1,6 +1,6 @@
 --- a/hostapd/config_file.c
 +++ b/hostapd/config_file.c
-@@ -3493,6 +3493,10 @@ static int hostapd_config_fill(struct ho
+@@ -3474,6 +3474,10 @@ static int hostapd_config_fill(struct ho
  		if (bss->ocv && !bss->ieee80211w)
  			bss->ieee80211w = 1;
  #endif /* CONFIG_OCV */
@@ -13,7 +13,7 @@
  	} else if (os_strcmp(buf, "ht_capab") == 0) {
 --- a/src/ap/ap_config.h
 +++ b/src/ap/ap_config.h
-@@ -984,6 +984,8 @@ struct hostapd_config {
+@@ -1014,6 +1014,8 @@ struct hostapd_config {
  
  	int ht_op_mode_fixed;
  	u16 ht_capab;
@@ -24,7 +24,7 @@
  	int no_pri_sec_switch;
 --- a/src/ap/hw_features.c
 +++ b/src/ap/hw_features.c
-@@ -500,7 +500,8 @@ static int ieee80211n_check_40mhz(struct
+@@ -517,7 +517,8 @@ static int ieee80211n_check_40mhz(struct
  	int ret;
  
  	/* Check that HT40 is used and PRI / SEC switch is allowed */
diff --git a/package/network/services/hostapd/patches/301-mesh-noscan.patch b/package/network/services/hostapd/patches/301-mesh-noscan.patch
index f85b72453e..e682efb543 100644
--- a/package/network/services/hostapd/patches/301-mesh-noscan.patch
+++ b/package/network/services/hostapd/patches/301-mesh-noscan.patch
@@ -1,6 +1,6 @@
 --- a/wpa_supplicant/config.c
 +++ b/wpa_supplicant/config.c
-@@ -2478,6 +2478,7 @@ static const struct parse_data ssid_fiel
+@@ -2532,6 +2532,7 @@ static const struct parse_data ssid_fiel
  #else /* CONFIG_MESH */
  	{ INT_RANGE(mode, 0, 4) },
  #endif /* CONFIG_MESH */
@@ -10,7 +10,7 @@
  	{ STR(id_str) },
 --- a/wpa_supplicant/config_file.c
 +++ b/wpa_supplicant/config_file.c
-@@ -866,6 +866,7 @@ static void wpa_config_write_network(FIL
+@@ -769,6 +769,7 @@ static void wpa_config_write_network(FIL
  #endif /* IEEE8021X_EAPOL */
  	INT(mode);
  	INT(no_auto_peer);
@@ -20,7 +20,7 @@
  	INT(enable_edmg);
 --- a/wpa_supplicant/mesh.c
 +++ b/wpa_supplicant/mesh.c
-@@ -467,6 +467,8 @@ static int wpa_supplicant_mesh_init(stru
+@@ -505,6 +505,8 @@ static int wpa_supplicant_mesh_init(stru
  			   frequency);
  		goto out_free;
  	}
@@ -31,14 +31,17 @@
  		/*
 --- a/wpa_supplicant/wpa_supplicant.c
 +++ b/wpa_supplicant/wpa_supplicant.c
-@@ -2334,12 +2334,12 @@ void ibss_mesh_setup_freq(struct wpa_sup
+@@ -2436,7 +2436,7 @@ void ibss_mesh_setup_freq(struct wpa_sup
  	int ieee80211_mode = wpas_mode_to_ieee80211_mode(ssid->mode);
  	enum hostapd_hw_mode hw_mode;
  	struct hostapd_hw_modes *mode = NULL;
 -	int ht40plus[] = { 36, 44, 52, 60, 100, 108, 116, 124, 132, 149, 157,
 +	int ht40plus[] = { 1, 2, 3, 4, 5, 6, 36, 44, 52, 60, 100, 108, 116, 124, 132, 149, 157,
  			   184, 192 };
- 	int vht80[] = { 36, 52, 100, 116, 132, 149 };
+ 	int bw80[] = { 5180, 5260, 5500, 5580, 5660, 5745, 5955,
+ 		       6035, 6115, 6195, 6275, 6355, 6435, 6515,
+@@ -2444,7 +2444,7 @@ void ibss_mesh_setup_freq(struct wpa_sup
+ 	int bw160[] = { 5955, 6115, 6275, 6435, 6595, 6755, 6915 };
  	struct hostapd_channel_data *pri_chan = NULL, *sec_chan = NULL;
  	u8 channel;
 -	int i, chan_idx, ht40 = -1, res, obss_scan = 1;
@@ -46,7 +49,7 @@
  	unsigned int j, k;
  	struct hostapd_freq_params vht_freq;
  	int chwidth, seg0, seg1;
-@@ -2421,7 +2421,7 @@ void ibss_mesh_setup_freq(struct wpa_sup
+@@ -2535,7 +2535,7 @@ void ibss_mesh_setup_freq(struct wpa_sup
  #endif /* CONFIG_HE_OVERRIDES */
  
  	/* Setup higher BW only for 5 GHz */
@@ -57,7 +60,7 @@
  	for (chan_idx = 0; chan_idx < mode->num_channels; chan_idx++) {
 --- a/wpa_supplicant/config_ssid.h
 +++ b/wpa_supplicant/config_ssid.h
-@@ -971,6 +971,8 @@ struct wpa_ssid {
+@@ -974,6 +974,8 @@ struct wpa_ssid {
  	 */
  	int no_auto_peer;
  
diff --git a/package/network/services/hostapd/patches/310-rescan_immediately.patch b/package/network/services/hostapd/patches/310-rescan_immediately.patch
index 0040b61c6b..b0c1cb8354 100644
--- a/package/network/services/hostapd/patches/310-rescan_immediately.patch
+++ b/package/network/services/hostapd/patches/310-rescan_immediately.patch
@@ -1,6 +1,6 @@
 --- a/wpa_supplicant/wpa_supplicant.c
 +++ b/wpa_supplicant/wpa_supplicant.c
-@@ -4949,7 +4949,7 @@ wpa_supplicant_alloc(struct wpa_supplica
+@@ -5377,7 +5377,7 @@ wpa_supplicant_alloc(struct wpa_supplica
  	if (wpa_s == NULL)
  		return NULL;
  	wpa_s->scan_req = INITIAL_SCAN_REQ;
diff --git a/package/network/services/hostapd/patches/320-optional_rfkill.patch b/package/network/services/hostapd/patches/320-optional_rfkill.patch
index a703c7e132..01537790e0 100644
--- a/package/network/services/hostapd/patches/320-optional_rfkill.patch
+++ b/package/network/services/hostapd/patches/320-optional_rfkill.patch
@@ -1,6 +1,6 @@
 --- a/src/drivers/drivers.mak
 +++ b/src/drivers/drivers.mak
-@@ -50,7 +50,6 @@ NEED_SME=y
+@@ -54,7 +54,6 @@ NEED_SME=y
  NEED_AP_MLME=y
  NEED_NETLINK=y
  NEED_LINUX_IOCTL=y
@@ -8,7 +8,7 @@
  NEED_RADIOTAP=y
  NEED_LIBNL=y
  endif
-@@ -107,7 +106,6 @@ DRV_WPA_CFLAGS += -DCONFIG_DRIVER_WEXT
+@@ -111,7 +110,6 @@ DRV_WPA_CFLAGS += -DCONFIG_DRIVER_WEXT
  CONFIG_WIRELESS_EXTENSION=y
  NEED_NETLINK=y
  NEED_LINUX_IOCTL=y
@@ -16,7 +16,7 @@
  endif
  
  ifdef CONFIG_DRIVER_NDIS
-@@ -133,7 +131,6 @@ endif
+@@ -137,7 +135,6 @@ endif
  ifdef CONFIG_WIRELESS_EXTENSION
  DRV_WPA_CFLAGS += -DCONFIG_WIRELESS_EXTENSION
  DRV_WPA_OBJS += ../src/drivers/driver_wext.o
@@ -24,7 +24,7 @@
  endif
  
  ifdef NEED_NETLINK
-@@ -142,6 +139,7 @@ endif
+@@ -146,6 +143,7 @@ endif
  
  ifdef NEED_RFKILL
  DRV_OBJS += ../src/drivers/rfkill.o
diff --git a/package/network/services/hostapd/patches/330-nl80211_fix_set_freq.patch b/package/network/services/hostapd/patches/330-nl80211_fix_set_freq.patch
index ccd8589728..37033c3035 100644
--- a/package/network/services/hostapd/patches/330-nl80211_fix_set_freq.patch
+++ b/package/network/services/hostapd/patches/330-nl80211_fix_set_freq.patch
@@ -1,6 +1,6 @@
 --- a/src/drivers/driver_nl80211.c
 +++ b/src/drivers/driver_nl80211.c
-@@ -4661,7 +4661,7 @@ static int nl80211_set_channel(struct i8
+@@ -4986,7 +4986,7 @@ static int nl80211_set_channel(struct i8
  		   freq->freq, freq->ht_enabled, freq->vht_enabled, freq->he_enabled,
  		   freq->bandwidth, freq->center_freq1, freq->center_freq2);
  
diff --git a/package/network/services/hostapd/patches/340-reload_freq_change.patch b/package/network/services/hostapd/patches/340-reload_freq_change.patch
index e0e62c2a11..3d51a47a1e 100644
--- a/package/network/services/hostapd/patches/340-reload_freq_change.patch
+++ b/package/network/services/hostapd/patches/340-reload_freq_change.patch
@@ -1,6 +1,6 @@
 --- a/src/ap/hostapd.c
 +++ b/src/ap/hostapd.c
-@@ -114,6 +114,28 @@ static void hostapd_reload_bss(struct ho
+@@ -115,6 +115,28 @@ static void hostapd_reload_bss(struct ho
  #endif /* CONFIG_NO_RADIUS */
  
  	ssid = &hapd->conf->ssid;
@@ -29,7 +29,7 @@
  	if (!ssid->wpa_psk_set && ssid->wpa_psk && !ssid->wpa_psk->next &&
  	    ssid->wpa_passphrase_set && ssid->wpa_passphrase) {
  		/*
-@@ -215,6 +237,7 @@ int hostapd_reload_config(struct hostapd
+@@ -216,6 +238,7 @@ int hostapd_reload_config(struct hostapd
  	struct hostapd_data *hapd = iface->bss[0];
  	struct hostapd_config *newconf, *oldconf;
  	size_t j;
@@ -37,7 +37,7 @@
  
  	if (iface->config_fname == NULL) {
  		/* Only in-memory config in use - assume it has been updated */
-@@ -265,24 +288,20 @@ int hostapd_reload_config(struct hostapd
+@@ -266,24 +289,20 @@ int hostapd_reload_config(struct hostapd
  	}
  	iface->conf = newconf;
  
diff --git a/package/network/services/hostapd/patches/341-mesh-ctrl-iface-channel-switch.patch b/package/network/services/hostapd/patches/341-mesh-ctrl-iface-channel-switch.patch
index 90fa5eff5d..b13dcb0673 100644
--- a/package/network/services/hostapd/patches/341-mesh-ctrl-iface-channel-switch.patch
+++ b/package/network/services/hostapd/patches/341-mesh-ctrl-iface-channel-switch.patch
@@ -1,6 +1,6 @@
 --- a/wpa_supplicant/ap.c
 +++ b/wpa_supplicant/ap.c
-@@ -1466,15 +1466,35 @@ int ap_switch_channel(struct wpa_supplic
+@@ -1611,15 +1611,35 @@ int ap_switch_channel(struct wpa_supplic
  
  
  #ifdef CONFIG_CTRL_IFACE
diff --git a/package/network/services/hostapd/patches/350-nl80211_del_beacon_bss.patch b/package/network/services/hostapd/patches/350-nl80211_del_beacon_bss.patch
index 076950fe35..35567838f5 100644
--- a/package/network/services/hostapd/patches/350-nl80211_del_beacon_bss.patch
+++ b/package/network/services/hostapd/patches/350-nl80211_del_beacon_bss.patch
@@ -1,6 +1,6 @@
 --- a/src/drivers/driver_nl80211.c
 +++ b/src/drivers/driver_nl80211.c
-@@ -2803,10 +2803,15 @@ static int wpa_driver_nl80211_del_beacon
+@@ -2931,10 +2931,15 @@ static int wpa_driver_nl80211_del_beacon
  	struct nl_msg *msg;
  	struct wpa_driver_nl80211_data *drv = bss->drv;
  
@@ -15,10 +15,10 @@
  	nl80211_put_wiphy_data_ap(bss);
 -	msg = nl80211_drv_msg(drv, 0, NL80211_CMD_DEL_BEACON);
 +	msg = nl80211_bss_msg(bss, 0, NL80211_CMD_DEL_BEACON);
- 	return send_and_recv_msgs(drv, msg, NULL, NULL);
+ 	return send_and_recv_msgs(drv, msg, NULL, NULL, NULL, NULL);
  }
  
-@@ -5278,7 +5283,7 @@ static void nl80211_teardown_ap(struct i
+@@ -5617,7 +5622,7 @@ static void nl80211_teardown_ap(struct i
  		nl80211_mgmt_unsubscribe(bss, "AP teardown");
  
  	nl80211_put_wiphy_data_ap(bss);
@@ -27,7 +27,7 @@
  }
  
  
-@@ -7694,8 +7699,6 @@ static int wpa_driver_nl80211_if_remove(
+@@ -8071,8 +8076,6 @@ static int wpa_driver_nl80211_if_remove(
  	} else {
  		wpa_printf(MSG_DEBUG, "nl80211: First BSS - reassign context");
  		nl80211_teardown_ap(bss);
@@ -36,7 +36,7 @@
  		nl80211_destroy_bss(bss);
  		if (!bss->added_if)
  			i802_set_iface_flags(bss, 0);
-@@ -8089,7 +8092,6 @@ static int wpa_driver_nl80211_deinit_ap(
+@@ -8469,7 +8472,6 @@ static int wpa_driver_nl80211_deinit_ap(
  	if (!is_ap_interface(drv->nlmode))
  		return -1;
  	wpa_driver_nl80211_del_beacon(bss);
@@ -44,7 +44,7 @@
  
  	/*
  	 * If the P2P GO interface was dynamically added, then it is
-@@ -8109,7 +8111,6 @@ static int wpa_driver_nl80211_stop_ap(vo
+@@ -8489,7 +8491,6 @@ static int wpa_driver_nl80211_stop_ap(vo
  	if (!is_ap_interface(drv->nlmode))
  		return -1;
  	wpa_driver_nl80211_del_beacon(bss);
diff --git a/package/network/services/hostapd/patches/360-ctrl_iface_reload.patch b/package/network/services/hostapd/patches/360-ctrl_iface_reload.patch
index 31c5102cb1..7f3aa91889 100644
--- a/package/network/services/hostapd/patches/360-ctrl_iface_reload.patch
+++ b/package/network/services/hostapd/patches/360-ctrl_iface_reload.patch
@@ -1,6 +1,6 @@
 --- a/hostapd/ctrl_iface.c
 +++ b/hostapd/ctrl_iface.c
-@@ -65,6 +65,7 @@
+@@ -67,6 +67,7 @@
  #include "fst/fst_ctrl_iface.h"
  #include "config_file.h"
  #include "ctrl_iface.h"
@@ -8,7 +8,7 @@
  
  
  #define HOSTAPD_CLI_DUP_VALUE_MAX_LEN 256
-@@ -80,6 +81,7 @@ static void hostapd_ctrl_iface_send(stru
+@@ -82,6 +83,7 @@ static void hostapd_ctrl_iface_send(stru
  				    enum wpa_msg_type type,
  				    const char *buf, size_t len);
  
@@ -16,7 +16,7 @@
  
  static int hostapd_ctrl_iface_attach(struct hostapd_data *hapd,
  				     struct sockaddr_storage *from,
-@@ -131,6 +133,61 @@ static int hostapd_ctrl_iface_new_sta(st
+@@ -133,6 +135,61 @@ static int hostapd_ctrl_iface_new_sta(st
  	return 0;
  }
  
@@ -78,7 +78,7 @@
  
  #ifdef NEED_AP_MLME
  static int hostapd_ctrl_iface_sa_query(struct hostapd_data *hapd,
-@@ -3546,6 +3603,8 @@ static int hostapd_ctrl_iface_receive_pr
+@@ -3771,6 +3828,8 @@ static int hostapd_ctrl_iface_receive_pr
  	} else if (os_strncmp(buf, "VENDOR ", 7) == 0) {
  		reply_len = hostapd_ctrl_iface_vendor(hapd, buf + 7, reply,
  						      reply_size);
@@ -89,7 +89,7 @@
  #ifdef RADIUS_SERVER
 --- a/src/ap/ctrl_iface_ap.c
 +++ b/src/ap/ctrl_iface_ap.c
-@@ -917,7 +917,13 @@ int hostapd_parse_csa_settings(const cha
+@@ -927,7 +927,13 @@ int hostapd_parse_csa_settings(const cha
  
  int hostapd_ctrl_iface_stop_ap(struct hostapd_data *hapd)
  {
diff --git a/package/network/services/hostapd/patches/370-ap_sta_support.patch b/package/network/services/hostapd/patches/370-ap_sta_support.patch
index 1c5f72ddc0..c81c841a43 100644
--- a/package/network/services/hostapd/patches/370-ap_sta_support.patch
+++ b/package/network/services/hostapd/patches/370-ap_sta_support.patch
@@ -1,17 +1,6 @@
 --- a/wpa_supplicant/Makefile
 +++ b/wpa_supplicant/Makefile
-@@ -26,6 +26,10 @@ CFLAGS += $(EXTRA_CFLAGS)
- CFLAGS += -I$(abspath ../src)
- CFLAGS += -I$(abspath ../src/utils)
- 
-+ifdef MULTICALL
-+CFLAGS += -DMULTICALL
-+endif
-+
- -include .config
- -include $(if $(MULTICALL),../hostapd/.config)
- 
-@@ -118,6 +122,8 @@ OBJS_c += ../src/utils/common.o
+@@ -108,6 +108,8 @@ OBJS_c += ../src/utils/common.o
  OBJS_c += ../src/common/cli.o
  OBJS += wmm_ac.o
  
@@ -30,7 +19,7 @@
  #include "drivers/driver.h"
  #include "eap_peer/eap.h"
  #include "wpa_supplicant_i.h"
-@@ -294,6 +295,10 @@ void calculate_update_time(const struct
+@@ -282,6 +283,10 @@ void calculate_update_time(const struct
  static void wpa_bss_copy_res(struct wpa_bss *dst, struct wpa_scan_res *src,
  			     struct os_reltime *fetch_time)
  {
@@ -41,7 +30,7 @@
  	dst->flags = src->flags;
  	os_memcpy(dst->bssid, src->bssid, ETH_ALEN);
  	dst->freq = src->freq;
-@@ -306,6 +311,15 @@ static void wpa_bss_copy_res(struct wpa_
+@@ -294,6 +299,15 @@ static void wpa_bss_copy_res(struct wpa_
  	dst->est_throughput = src->est_throughput;
  	dst->snr = src->snr;
  
@@ -59,7 +48,7 @@
  
 --- a/wpa_supplicant/bss.h
 +++ b/wpa_supplicant/bss.h
-@@ -83,6 +83,10 @@ struct wpa_bss {
+@@ -94,6 +94,10 @@ struct wpa_bss {
  	u8 ssid[SSID_MAX_LEN];
  	/** Length of SSID */
  	size_t ssid_len;
@@ -110,7 +99,7 @@
  			break;
 --- a/wpa_supplicant/wpa_supplicant.c
 +++ b/wpa_supplicant/wpa_supplicant.c
-@@ -129,6 +129,54 @@ static void wpas_update_fils_connect_par
+@@ -130,6 +130,54 @@ static void wpas_update_fils_connect_par
  static void wpas_update_owe_connect_params(struct wpa_supplicant *wpa_s);
  #endif /* CONFIG_OWE */
  
@@ -165,7 +154,7 @@
  
  #ifdef CONFIG_WEP
  /* Configure default/group WEP keys for static WEP */
-@@ -991,6 +1039,8 @@ void wpa_supplicant_set_state(struct wpa
+@@ -1015,6 +1063,8 @@ void wpa_supplicant_set_state(struct wpa
  
  		sme_sched_obss_scan(wpa_s, 1);
  
@@ -174,7 +163,7 @@
  #if defined(CONFIG_FILS) && defined(IEEE8021X_EAPOL)
  		if (!fils_hlp_sent && ssid && ssid->eap.erp)
  			update_fils_connect_params = true;
-@@ -1001,6 +1051,8 @@ void wpa_supplicant_set_state(struct wpa
+@@ -1025,6 +1075,8 @@ void wpa_supplicant_set_state(struct wpa
  #endif /* CONFIG_OWE */
  	} else if (state == WPA_DISCONNECTED || state == WPA_ASSOCIATING ||
  		   state == WPA_ASSOCIATED) {
@@ -183,7 +172,7 @@
  		wpa_s->new_connection = 1;
  		wpa_drv_set_operstate(wpa_s, 0);
  #ifndef IEEE8021X_EAPOL
-@@ -2225,6 +2277,8 @@ void wpa_supplicant_associate(struct wpa
+@@ -2308,6 +2360,8 @@ void wpa_supplicant_associate(struct wpa
  			return;
  		}
  		wpa_s->current_bss = bss;
@@ -192,7 +181,7 @@
  #else /* CONFIG_MESH */
  		wpa_msg(wpa_s, MSG_ERROR,
  			"mesh mode support not included in the build");
-@@ -6207,6 +6261,16 @@ static int wpa_supplicant_init_iface(str
+@@ -6650,6 +6704,16 @@ static int wpa_supplicant_init_iface(str
  			   sizeof(wpa_s->bridge_ifname));
  	}
  
@@ -209,7 +198,7 @@
  	/* RSNA Supplicant Key Management - INITIALIZE */
  	eapol_sm_notify_portEnabled(wpa_s->eapol, false);
  	eapol_sm_notify_portValid(wpa_s->eapol, false);
-@@ -6540,6 +6604,11 @@ static void wpa_supplicant_deinit_iface(
+@@ -6987,6 +7051,11 @@ static void wpa_supplicant_deinit_iface(
  	if (terminate)
  		wpa_msg(wpa_s, MSG_INFO, WPA_EVENT_TERMINATING);
  
@@ -218,9 +207,9 @@
 +		wpa_s->hostapd = NULL;
 +	}
 +
- 	if (wpa_s->ctrl_iface) {
- 		wpa_supplicant_ctrl_iface_deinit(wpa_s->ctrl_iface);
- 		wpa_s->ctrl_iface = NULL;
+ 	wpa_supplicant_ctrl_iface_deinit(wpa_s, wpa_s->ctrl_iface);
+ 	wpa_s->ctrl_iface = NULL;
+ 
 --- a/wpa_supplicant/wpa_supplicant_i.h
 +++ b/wpa_supplicant/wpa_supplicant_i.h
 @@ -104,6 +104,11 @@ struct wpa_interface {
@@ -235,7 +224,7 @@
  	 * bridge_ifname - Optional bridge interface name
  	 *
  	 * If the driver interface (ifname) is included in a Linux bridge
-@@ -530,6 +535,8 @@ struct wpa_supplicant {
+@@ -718,6 +723,8 @@ struct wpa_supplicant {
  #endif /* CONFIG_CTRL_IFACE_BINDER */
  	char bridge_ifname[16];
  
@@ -246,23 +235,24 @@
  
 --- a/hostapd/ctrl_iface.c
 +++ b/hostapd/ctrl_iface.c
-@@ -2712,6 +2712,11 @@ static int hostapd_ctrl_iface_chan_switc
+@@ -2889,6 +2889,12 @@ static int hostapd_ctrl_iface_chan_switc
  		return 0;
  	}
  
 +	if (os_strstr(pos, " auto-ht")) {
 +		settings.freq_params.ht_enabled = iface->conf->ieee80211n;
 +		settings.freq_params.vht_enabled = iface->conf->ieee80211ac;
++		settings.freq_params.he_enabled = iface->conf->ieee80211ax;
 +	}
 +
  	for (i = 0; i < iface->num_bss; i++) {
  
- 		/* Save CHAN_SWITCH VHT config */
+ 		/* Save CHAN_SWITCH VHT and HE config */
 --- a/src/ap/beacon.c
 +++ b/src/ap/beacon.c
-@@ -1468,11 +1468,6 @@ int ieee802_11_set_beacon(struct hostapd
- 	struct wpabuf *beacon, *proberesp, *assocresp;
- 	int res, ret = -1;
+@@ -1791,11 +1791,6 @@ static int __ieee802_11_set_beacon(struc
+ 		return -1;
+ 	}
  
 -	if (hapd->csa_in_progress) {
 -		wpa_printf(MSG_ERROR, "Cannot set beacons during CSA period");
@@ -274,7 +264,7 @@
  	if (ieee802_11_build_ap_params(hapd, &params) < 0)
 --- a/wpa_supplicant/events.c
 +++ b/wpa_supplicant/events.c
-@@ -4579,6 +4579,60 @@ static void wpas_event_unprot_beacon(str
+@@ -4891,6 +4891,60 @@ static void wpas_event_unprot_beacon(str
  }
  
  
@@ -335,7 +325,7 @@
  void supplicant_event(void *ctx, enum wpa_event_type event,
  		      union wpa_event_data *data)
  {
-@@ -4881,8 +4935,10 @@ void supplicant_event(void *ctx, enum wp
+@@ -5206,8 +5260,10 @@ void supplicant_event(void *ctx, enum wp
  			channel_width_to_string(data->ch_switch.ch_width),
  			data->ch_switch.cf1,
  			data->ch_switch.cf2);
@@ -349,7 +339,7 @@
  		wpa_s->current_ssid->frequency = data->ch_switch.freq;
 --- a/src/drivers/driver.h
 +++ b/src/drivers/driver.h
-@@ -5690,6 +5690,7 @@ union wpa_event_data {
+@@ -5837,6 +5837,7 @@ union wpa_event_data {
  
  	/**
  	 * struct ch_switch
@@ -357,7 +347,7 @@
  	 * @freq: Frequency of new channel in MHz
  	 * @ht_enabled: Whether this is an HT channel
  	 * @ch_offset: Secondary channel offset
-@@ -5698,6 +5699,7 @@ union wpa_event_data {
+@@ -5845,6 +5846,7 @@ union wpa_event_data {
  	 * @cf2: Center frequency 2
  	 */
  	struct ch_switch {
@@ -367,7 +357,7 @@
  		int ch_offset;
 --- a/src/drivers/driver_nl80211_event.c
 +++ b/src/drivers/driver_nl80211_event.c
-@@ -541,7 +541,7 @@ static void mlme_event_ch_switch(struct
+@@ -684,7 +684,7 @@ static void mlme_event_ch_switch(struct
  				 struct nlattr *ifindex, struct nlattr *freq,
  				 struct nlattr *type, struct nlattr *bw,
  				 struct nlattr *cf1, struct nlattr *cf2,
@@ -376,7 +366,7 @@
  {
  	struct i802_bss *bss;
  	union wpa_event_data data;
-@@ -600,6 +600,8 @@ static void mlme_event_ch_switch(struct
+@@ -745,6 +745,8 @@ static void mlme_event_ch_switch(struct
  		data.ch_switch.cf1 = nla_get_u32(cf1);
  	if (cf2)
  		data.ch_switch.cf2 = nla_get_u32(cf2);
@@ -385,7 +375,7 @@
  
  	if (finished)
  		bss->freq = data.ch_switch.freq;
-@@ -2686,6 +2688,7 @@ static void do_process_drv_event(struct
+@@ -3003,6 +3005,7 @@ static void do_process_drv_event(struct
  				     tb[NL80211_ATTR_CHANNEL_WIDTH],
  				     tb[NL80211_ATTR_CENTER_FREQ1],
  				     tb[NL80211_ATTR_CENTER_FREQ2],
@@ -393,7 +383,7 @@
  				     0);
  		break;
  	case NL80211_CMD_CH_SWITCH_NOTIFY:
-@@ -2696,6 +2699,7 @@ static void do_process_drv_event(struct
+@@ -3013,6 +3016,7 @@ static void do_process_drv_event(struct
  				     tb[NL80211_ATTR_CHANNEL_WIDTH],
  				     tb[NL80211_ATTR_CENTER_FREQ1],
  				     tb[NL80211_ATTR_CENTER_FREQ2],
diff --git a/package/network/services/hostapd/patches/380-disable_ctrl_iface_mib.patch b/package/network/services/hostapd/patches/380-disable_ctrl_iface_mib.patch
index b98b2d0cba..92b52a6d37 100644
--- a/package/network/services/hostapd/patches/380-disable_ctrl_iface_mib.patch
+++ b/package/network/services/hostapd/patches/380-disable_ctrl_iface_mib.patch
@@ -1,6 +1,6 @@
 --- a/hostapd/Makefile
 +++ b/hostapd/Makefile
-@@ -226,6 +226,9 @@ endif
+@@ -221,6 +221,9 @@ endif
  ifdef CONFIG_NO_CTRL_IFACE
  CFLAGS += -DCONFIG_NO_CTRL_IFACE
  else
@@ -12,7 +12,7 @@
  else
 --- a/hostapd/ctrl_iface.c
 +++ b/hostapd/ctrl_iface.c
-@@ -3370,6 +3370,7 @@ static int hostapd_ctrl_iface_receive_pr
+@@ -3587,6 +3587,7 @@ static int hostapd_ctrl_iface_receive_pr
  						      reply_size);
  	} else if (os_strcmp(buf, "STATUS-DRIVER") == 0) {
  		reply_len = hostapd_drv_status(hapd, reply, reply_size);
@@ -20,7 +20,7 @@
  	} else if (os_strcmp(buf, "MIB") == 0) {
  		reply_len = ieee802_11_get_mib(hapd, reply, reply_size);
  		if (reply_len >= 0) {
-@@ -3411,6 +3412,7 @@ static int hostapd_ctrl_iface_receive_pr
+@@ -3628,6 +3629,7 @@ static int hostapd_ctrl_iface_receive_pr
  	} else if (os_strncmp(buf, "STA-NEXT ", 9) == 0) {
  		reply_len = hostapd_ctrl_iface_sta_next(hapd, buf + 9, reply,
  							reply_size);
@@ -30,7 +30,7 @@
  			reply_len = -1;
 --- a/wpa_supplicant/Makefile
 +++ b/wpa_supplicant/Makefile
-@@ -952,6 +952,9 @@ ifdef CONFIG_FILS
+@@ -958,6 +958,9 @@ ifdef CONFIG_FILS
  OBJS += ../src/ap/fils_hlp.o
  endif
  ifdef CONFIG_CTRL_IFACE
@@ -42,7 +42,7 @@
  
 --- a/wpa_supplicant/ctrl_iface.c
 +++ b/wpa_supplicant/ctrl_iface.c
-@@ -2267,7 +2267,7 @@ static int wpa_supplicant_ctrl_iface_sta
+@@ -2314,7 +2314,7 @@ static int wpa_supplicant_ctrl_iface_sta
  			pos += ret;
  		}
  
@@ -51,7 +51,7 @@
  		if (wpa_s->ap_iface) {
  			pos += ap_ctrl_iface_wpa_get_status(wpa_s, pos,
  							    end - pos,
-@@ -10366,6 +10366,7 @@ char * wpa_supplicant_ctrl_iface_process
+@@ -11494,6 +11494,7 @@ char * wpa_supplicant_ctrl_iface_process
  			reply_len = -1;
  	} else if (os_strncmp(buf, "NOTE ", 5) == 0) {
  		wpa_printf(MSG_INFO, "NOTE: %s", buf + 5);
@@ -59,7 +59,7 @@
  	} else if (os_strcmp(buf, "MIB") == 0) {
  		reply_len = wpa_sm_get_mib(wpa_s->wpa, reply, reply_size);
  		if (reply_len >= 0) {
-@@ -10378,6 +10379,7 @@ char * wpa_supplicant_ctrl_iface_process
+@@ -11506,6 +11507,7 @@ char * wpa_supplicant_ctrl_iface_process
  				reply_size - reply_len);
  #endif /* CONFIG_MACSEC */
  		}
@@ -67,7 +67,7 @@
  	} else if (os_strncmp(buf, "STATUS", 6) == 0) {
  		reply_len = wpa_supplicant_ctrl_iface_status(
  			wpa_s, buf + 6, reply, reply_size);
-@@ -10862,6 +10864,7 @@ char * wpa_supplicant_ctrl_iface_process
+@@ -11994,6 +11996,7 @@ char * wpa_supplicant_ctrl_iface_process
  		reply_len = wpa_supplicant_ctrl_iface_bss(
  			wpa_s, buf + 4, reply, reply_size);
  #ifdef CONFIG_AP
@@ -75,7 +75,7 @@
  	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
  		reply_len = ap_ctrl_iface_sta_first(wpa_s, reply, reply_size);
  	} else if (os_strncmp(buf, "STA ", 4) == 0) {
-@@ -10870,12 +10873,15 @@ char * wpa_supplicant_ctrl_iface_process
+@@ -12002,12 +12005,15 @@ char * wpa_supplicant_ctrl_iface_process
  	} else if (os_strncmp(buf, "STA-NEXT ", 9) == 0) {
  		reply_len = ap_ctrl_iface_sta_next(wpa_s, buf + 9, reply,
  						   reply_size);
@@ -101,7 +101,7 @@
  
  static size_t hostapd_write_ht_mcs_bitmask(char *buf, size_t buflen,
  					   size_t curr_len, const u8 *mcs_set)
-@@ -451,6 +452,7 @@ int hostapd_ctrl_iface_sta_next(struct h
+@@ -459,6 +460,7 @@ int hostapd_ctrl_iface_sta_next(struct h
  	return hostapd_ctrl_iface_sta_mib(hapd, sta->next, buf, buflen);
  }
  
@@ -109,7 +109,7 @@
  
  #ifdef CONFIG_P2P_MANAGER
  static int p2p_manager_disconnect(struct hostapd_data *hapd, u16 stype,
-@@ -806,12 +808,12 @@ int hostapd_ctrl_iface_status(struct hos
+@@ -815,12 +817,12 @@ int hostapd_ctrl_iface_status(struct hos
  			return len;
  		len += ret;
  	}
@@ -126,7 +126,7 @@
  		if (os_snprintf_error(buflen - len, ret))
 --- a/src/ap/ieee802_1x.c
 +++ b/src/ap/ieee802_1x.c
-@@ -2711,6 +2711,7 @@ static const char * bool_txt(bool val)
+@@ -2712,6 +2712,7 @@ static const char * bool_txt(bool val)
  	return val ? "TRUE" : "FALSE";
  }
  
@@ -134,7 +134,7 @@
  
  int ieee802_1x_get_mib(struct hostapd_data *hapd, char *buf, size_t buflen)
  {
-@@ -2897,6 +2898,7 @@ int ieee802_1x_get_mib_sta(struct hostap
+@@ -2898,6 +2899,7 @@ int ieee802_1x_get_mib_sta(struct hostap
  	return len;
  }
  
@@ -144,7 +144,7 @@
  static void ieee802_1x_wnm_notif_send(void *eloop_ctx, void *timeout_ctx)
 --- a/src/ap/wpa_auth.c
 +++ b/src/ap/wpa_auth.c
-@@ -4451,6 +4451,7 @@ static const char * wpa_bool_txt(int val
+@@ -4519,6 +4519,7 @@ static const char * wpa_bool_txt(int val
  	return val ? "TRUE" : "FALSE";
  }
  
@@ -152,7 +152,7 @@
  
  #define RSN_SUITE "%02x-%02x-%02x-%d"
  #define RSN_SUITE_ARG(s) \
-@@ -4601,7 +4602,7 @@ int wpa_get_mib_sta(struct wpa_state_mac
+@@ -4669,7 +4670,7 @@ int wpa_get_mib_sta(struct wpa_state_mac
  
  	return len;
  }
@@ -163,7 +163,7 @@
  {
 --- a/src/rsn_supp/wpa.c
 +++ b/src/rsn_supp/wpa.c
-@@ -2728,6 +2728,8 @@ static u32 wpa_key_mgmt_suite(struct wpa
+@@ -2777,6 +2777,8 @@ static u32 wpa_key_mgmt_suite(struct wpa
  }
  
  
@@ -172,7 +172,7 @@
  #define RSN_SUITE "%02x-%02x-%02x-%d"
  #define RSN_SUITE_ARG(s) \
  ((s) >> 24) & 0xff, ((s) >> 16) & 0xff, ((s) >> 8) & 0xff, (s) & 0xff
-@@ -2809,6 +2811,7 @@ int wpa_sm_get_mib(struct wpa_sm *sm, ch
+@@ -2858,6 +2860,7 @@ int wpa_sm_get_mib(struct wpa_sm *sm, ch
  
  	return (int) len;
  }
@@ -182,7 +182,7 @@
  
 --- a/wpa_supplicant/ap.c
 +++ b/wpa_supplicant/ap.c
-@@ -1324,7 +1324,7 @@ int wpas_ap_wps_nfc_report_handover(stru
+@@ -1462,7 +1462,7 @@ int wpas_ap_wps_nfc_report_handover(stru
  #endif /* CONFIG_WPS */
  
  
diff --git a/package/network/services/hostapd/patches/390-wpa_ie_cap_workaround.patch b/package/network/services/hostapd/patches/390-wpa_ie_cap_workaround.patch
index 9dee2d738e..65a8b07e65 100644
--- a/package/network/services/hostapd/patches/390-wpa_ie_cap_workaround.patch
+++ b/package/network/services/hostapd/patches/390-wpa_ie_cap_workaround.patch
@@ -1,6 +1,6 @@
 --- a/src/common/wpa_common.c
 +++ b/src/common/wpa_common.c
-@@ -2121,6 +2121,31 @@ u32 wpa_akm_to_suite(int akm)
+@@ -2444,6 +2444,31 @@ u32 wpa_akm_to_suite(int akm)
  }
  
  
@@ -32,7 +32,7 @@
  int wpa_compare_rsn_ie(int ft_initial_assoc,
  		       const u8 *ie1, size_t ie1len,
  		       const u8 *ie2, size_t ie2len)
-@@ -2128,8 +2153,19 @@ int wpa_compare_rsn_ie(int ft_initial_as
+@@ -2451,8 +2476,19 @@ int wpa_compare_rsn_ie(int ft_initial_as
  	if (ie1 == NULL || ie2 == NULL)
  		return -1;
  
diff --git a/package/network/services/hostapd/patches/400-wps_single_auth_enc_type.patch b/package/network/services/hostapd/patches/400-wps_single_auth_enc_type.patch
index 73a8c7694d..f708bf39ba 100644
--- a/package/network/services/hostapd/patches/400-wps_single_auth_enc_type.patch
+++ b/package/network/services/hostapd/patches/400-wps_single_auth_enc_type.patch
@@ -11,7 +11,7 @@
  			bss->wpa_pairwise |= WPA_CIPHER_TKIP;
  #endif /* CONFIG_NO_TKIP */
  		bss->rsn_pairwise = bss->wpa_pairwise;
-@@ -1178,8 +1177,7 @@ int hostapd_init_wps(struct hostapd_data
+@@ -1180,8 +1179,7 @@ int hostapd_init_wps(struct hostapd_data
  					  WPA_CIPHER_GCMP_256)) {
  			wps->encr_types |= WPS_ENCR_AES;
  			wps->encr_types_rsn |= WPS_ENCR_AES;
diff --git a/package/network/services/hostapd/patches/420-indicate-features.patch b/package/network/services/hostapd/patches/420-indicate-features.patch
index 9f216347f4..f9dff66073 100644
--- a/package/network/services/hostapd/patches/420-indicate-features.patch
+++ b/package/network/services/hostapd/patches/420-indicate-features.patch
@@ -8,7 +8,7 @@
  #include "crypto/random.h"
  #include "crypto/tls.h"
  #include "common/version.h"
-@@ -692,7 +693,7 @@ int main(int argc, char *argv[])
+@@ -691,7 +692,7 @@ int main(int argc, char *argv[])
  	wpa_supplicant_event = hostapd_wpa_event;
  	wpa_supplicant_event_global = hostapd_wpa_event_global;
  	for (;;) {
@@ -17,7 +17,7 @@
  		if (c < 0)
  			break;
  		switch (c) {
-@@ -729,6 +730,8 @@ int main(int argc, char *argv[])
+@@ -728,6 +729,8 @@ int main(int argc, char *argv[])
  			break;
  #endif /* CONFIG_DEBUG_LINUX_TRACING */
  		case 'v':
diff --git a/package/network/services/hostapd/patches/430-hostapd_cli_ifdef.patch b/package/network/services/hostapd/patches/430-hostapd_cli_ifdef.patch
index 3744464c89..dc1fa3d29d 100644
--- a/package/network/services/hostapd/patches/430-hostapd_cli_ifdef.patch
+++ b/package/network/services/hostapd/patches/430-hostapd_cli_ifdef.patch
@@ -32,7 +32,7 @@
  
  
  static int hostapd_cli_cmd_disassoc_imminent(struct wpa_ctrl *ctrl, int argc,
-@@ -1532,13 +1528,10 @@ static const struct hostapd_cli_cmd host
+@@ -1579,13 +1575,10 @@ static const struct hostapd_cli_cmd host
  	{ "disassociate", hostapd_cli_cmd_disassociate,
  	  hostapd_complete_stations,
  	  "<addr> = disassociate a station" },
@@ -46,7 +46,7 @@
  	{ "wps_pin", hostapd_cli_cmd_wps_pin, NULL,
  	  "<uuid> <pin> [timeout] [addr] = add WPS Enrollee PIN" },
  	{ "wps_check_pin", hostapd_cli_cmd_wps_check_pin, NULL,
-@@ -1563,7 +1556,6 @@ static const struct hostapd_cli_cmd host
+@@ -1610,7 +1603,6 @@ static const struct hostapd_cli_cmd host
  	  "<SSID> <auth> <encr> <key> = configure AP" },
  	{ "wps_get_status", hostapd_cli_cmd_wps_get_status, NULL,
  	  "= show current WPS status" },
diff --git a/package/network/services/hostapd/patches/460-wpa_supplicant-add-new-config-params-to-be-used-with.patch b/package/network/services/hostapd/patches/460-wpa_supplicant-add-new-config-params-to-be-used-with.patch
index 99c552821b..28f07c7dc2 100644
--- a/package/network/services/hostapd/patches/460-wpa_supplicant-add-new-config-params-to-be-used-with.patch
+++ b/package/network/services/hostapd/patches/460-wpa_supplicant-add-new-config-params-to-be-used-with.patch
@@ -22,7 +22,7 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
  #include "common/defs.h"
  #include "common/ieee802_11_defs.h"
  #include "common/wpa_common.h"
-@@ -850,6 +851,9 @@ struct wpa_driver_associate_params {
+@@ -857,6 +858,9 @@ struct wpa_driver_associate_params {
  	 * responsible for selecting with which BSS to associate. */
  	const u8 *bssid;
  
@@ -42,7 +42,7 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
  #include "config.h"
  
  
-@@ -2269,6 +2270,97 @@ static char * wpa_config_write_peerkey(c
+@@ -2321,6 +2322,97 @@ static char * wpa_config_write_peerkey(c
  #endif /* NO_CONFIG_WRITE */
  
  
@@ -140,7 +140,7 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
  /* Helper macros for network block parser */
  
  #ifdef OFFSET
-@@ -2552,6 +2644,8 @@ static const struct parse_data ssid_fiel
+@@ -2606,6 +2698,8 @@ static const struct parse_data ssid_fiel
  	{ INT(ap_max_inactivity) },
  	{ INT(dtim_period) },
  	{ INT(beacon_int) },
@@ -162,7 +162,7 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
  
  
  #define DEFAULT_EAP_WORKAROUND ((unsigned int) -1)
-@@ -843,6 +845,9 @@ struct wpa_ssid {
+@@ -846,6 +848,9 @@ struct wpa_ssid {
  	 */
  	void *parent_cred;
  
@@ -174,7 +174,7 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
  	 * macsec_policy - Determines the policy for MACsec secure session
 --- a/wpa_supplicant/wpa_supplicant.c
 +++ b/wpa_supplicant/wpa_supplicant.c
-@@ -3638,6 +3638,12 @@ static void wpas_start_assoc_cb(struct w
+@@ -3865,6 +3865,12 @@ static void wpas_start_assoc_cb(struct w
  			params.beacon_int = ssid->beacon_int;
  		else
  			params.beacon_int = wpa_s->conf->beacon_int;
diff --git a/package/network/services/hostapd/patches/461-driver_nl80211-use-new-parameters-during-ibss-join.patch b/package/network/services/hostapd/patches/461-driver_nl80211-use-new-parameters-during-ibss-join.patch
index b5dec991d0..0be77f9845 100644
--- a/package/network/services/hostapd/patches/461-driver_nl80211-use-new-parameters-during-ibss-join.patch
+++ b/package/network/services/hostapd/patches/461-driver_nl80211-use-new-parameters-during-ibss-join.patch
@@ -10,7 +10,7 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
 
 --- a/src/drivers/driver_nl80211.c
 +++ b/src/drivers/driver_nl80211.c
-@@ -5601,7 +5601,7 @@ static int wpa_driver_nl80211_ibss(struc
+@@ -5966,7 +5966,7 @@ static int wpa_driver_nl80211_ibss(struc
  				   struct wpa_driver_associate_params *params)
  {
  	struct nl_msg *msg;
@@ -19,7 +19,7 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
  	int count = 0;
  
  	wpa_printf(MSG_DEBUG, "nl80211: Join IBSS (ifindex=%d)", drv->ifindex);
-@@ -5628,6 +5628,37 @@ retry:
+@@ -5993,6 +5993,37 @@ retry:
  	    nl80211_put_beacon_int(msg, params->beacon_int))
  		goto fail;
  
diff --git a/package/network/services/hostapd/patches/463-add-mcast_rate-to-11s.patch b/package/network/services/hostapd/patches/463-add-mcast_rate-to-11s.patch
index 7e21da263d..bd1d4d7565 100644
--- a/package/network/services/hostapd/patches/463-add-mcast_rate-to-11s.patch
+++ b/package/network/services/hostapd/patches/463-add-mcast_rate-to-11s.patch
@@ -19,17 +19,17 @@ Tested-by: Simon Wunderlich <simon.wunderlich@openmesh.com>
 
 --- a/src/drivers/driver.h
 +++ b/src/drivers/driver.h
-@@ -1549,6 +1549,7 @@ struct wpa_driver_mesh_join_params {
+@@ -1624,6 +1624,7 @@ struct wpa_driver_mesh_join_params {
  #define WPA_DRIVER_MESH_FLAG_AMPE	0x00000008
  	unsigned int flags;
- 	u8 handle_dfs;
+ 	bool handle_dfs;
 +	int mcast_rate;
  };
  
  struct wpa_driver_set_key_params {
 --- a/src/drivers/driver_nl80211.c
 +++ b/src/drivers/driver_nl80211.c
-@@ -10058,6 +10058,18 @@ static int nl80211_put_mesh_id(struct nl
+@@ -10496,6 +10496,18 @@ static int nl80211_put_mesh_id(struct nl
  }
  
  
@@ -48,7 +48,7 @@ Tested-by: Simon Wunderlich <simon.wunderlich@openmesh.com>
  static int nl80211_put_mesh_config(struct nl_msg *msg,
  				   struct wpa_driver_mesh_bss_params *params)
  {
-@@ -10119,6 +10131,7 @@ static int nl80211_join_mesh(struct i802
+@@ -10557,6 +10569,7 @@ static int nl80211_join_mesh(struct i802
  	    nl80211_put_basic_rates(msg, params->basic_rates) ||
  	    nl80211_put_mesh_id(msg, params->meshid, params->meshid_len) ||
  	    nl80211_put_beacon_int(msg, params->beacon_int) ||
@@ -58,7 +58,7 @@ Tested-by: Simon Wunderlich <simon.wunderlich@openmesh.com>
  
 --- a/wpa_supplicant/mesh.c
 +++ b/wpa_supplicant/mesh.c
-@@ -592,6 +592,7 @@ int wpa_supplicant_join_mesh(struct wpa_
+@@ -631,6 +631,7 @@ int wpa_supplicant_join_mesh(struct wpa_
  
  	params->meshid = ssid->ssid;
  	params->meshid_len = ssid->ssid_len;
diff --git a/package/network/services/hostapd/patches/464-fix-mesh-obss-check.patch b/package/network/services/hostapd/patches/464-fix-mesh-obss-check.patch
index 6d48175163..4807727e0e 100644
--- a/package/network/services/hostapd/patches/464-fix-mesh-obss-check.patch
+++ b/package/network/services/hostapd/patches/464-fix-mesh-obss-check.patch
@@ -1,6 +1,6 @@
 --- a/wpa_supplicant/wpa_supplicant.c
 +++ b/wpa_supplicant/wpa_supplicant.c
-@@ -2407,11 +2407,13 @@ void ibss_mesh_setup_freq(struct wpa_sup
+@@ -2512,11 +2512,13 @@ void ibss_mesh_setup_freq(struct wpa_sup
  	for (j = 0; j < wpa_s->last_scan_res_used; j++) {
  		struct wpa_bss *bss = wpa_s->last_scan_res[j];
  
diff --git a/package/network/services/hostapd/patches/470-survey_data_fallback.patch b/package/network/services/hostapd/patches/470-survey_data_fallback.patch
index 57a78ee865..359b5f3ef8 100644
--- a/package/network/services/hostapd/patches/470-survey_data_fallback.patch
+++ b/package/network/services/hostapd/patches/470-survey_data_fallback.patch
@@ -1,26 +1,6 @@
 --- a/src/ap/acs.c
 +++ b/src/ap/acs.c
-@@ -302,18 +302,12 @@ static void acs_fail(struct hostapd_ifac
- static long double
- acs_survey_interference_factor(struct freq_survey *survey, s8 min_nf)
- {
--	long double factor, busy, total;
-+	long double factor, busy = 0, total;
- 
- 	if (survey->filled & SURVEY_HAS_CHAN_TIME_BUSY)
- 		busy = survey->channel_time_busy;
- 	else if (survey->filled & SURVEY_HAS_CHAN_TIME_RX)
- 		busy = survey->channel_time_rx;
--	else {
--		/* This shouldn't really happen as survey data is checked in
--		 * acs_sanity_check() */
--		wpa_printf(MSG_ERROR, "ACS: Survey data missing");
--		return 0;
--	}
- 
- 	total = survey->channel_time;
- 
-@@ -415,20 +409,19 @@ static int acs_usable_vht160_chan(const
+@@ -420,20 +420,19 @@ static int acs_usable_bw160_chan(const s
  static int acs_survey_is_sufficient(struct freq_survey *survey)
  {
  	if (!(survey->filled & SURVEY_HAS_NF)) {
diff --git a/package/network/services/hostapd/patches/500-lto-jobserver-support.patch b/package/network/services/hostapd/patches/500-lto-jobserver-support.patch
index 46030859de..c51db01fec 100644
--- a/package/network/services/hostapd/patches/500-lto-jobserver-support.patch
+++ b/package/network/services/hostapd/patches/500-lto-jobserver-support.patch
@@ -1,16 +1,17 @@
 --- a/hostapd/Makefile
 +++ b/hostapd/Makefile
-@@ -1327,14 +1327,14 @@ hostapd_multi.a: $(BCHECK) $(OBJS)
+@@ -1297,7 +1297,7 @@ hostapd_multi.a: $(BCHECK) $(OBJS)
  	@$(AR) cr $@ hostapd_multi.o $(OBJS)
  
- hostapd: $(BCHECK) $(OBJS)
+ hostapd: $(OBJS)
 -	$(Q)$(CC) $(LDFLAGS) -o hostapd $(OBJS) $(LIBS)
 +	+$(Q)$(CC) $(LDFLAGS) -o hostapd $(OBJS) $(LIBS)
  	@$(E) "  LD " $@
  
  ifdef CONFIG_WPA_TRACE
- OBJS_c += ../src/utils/trace.o
- endif
+@@ -1308,7 +1308,7 @@ _OBJS_VAR := OBJS_c
+ include ../src/objs.mk
+ 
  hostapd_cli: $(OBJS_c)
 -	$(Q)$(CC) $(LDFLAGS) -o hostapd_cli $(OBJS_c) $(LIBS_c)
 +	+$(Q)$(CC) $(LDFLAGS) -o hostapd_cli $(OBJS_c) $(LIBS_c)
@@ -19,7 +20,7 @@
  NOBJS = nt_password_hash.o ../src/crypto/ms_funcs.o $(SHA1OBJS)
 --- a/wpa_supplicant/Makefile
 +++ b/wpa_supplicant/Makefile
-@@ -1930,23 +1930,23 @@ wpa_supplicant_multi.a: .config $(BCHECK
+@@ -1920,31 +1920,31 @@ wpa_supplicant_multi.a: .config $(BCHECK
  	@$(AR) cr $@ wpa_supplicant_multi.o $(OBJS)
  
  wpa_supplicant: $(BCHECK) $(OBJS) $(EXTRA_progs)
@@ -27,21 +28,29 @@
 +	+$(Q)$(LDO) $(LDFLAGS) -o wpa_supplicant $(OBJS) $(LIBS) $(EXTRALIBS)
  	@$(E) "  LD " $@
  
+ _OBJS_VAR := OBJS_t
+ include ../src/objs.mk
  eapol_test: $(OBJS_t)
 -	$(Q)$(LDO) $(LDFLAGS) -o eapol_test $(OBJS_t) $(LIBS)
 +	+$(Q)$(LDO) $(LDFLAGS) -o eapol_test $(OBJS_t) $(LIBS)
  	@$(E) "  LD " $@
  
+ _OBJS_VAR := OBJS_t2
+ include ../src/objs.mk
  preauth_test: $(OBJS_t2)
 -	$(Q)$(LDO) $(LDFLAGS) -o preauth_test $(OBJS_t2) $(LIBS)
 +	+$(Q)$(LDO) $(LDFLAGS) -o preauth_test $(OBJS_t2) $(LIBS)
  	@$(E) "  LD " $@
  
+ _OBJS_VAR := OBJS_p
+ include ../src/objs.mk
  wpa_passphrase: $(OBJS_p)
 -	$(Q)$(LDO) $(LDFLAGS) -o wpa_passphrase $(OBJS_p) $(LIBS_p) $(LIBS)
 +	+$(Q)$(LDO) $(LDFLAGS) -o wpa_passphrase $(OBJS_p) $(LIBS_p) $(LIBS)
  	@$(E) "  LD " $@
  
+ _OBJS_VAR := OBJS_c
+ include ../src/objs.mk
  wpa_cli: $(OBJS_c)
 -	$(Q)$(LDO) $(LDFLAGS) -o wpa_cli $(OBJS_c) $(LIBS_c)
 +	+$(Q)$(LDO) $(LDFLAGS) -o wpa_cli $(OBJS_c) $(LIBS_c)
diff --git a/package/network/services/hostapd/patches/590-rrm-wnm-statistics.patch b/package/network/services/hostapd/patches/590-rrm-wnm-statistics.patch
new file mode 100644
index 0000000000..ee3ab7938a
--- /dev/null
+++ b/package/network/services/hostapd/patches/590-rrm-wnm-statistics.patch
@@ -0,0 +1,92 @@
+--- a/src/ap/hostapd.h
++++ b/src/ap/hostapd.h
+@@ -150,6 +150,21 @@ struct hostapd_sae_commit_queue {
+ };
+ 
+ /**
++ * struct hostapd_openwrt_stats - OpenWrt custom STA/AP statistics
++ */
++struct hostapd_openwrt_stats {
++	struct {
++		u64 neighbor_report_tx;
++	} rrm;
++
++	struct {
++		u64 bss_transition_query_rx;
++		u64 bss_transition_request_tx;
++		u64 bss_transition_response_rx;
++	} wnm;
++};
++
++/**
+  * struct hostapd_data - hostapd per-BSS data structure
+  */
+ struct hostapd_data {
+@@ -163,6 +178,9 @@ struct hostapd_data {
+ 
+ 	u8 own_addr[ETH_ALEN];
+ 
++	/* OpenWrt specific statistics */
++	struct hostapd_openwrt_stats openwrt_stats;
++
+ 	int num_sta; /* number of entries in sta_list */
+ 	struct sta_info *sta_list; /* STA info list head */
+ #define STA_HASH_SIZE 256
+--- a/src/ap/wnm_ap.c
++++ b/src/ap/wnm_ap.c
+@@ -386,6 +386,7 @@ static int ieee802_11_send_bss_trans_mgm
+ 	mgmt->u.action.u.bss_tm_req.validity_interval = 1;
+ 	pos = mgmt->u.action.u.bss_tm_req.variable;
+ 
++	hapd->openwrt_stats.wnm.bss_transition_request_tx++;
+ 	wpa_printf(MSG_DEBUG, "WNM: Send BSS Transition Management Request to "
+ 		   MACSTR " dialog_token=%u req_mode=0x%x disassoc_timer=%u "
+ 		   "validity_interval=%u",
+@@ -646,10 +647,12 @@ int ieee802_11_rx_wnm_action_ap(struct h
+ 
+ 	switch (action) {
+ 	case WNM_BSS_TRANS_MGMT_QUERY:
++		hapd->openwrt_stats.wnm.bss_transition_query_rx++;
+ 		ieee802_11_rx_bss_trans_mgmt_query(hapd, mgmt->sa, payload,
+ 						   plen);
+ 		return 0;
+ 	case WNM_BSS_TRANS_MGMT_RESP:
++		hapd->openwrt_stats.wnm.bss_transition_response_rx++;
+ 		ieee802_11_rx_bss_trans_mgmt_resp(hapd, mgmt->sa, payload,
+ 						  plen);
+ 		return 0;
+@@ -696,6 +699,7 @@ int wnm_send_disassoc_imminent(struct ho
+ 
+ 	pos = mgmt->u.action.u.bss_tm_req.variable;
+ 
++	hapd->openwrt_stats.wnm.bss_transition_request_tx++;
+ 	wpa_printf(MSG_DEBUG, "WNM: Send BSS Transition Management Request frame to indicate imminent disassociation (disassoc_timer=%d) to "
+ 		   MACSTR, disassoc_timer, MAC2STR(sta->addr));
+ 	if (hostapd_drv_send_mlme(hapd, buf, pos - buf, 0, NULL, 0, 0) < 0) {
+@@ -777,6 +781,7 @@ int wnm_send_ess_disassoc_imminent(struc
+ 		return -1;
+ 	}
+ 
++	hapd->openwrt_stats.wnm.bss_transition_request_tx++;
+ 	if (disassoc_timer) {
+ 		/* send disassociation frame after time-out */
+ 		set_disassoc_timer(hapd, sta, disassoc_timer);
+@@ -857,6 +862,7 @@ int wnm_send_bss_tm_req(struct hostapd_d
+ 	}
+ 	os_free(buf);
+ 
++	hapd->openwrt_stats.wnm.bss_transition_request_tx++;
+ 	if (disassoc_timer) {
+ 		/* send disassociation frame after time-out */
+ 		set_disassoc_timer(hapd, sta, disassoc_timer);
+--- a/src/ap/rrm.c
++++ b/src/ap/rrm.c
+@@ -269,6 +269,8 @@ static void hostapd_send_nei_report_resp
+ 		}
+ 	}
+ 
++	hapd->openwrt_stats.rrm.neighbor_report_tx++;
++
+ 	hostapd_drv_send_action(hapd, hapd->iface->freq, 0, addr,
+ 				wpabuf_head(buf), wpabuf_len(buf));
+ 	wpabuf_free(buf);
diff --git a/package/network/services/hostapd/patches/600-ubus_support.patch b/package/network/services/hostapd/patches/600-ubus_support.patch
index 53f521e649..6a0acbb318 100644
--- a/package/network/services/hostapd/patches/600-ubus_support.patch
+++ b/package/network/services/hostapd/patches/600-ubus_support.patch
@@ -1,6 +1,6 @@
 --- a/hostapd/Makefile
 +++ b/hostapd/Makefile
-@@ -171,6 +171,11 @@ OBJS += ../src/common/hw_features_common
+@@ -166,6 +166,11 @@ OBJS += ../src/common/hw_features_common
  
  OBJS += ../src/eapol_auth/eapol_auth_sm.o
  
@@ -31,7 +31,7 @@
  };
  
  enum hostapd_chan_status {
-@@ -154,6 +155,7 @@ struct hostapd_data {
+@@ -171,6 +172,7 @@ struct hostapd_data {
  	struct hostapd_iface *iface;
  	struct hostapd_config *iconf;
  	struct hostapd_bss_config *conf;
@@ -39,7 +39,7 @@
  	int interface_added; /* virtual interface added for this BSS */
  	unsigned int started:1;
  	unsigned int disabled:1;
-@@ -606,6 +608,7 @@ hostapd_alloc_bss_data(struct hostapd_if
+@@ -630,6 +632,7 @@ hostapd_alloc_bss_data(struct hostapd_if
  		       struct hostapd_bss_config *bss);
  int hostapd_setup_interface(struct hostapd_iface *iface);
  int hostapd_setup_interface_complete(struct hostapd_iface *iface, int err);
@@ -49,7 +49,7 @@
  struct hostapd_iface * hostapd_alloc_iface(void);
 --- a/src/ap/hostapd.c
 +++ b/src/ap/hostapd.c
-@@ -395,6 +395,7 @@ void hostapd_free_hapd_data(struct hosta
+@@ -396,6 +396,7 @@ void hostapd_free_hapd_data(struct hosta
  	hapd->beacon_set_done = 0;
  
  	wpa_printf(MSG_DEBUG, "%s(%s)", __func__, hapd->conf->iface);
@@ -57,7 +57,7 @@
  	accounting_deinit(hapd);
  	hostapd_deinit_wpa(hapd);
  	vlan_deinit(hapd);
-@@ -1417,6 +1418,8 @@ static int hostapd_setup_bss(struct host
+@@ -1422,6 +1423,8 @@ static int hostapd_setup_bss(struct host
  	if (hapd->driver && hapd->driver->set_operstate)
  		hapd->driver->set_operstate(hapd->drv_priv, 1);
  
@@ -66,7 +66,7 @@
  	return 0;
  }
  
-@@ -1999,6 +2002,7 @@ static int hostapd_setup_interface_compl
+@@ -2028,6 +2031,7 @@ static int hostapd_setup_interface_compl
  	if (err)
  		goto fail;
  
@@ -74,7 +74,7 @@
  	wpa_printf(MSG_DEBUG, "Completing interface initialization");
  	if (iface->freq) {
  #ifdef NEED_AP_MLME
-@@ -2196,6 +2200,7 @@ dfs_offload:
+@@ -2225,6 +2229,7 @@ dfs_offload:
  
  fail:
  	wpa_printf(MSG_ERROR, "Interface initialization failed");
@@ -82,7 +82,7 @@
  	hostapd_set_state(iface, HAPD_IFACE_DISABLED);
  	wpa_msg(hapd->msg_ctx, MSG_INFO, AP_EVENT_DISABLED);
  #ifdef CONFIG_FST
-@@ -2669,6 +2674,7 @@ void hostapd_interface_deinit_free(struc
+@@ -2700,6 +2705,7 @@ void hostapd_interface_deinit_free(struc
  		   (unsigned int) iface->conf->num_bss);
  	driver = iface->bss[0]->driver;
  	drv_priv = iface->bss[0]->drv_priv;
@@ -92,7 +92,7 @@
  		   __func__, driver, drv_priv);
 --- a/src/ap/ieee802_11.c
 +++ b/src/ap/ieee802_11.c
-@@ -2327,13 +2327,18 @@ static void handle_auth(struct hostapd_d
+@@ -3553,13 +3553,18 @@ static void handle_auth(struct hostapd_d
  	u16 auth_alg, auth_transaction, status_code;
  	u16 resp = WLAN_STATUS_SUCCESS;
  	struct sta_info *sta = NULL;
@@ -112,7 +112,7 @@
  
  	if (len < IEEE80211_HDRLEN + sizeof(mgmt->u.auth)) {
  		wpa_printf(MSG_INFO, "handle_auth - too short payload (len=%lu)",
-@@ -2493,6 +2498,13 @@ static void handle_auth(struct hostapd_d
+@@ -3727,6 +3732,13 @@ static void handle_auth(struct hostapd_d
  		resp = WLAN_STATUS_UNSPECIFIED_FAILURE;
  		goto fail;
  	}
@@ -126,16 +126,16 @@
  	if (res == HOSTAPD_ACL_PENDING)
  		return;
  
-@@ -4157,7 +4169,7 @@ static void handle_assoc(struct hostapd_
+@@ -5447,7 +5459,7 @@ static void handle_assoc(struct hostapd_
  	int resp = WLAN_STATUS_SUCCESS;
- 	u16 reply_res;
+ 	u16 reply_res = WLAN_STATUS_UNSPECIFIED_FAILURE;
  	const u8 *pos;
 -	int left, i;
 +	int left, i, ubus_resp;
  	struct sta_info *sta;
  	u8 *tmp = NULL;
  #ifdef CONFIG_FILS
-@@ -4370,6 +4382,11 @@ static void handle_assoc(struct hostapd_
+@@ -5660,6 +5672,11 @@ static void handle_assoc(struct hostapd_
  		left = res;
  	}
  #endif /* CONFIG_FILS */
@@ -147,7 +147,7 @@
  
  	/* followed by SSID and Supported rates; and HT capabilities if 802.11n
  	 * is used */
-@@ -4468,6 +4485,14 @@ static void handle_assoc(struct hostapd_
+@@ -5758,6 +5775,13 @@ static void handle_assoc(struct hostapd_
  	}
  #endif /* CONFIG_FILS */
  
@@ -158,11 +158,10 @@
 +		resp = ubus_resp > 0 ? (u16) ubus_resp : WLAN_STATUS_UNSPECIFIED_FAILURE;
 +		goto fail;
 +	}
-+
   fail:
  
  	/*
-@@ -4561,6 +4586,7 @@ static void handle_disassoc(struct hosta
+@@ -5851,6 +5875,7 @@ static void handle_disassoc(struct hosta
  	wpa_printf(MSG_DEBUG, "disassocation: STA=" MACSTR " reason_code=%d",
  		   MAC2STR(mgmt->sa),
  		   le_to_host16(mgmt->u.disassoc.reason_code));
@@ -170,9 +169,9 @@
  
  	sta = ap_get_sta(hapd, mgmt->sa);
  	if (sta == NULL) {
-@@ -4627,6 +4653,8 @@ static void handle_deauth(struct hostapd
- 		" reason_code=%d",
- 		MAC2STR(mgmt->sa), le_to_host16(mgmt->u.deauth.reason_code));
+@@ -5920,6 +5945,8 @@ static void handle_deauth(struct hostapd
+ 	/* Clear the PTKSA cache entries for PASN */
+ 	ptksa_cache_flush(hapd->ptksa, mgmt->sa, WPA_CIPHER_NONE);
  
 +	hostapd_ubus_notify(hapd, "deauth", mgmt->sa);
 +
@@ -181,7 +180,7 @@
  		wpa_msg(hapd->msg_ctx, MSG_DEBUG, "Station " MACSTR " trying "
 --- a/src/ap/beacon.c
 +++ b/src/ap/beacon.c
-@@ -814,6 +814,12 @@ void handle_probe_req(struct hostapd_dat
+@@ -852,6 +852,12 @@ void handle_probe_req(struct hostapd_dat
  	u16 csa_offs[2];
  	size_t csa_offs_len;
  	struct radius_sta rad_info;
@@ -192,9 +191,9 @@
 +		.elems = &elems,
 +	};
  
- 	if (len < IEEE80211_HDRLEN)
- 		return;
-@@ -996,6 +1002,12 @@ void handle_probe_req(struct hostapd_dat
+ 	if (hapd->iconf->rssi_ignore_probe_request && ssi_signal &&
+ 	    ssi_signal < hapd->iconf->rssi_ignore_probe_request)
+@@ -1038,6 +1044,12 @@ void handle_probe_req(struct hostapd_dat
  	}
  #endif /* CONFIG_P2P */
  
@@ -209,7 +208,7 @@
  
 --- a/src/ap/drv_callbacks.c
 +++ b/src/ap/drv_callbacks.c
-@@ -119,6 +119,10 @@ int hostapd_notif_assoc(struct hostapd_d
+@@ -145,6 +145,10 @@ int hostapd_notif_assoc(struct hostapd_d
  	u16 reason = WLAN_REASON_UNSPECIFIED;
  	int status = WLAN_STATUS_SUCCESS;
  	const u8 *p2p_dev_addr = NULL;
@@ -220,7 +219,7 @@
  
  	if (addr == NULL) {
  		/*
-@@ -211,6 +215,12 @@ int hostapd_notif_assoc(struct hostapd_d
+@@ -237,6 +241,12 @@ int hostapd_notif_assoc(struct hostapd_d
  		goto fail;
  	}
  
@@ -235,7 +234,7 @@
  		wpabuf_free(sta->p2p_ie);
 --- a/src/ap/sta_info.c
 +++ b/src/ap/sta_info.c
-@@ -423,6 +423,7 @@ void ap_handle_timer(void *eloop_ctx, vo
+@@ -458,6 +458,7 @@ void ap_handle_timer(void *eloop_ctx, vo
  		hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
  			       HOSTAPD_LEVEL_INFO, "deauthenticated due to "
  			       "local deauth request");
@@ -243,7 +242,7 @@
  		ap_free_sta(hapd, sta);
  		return;
  	}
-@@ -578,6 +579,7 @@ skip_poll:
+@@ -613,6 +614,7 @@ skip_poll:
  		mlme_deauthenticate_indication(
  			hapd, sta,
  			WLAN_REASON_PREV_AUTH_NOT_VALID);
@@ -251,7 +250,7 @@
  		ap_free_sta(hapd, sta);
  		break;
  	}
-@@ -1294,6 +1296,7 @@ void ap_sta_set_authorized(struct hostap
+@@ -1329,6 +1331,7 @@ void ap_sta_set_authorized(struct hostap
  					  buf, ip_addr, keyid_buf);
  	} else {
  		wpa_msg(hapd->msg_ctx, MSG_INFO, AP_STA_DISCONNECTED "%s", buf);
@@ -261,7 +260,7 @@
  		    hapd->msg_ctx_parent != hapd->msg_ctx)
 --- a/src/ap/wpa_auth_glue.c
 +++ b/src/ap/wpa_auth_glue.c
-@@ -259,6 +259,7 @@ static void hostapd_wpa_auth_psk_failure
+@@ -265,6 +265,7 @@ static void hostapd_wpa_auth_psk_failure
  	struct hostapd_data *hapd = ctx;
  	wpa_msg(hapd->msg_ctx, MSG_INFO, AP_STA_POSSIBLE_PSK_MISMATCH MACSTR,
  		MAC2STR(addr));
@@ -271,7 +270,7 @@
  
 --- a/wpa_supplicant/Makefile
 +++ b/wpa_supplicant/Makefile
-@@ -190,6 +190,12 @@ ifdef CONFIG_EAPOL_TEST
+@@ -176,6 +176,12 @@ ifdef CONFIG_EAPOL_TEST
  CFLAGS += -Werror -DEAPOL_TEST
  endif
  
@@ -284,7 +283,7 @@
  ifdef CONFIG_CODE_COVERAGE
  CFLAGS += -O0 -fprofile-arcs -ftest-coverage
  LIBS += -lgcov
-@@ -956,6 +962,9 @@ ifdef CONFIG_CTRL_IFACE_MIB
+@@ -962,6 +968,9 @@ ifdef CONFIG_CTRL_IFACE_MIB
  CFLAGS += -DCONFIG_CTRL_IFACE_MIB
  endif
  OBJS += ../src/ap/ctrl_iface_ap.o
@@ -296,7 +295,7 @@
  CFLAGS += -DEAP_SERVER -DEAP_SERVER_IDENTITY
 --- a/wpa_supplicant/wpa_supplicant.c
 +++ b/wpa_supplicant/wpa_supplicant.c
-@@ -6794,6 +6794,8 @@ struct wpa_supplicant * wpa_supplicant_a
+@@ -7241,6 +7241,8 @@ struct wpa_supplicant * wpa_supplicant_a
  	}
  #endif /* CONFIG_P2P */
  
@@ -305,7 +304,7 @@
  	return wpa_s;
  }
  
-@@ -6820,6 +6822,8 @@ int wpa_supplicant_remove_iface(struct w
+@@ -7267,6 +7269,8 @@ int wpa_supplicant_remove_iface(struct w
  	struct wpa_supplicant *parent = wpa_s->parent;
  #endif /* CONFIG_MESH */
  
@@ -314,7 +313,7 @@
  	/* Remove interface from the global list of interfaces */
  	prev = global->ifaces;
  	if (prev == wpa_s) {
-@@ -7123,8 +7127,12 @@ int wpa_supplicant_run(struct wpa_global
+@@ -7570,8 +7574,12 @@ int wpa_supplicant_run(struct wpa_global
  	eloop_register_signal_terminate(wpa_supplicant_terminate, global);
  	eloop_register_signal_reconfig(wpa_supplicant_reconfig, global);
  
@@ -329,7 +328,7 @@
  
 --- a/wpa_supplicant/wpa_supplicant_i.h
 +++ b/wpa_supplicant/wpa_supplicant_i.h
-@@ -17,6 +17,7 @@
+@@ -19,6 +19,7 @@
  #include "wps/wps_defs.h"
  #include "config_ssid.h"
  #include "wmm_ac.h"
@@ -337,7 +336,7 @@
  
  extern const char *const wpa_supplicant_version;
  extern const char *const wpa_supplicant_license;
-@@ -310,6 +311,8 @@ struct wpa_global {
+@@ -322,6 +323,8 @@ struct wpa_global {
  #endif /* CONFIG_WIFI_DISPLAY */
  
  	struct psk_list_entry *add_psk; /* From group formation */
@@ -346,7 +345,7 @@
  };
  
  
-@@ -520,6 +523,7 @@ struct wpa_supplicant {
+@@ -708,6 +711,7 @@ struct wpa_supplicant {
  	unsigned char own_addr[ETH_ALEN];
  	unsigned char perm_addr[ETH_ALEN];
  	char ifname[100];
@@ -364,7 +363,7 @@
  
  
  #ifndef WPS_PIN_SCAN_IGNORE_SEL_REG
-@@ -392,6 +393,8 @@ static int wpa_supplicant_wps_cred(void
+@@ -393,6 +394,8 @@ static int wpa_supplicant_wps_cred(void
  	wpa_hexdump_key(MSG_DEBUG, "WPS: Received Credential attribute",
  			cred->cred_attr, cred->cred_attr_len);
  
@@ -375,7 +374,7 @@
  
 --- a/hostapd/main.c
 +++ b/hostapd/main.c
-@@ -896,6 +896,7 @@ int main(int argc, char *argv[])
+@@ -895,6 +895,7 @@ int main(int argc, char *argv[])
  	}
  
  	hostapd_global_ctrl_iface_init(&interfaces);
@@ -383,7 +382,7 @@
  
  	if (hostapd_global_run(&interfaces, daemonize, pid_file)) {
  		wpa_printf(MSG_ERROR, "Failed to start eloop");
-@@ -905,6 +906,7 @@ int main(int argc, char *argv[])
+@@ -904,6 +905,7 @@ int main(int argc, char *argv[])
  	ret = 0;
  
   out:
@@ -424,3 +423,133 @@
  }
  
  
+--- a/src/ap/vlan_init.c
++++ b/src/ap/vlan_init.c
+@@ -22,6 +22,7 @@
+ static int vlan_if_add(struct hostapd_data *hapd, struct hostapd_vlan *vlan,
+ 		       int existsok)
+ {
++	bool vlan_exists = iface_exists(vlan->ifname);
+ 	int ret;
+ #ifdef CONFIG_WEP
+ 	int i;
+@@ -36,7 +37,7 @@ static int vlan_if_add(struct hostapd_da
+ 	}
+ #endif /* CONFIG_WEP */
+ 
+-	if (!iface_exists(vlan->ifname))
++	if (!vlan_exists)
+ 		ret = hostapd_vlan_if_add(hapd, vlan->ifname);
+ 	else if (!existsok)
+ 		return -1;
+@@ -51,6 +52,9 @@ static int vlan_if_add(struct hostapd_da
+ 	if (hapd->wpa_auth)
+ 		ret = wpa_auth_ensure_group(hapd->wpa_auth, vlan->vlan_id);
+ 
++	if (!ret && !vlan_exists)
++		hostapd_ubus_add_vlan(hapd, vlan);
++
+ 	if (ret == 0)
+ 		return ret;
+ 
+@@ -77,6 +81,8 @@ int vlan_if_remove(struct hostapd_data *
+ 			   "WPA deinitialization for VLAN %d failed (%d)",
+ 			   vlan->vlan_id, ret);
+ 
++	hostapd_ubus_remove_vlan(hapd, vlan);
++
+ 	return hostapd_vlan_if_remove(hapd, vlan->ifname);
+ }
+ 
+--- a/src/ap/dfs.c
++++ b/src/ap/dfs.c
+@@ -1196,6 +1196,8 @@ int hostapd_dfs_radar_detected(struct ho
+ 		"freq=%d ht_enabled=%d chan_offset=%d chan_width=%d cf1=%d cf2=%d",
+ 		freq, ht_enabled, chan_offset, chan_width, cf1, cf2);
+ 
++	hostapd_ubus_notify_radar_detected(iface, freq, chan_width, cf1, cf2);
++
+ 	/* Proceed only if DFS is not offloaded to the driver */
+ 	if (iface->drv_flags & WPA_DRIVER_FLAGS_DFS_OFFLOAD)
+ 		return 0;
+--- a/src/ap/airtime_policy.c
++++ b/src/ap/airtime_policy.c
+@@ -112,8 +112,14 @@ static void set_sta_weights(struct hosta
+ {
+ 	struct sta_info *sta;
+ 
+-	for (sta = hapd->sta_list; sta; sta = sta->next)
+-		sta_set_airtime_weight(hapd, sta, weight);
++	for (sta = hapd->sta_list; sta; sta = sta->next) {
++		unsigned int sta_weight = weight;
++
++		if (sta->dyn_airtime_weight)
++			sta_weight = (weight * sta->dyn_airtime_weight) / 256;
++
++		sta_set_airtime_weight(hapd, sta, sta_weight);
++	}
+ }
+ 
+ 
+@@ -244,7 +250,10 @@ int airtime_policy_new_sta(struct hostap
+ 	unsigned int weight;
+ 
+ 	if (hapd->iconf->airtime_mode == AIRTIME_MODE_STATIC) {
+-		weight = get_weight_for_sta(hapd, sta->addr);
++		if (sta->dyn_airtime_weight)
++			weight = sta->dyn_airtime_weight;
++		else
++			weight = get_weight_for_sta(hapd, sta->addr);
+ 		if (weight)
+ 			return sta_set_airtime_weight(hapd, sta, weight);
+ 	}
+--- a/src/ap/sta_info.h
++++ b/src/ap/sta_info.h
+@@ -324,6 +324,7 @@ struct sta_info {
+ #endif /* CONFIG_TESTING_OPTIONS */
+ #ifdef CONFIG_AIRTIME_POLICY
+ 	unsigned int airtime_weight;
++	unsigned int dyn_airtime_weight;
+ 	struct os_reltime backlogged_until;
+ #endif /* CONFIG_AIRTIME_POLICY */
+ 
+--- a/src/ap/wnm_ap.c
++++ b/src/ap/wnm_ap.c
+@@ -442,7 +442,8 @@ static void ieee802_11_rx_bss_trans_mgmt
+ 	wpa_hexdump(MSG_DEBUG, "WNM: BSS Transition Candidate List Entries",
+ 		    pos, end - pos);
+ 
+-	ieee802_11_send_bss_trans_mgmt_request(hapd, addr, dialog_token);
++	if (!hostapd_ubus_notify_bss_transition_query(hapd, addr, dialog_token, reason, pos, end - pos))
++		ieee802_11_send_bss_trans_mgmt_request(hapd, addr, dialog_token);
+ }
+ 
+ 
+@@ -464,7 +465,7 @@ static void ieee802_11_rx_bss_trans_mgmt
+ 					      size_t len)
+ {
+ 	u8 dialog_token, status_code, bss_termination_delay;
+-	const u8 *pos, *end;
++	const u8 *pos, *end, *target_bssid = NULL;
+ 	int enabled = hapd->conf->bss_transition;
+ 	struct sta_info *sta;
+ 
+@@ -511,6 +512,7 @@ static void ieee802_11_rx_bss_trans_mgmt
+ 			wpa_printf(MSG_DEBUG, "WNM: not enough room for Target BSSID field");
+ 			return;
+ 		}
++		target_bssid = pos;
+ 		sta->agreed_to_steer = 1;
+ 		eloop_cancel_timeout(ap_sta_reset_steer_flag_timer, hapd, sta);
+ 		eloop_register_timeout(2, 0, ap_sta_reset_steer_flag_timer,
+@@ -530,6 +532,10 @@ static void ieee802_11_rx_bss_trans_mgmt
+ 			MAC2STR(addr), status_code, bss_termination_delay);
+ 	}
+ 
++	hostapd_ubus_notify_bss_transition_response(hapd, sta->addr, dialog_token,
++						    status_code, bss_termination_delay,
++						    target_bssid, pos, end - pos);
++
+ 	wpa_hexdump(MSG_DEBUG, "WNM: BSS Transition Candidate List Entries",
+ 		    pos, end - pos);
+ }
diff --git a/package/network/services/hostapd/patches/610-hostapd_cli_ujail_permission.patch b/package/network/services/hostapd/patches/610-hostapd_cli_ujail_permission.patch
new file mode 100644
index 0000000000..a03fcc9f92
--- /dev/null
+++ b/package/network/services/hostapd/patches/610-hostapd_cli_ujail_permission.patch
@@ -0,0 +1,33 @@
+--- a/src/common/wpa_ctrl.c
++++ b/src/common/wpa_ctrl.c
+@@ -135,7 +135,7 @@ try_again:
+ 		return NULL;
+ 	}
+ 	tries++;
+-#ifdef ANDROID
++
+ 	/* Set client socket file permissions so that bind() creates the client
+ 	 * socket with these permissions and there is no need to try to change
+ 	 * them with chmod() after bind() which would have potential issues with
+@@ -147,7 +147,7 @@ try_again:
+ 	 * operations to allow the response to go through. Those are using the
+ 	 * no-deference-symlinks version to avoid races. */
+ 	fchmod(ctrl->s, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
+-#endif /* ANDROID */
++
+ 	if (bind(ctrl->s, (struct sockaddr *) &ctrl->local,
+ 		    sizeof(ctrl->local)) < 0) {
+ 		if (errno == EADDRINUSE && tries < 2) {
+@@ -165,7 +165,11 @@ try_again:
+ 		return NULL;
+ 	}
+ 
+-#ifdef ANDROID
++#ifndef ANDROID
++	/* Set group even if we do not have privileges to change owner */
++	lchown(ctrl->local.sun_path, -1, 101);
++	lchown(ctrl->local.sun_path, 101, 101);
++#else
+ 	/* Set group even if we do not have privileges to change owner */
+ 	lchown(ctrl->local.sun_path, -1, AID_WIFI);
+ 	lchown(ctrl->local.sun_path, AID_SYSTEM, AID_WIFI);
diff --git a/package/network/services/hostapd/patches/700-wifi-reload.patch b/package/network/services/hostapd/patches/700-wifi-reload.patch
index ceb92265dd..e6d7c2f673 100644
--- a/package/network/services/hostapd/patches/700-wifi-reload.patch
+++ b/package/network/services/hostapd/patches/700-wifi-reload.patch
@@ -1,6 +1,6 @@
 --- a/hostapd/config_file.c
 +++ b/hostapd/config_file.c
-@@ -2501,6 +2501,8 @@ static int hostapd_config_fill(struct ho
+@@ -2458,6 +2458,8 @@ static int hostapd_config_fill(struct ho
  		bss->isolate = atoi(pos);
  	} else if (os_strcmp(buf, "ap_max_inactivity") == 0) {
  		bss->ap_max_inactivity = atoi(pos);
@@ -9,7 +9,7 @@
  	} else if (os_strcmp(buf, "skip_inactivity_poll") == 0) {
  		bss->skip_inactivity_poll = atoi(pos);
  	} else if (os_strcmp(buf, "country_code") == 0) {
-@@ -3197,6 +3199,8 @@ static int hostapd_config_fill(struct ho
+@@ -3158,6 +3160,8 @@ static int hostapd_config_fill(struct ho
  		}
  	} else if (os_strcmp(buf, "acs_exclude_dfs") == 0) {
  		conf->acs_exclude_dfs = atoi(pos);
@@ -20,7 +20,7 @@
  	} else if (os_strcmp(buf, "channel") == 0) {
 --- a/src/ap/ap_config.c
 +++ b/src/ap/ap_config.c
-@@ -780,6 +780,7 @@ void hostapd_config_free_bss(struct host
+@@ -792,6 +792,7 @@ void hostapd_config_free_bss(struct host
  	os_free(conf->radius_req_attr_sqlite);
  	os_free(conf->rsn_preauth_interfaces);
  	os_free(conf->ctrl_interface);
@@ -28,7 +28,7 @@
  	os_free(conf->ca_cert);
  	os_free(conf->server_cert);
  	os_free(conf->server_cert2);
-@@ -972,6 +973,7 @@ void hostapd_config_free(struct hostapd_
+@@ -988,6 +989,7 @@ void hostapd_config_free(struct hostapd_
  
  	for (i = 0; i < conf->num_bss; i++)
  		hostapd_config_free_bss(conf->bss[i]);
@@ -38,25 +38,26 @@
  	os_free(conf->basic_rates);
 --- a/src/ap/ap_config.h
 +++ b/src/ap/ap_config.h
-@@ -871,6 +871,7 @@ struct hostapd_bss_config {
- 	 */
- 	u8 mka_psk_set;
- #endif /* CONFIG_MACSEC */
+@@ -279,6 +279,8 @@ struct hostapd_bss_config {
+ 	char vlan_bridge[IFNAMSIZ + 1];
+ 	char wds_bridge[IFNAMSIZ + 1];
+ 
 +	char *config_id;
- };
++
+ 	enum hostapd_logger_level logger_syslog_level, logger_stdout_level;
  
- /**
-@@ -1062,6 +1063,7 @@ struct hostapd_config {
- 	unsigned int airtime_update_interval;
- #define AIRTIME_MODE_MAX (__AIRTIME_MODE_MAX - 1)
- #endif /* CONFIG_AIRTIME_POLICY */
+ 	unsigned int logger_syslog; /* module bitfield */
+@@ -942,6 +944,7 @@ struct spatial_reuse {
+ struct hostapd_config {
+ 	struct hostapd_bss_config **bss, *last_bss;
+ 	size_t num_bss;
 +	char *config_id;
  
- 	u8 notify_mgmt_frames;
- };
+ 	u16 beacon_int;
+ 	int rts_threshold;
 --- a/src/ap/hostapd.c
 +++ b/src/ap/hostapd.c
-@@ -218,6 +218,10 @@ static int hostapd_iface_conf_changed(st
+@@ -219,6 +219,10 @@ static int hostapd_iface_conf_changed(st
  {
  	size_t i;
  
@@ -67,7 +68,7 @@
  	if (newconf->num_bss != oldconf->num_bss)
  		return 1;
  
-@@ -231,7 +235,7 @@ static int hostapd_iface_conf_changed(st
+@@ -232,7 +236,7 @@ static int hostapd_iface_conf_changed(st
  }
  
  
@@ -76,7 +77,7 @@
  {
  	struct hapd_interfaces *interfaces = iface->interfaces;
  	struct hostapd_data *hapd = iface->bss[0];
-@@ -254,13 +258,16 @@ int hostapd_reload_config(struct hostapd
+@@ -255,13 +259,16 @@ int hostapd_reload_config(struct hostapd
  	if (newconf == NULL)
  		return -1;
  
@@ -95,7 +96,7 @@
  		wpa_printf(MSG_DEBUG,
  			   "Configuration changes include interface/BSS modification - force full disable+enable sequence");
  		fname = os_strdup(iface->config_fname);
-@@ -285,6 +292,24 @@ int hostapd_reload_config(struct hostapd
+@@ -286,6 +293,24 @@ int hostapd_reload_config(struct hostapd
  			wpa_printf(MSG_ERROR,
  				   "Failed to enable interface on config reload");
  		return res;
@@ -120,7 +121,7 @@
  	}
  	iface->conf = newconf;
  
-@@ -301,6 +326,12 @@ int hostapd_reload_config(struct hostapd
+@@ -302,6 +327,12 @@ int hostapd_reload_config(struct hostapd
  
  	for (j = 0; j < iface->num_bss; j++) {
  		hapd = iface->bss[j];
@@ -133,7 +134,7 @@
  		hapd->iconf = newconf;
  		hapd->conf = newconf->bss[j];
  		hostapd_reload_bss(hapd);
-@@ -2366,6 +2397,10 @@ hostapd_alloc_bss_data(struct hostapd_if
+@@ -2397,6 +2428,10 @@ hostapd_alloc_bss_data(struct hostapd_if
  	hapd->iconf = conf;
  	hapd->conf = bss;
  	hapd->iface = hapd_iface;
@@ -155,7 +156,7 @@
  	struct hostapd_config * (*config_read_cb)(const char *config_fname);
  	int (*ctrl_iface_init)(struct hostapd_data *hapd);
  	void (*ctrl_iface_deinit)(struct hostapd_data *hapd);
-@@ -156,6 +156,7 @@ struct hostapd_data {
+@@ -173,6 +173,7 @@ struct hostapd_data {
  	struct hostapd_config *iconf;
  	struct hostapd_bss_config *conf;
  	struct hostapd_ubus_bss ubus;
@@ -163,7 +164,7 @@
  	int interface_added; /* virtual interface added for this BSS */
  	unsigned int started:1;
  	unsigned int disabled:1;
-@@ -600,7 +601,7 @@ struct hostapd_iface {
+@@ -624,7 +625,7 @@ struct hostapd_iface {
  int hostapd_for_each_interface(struct hapd_interfaces *interfaces,
  			       int (*cb)(struct hostapd_iface *iface,
  					 void *ctx), void *ctx);
@@ -174,7 +175,7 @@
  hostapd_alloc_bss_data(struct hostapd_iface *hapd_iface,
 --- a/src/drivers/driver_nl80211.c
 +++ b/src/drivers/driver_nl80211.c
-@@ -4508,6 +4508,9 @@ static int wpa_driver_nl80211_set_ap(voi
+@@ -4833,6 +4833,9 @@ static int wpa_driver_nl80211_set_ap(voi
  	if (ret) {
  		wpa_printf(MSG_DEBUG, "nl80211: Beacon set failed: %d (%s)",
  			   ret, strerror(-ret));
@@ -186,7 +187,7 @@
  		nl80211_set_bss(bss, params->cts_protect, params->preamble,
 --- a/hostapd/ctrl_iface.c
 +++ b/hostapd/ctrl_iface.c
-@@ -184,7 +184,7 @@ static int hostapd_ctrl_iface_update(str
+@@ -186,7 +186,7 @@ static int hostapd_ctrl_iface_update(str
  	iface->interfaces->config_read_cb = hostapd_ctrl_iface_config_read;
  	reload_opts = txt;
  
diff --git a/package/network/services/hostapd/patches/710-vlan_no_bridge.patch b/package/network/services/hostapd/patches/710-vlan_no_bridge.patch
index 7de4e2c1d4..856dc8ba88 100644
--- a/package/network/services/hostapd/patches/710-vlan_no_bridge.patch
+++ b/package/network/services/hostapd/patches/710-vlan_no_bridge.patch
@@ -10,19 +10,27 @@
  #define DYNAMIC_VLAN_NAMING_END 2
 --- a/src/ap/vlan_full.c
 +++ b/src/ap/vlan_full.c
-@@ -466,6 +466,9 @@ void vlan_newlink(const char *ifname, st
- 
- 	wpa_printf(MSG_DEBUG, "VLAN: vlan_newlink(%s)", ifname);
+@@ -475,6 +475,9 @@ void vlan_newlink(const char *ifname, st
+ 	if (!vlan)
+ 		return;
  
 +	if (hapd->conf->ssid.vlan_no_bridge)
-+		return;
++		goto out;
 +
- 	for (vlan = hapd->conf->vlan; vlan; vlan = vlan->next) {
- 		if (vlan->configured ||
- 		    os_strcmp(ifname, vlan->ifname) != 0)
+ 	vlan->configured = 1;
+ 
+ 	notempty = vlan->vlan_desc.notempty;
+@@ -506,6 +509,7 @@ void vlan_newlink(const char *ifname, st
+ 				    ifname, br_name, tagged[i], hapd);
+ 	}
+ 
++out:
+ 	ifconfig_up(ifname);
+ }
+ 
 --- a/hostapd/config_file.c
 +++ b/hostapd/config_file.c
-@@ -3400,6 +3400,8 @@ static int hostapd_config_fill(struct ho
+@@ -3381,6 +3381,8 @@ static int hostapd_config_fill(struct ho
  #ifndef CONFIG_NO_VLAN
  	} else if (os_strcmp(buf, "dynamic_vlan") == 0) {
  		bss->ssid.dynamic_vlan = atoi(pos);
diff --git a/package/network/services/hostapd/patches/711-wds_bridge_force.patch b/package/network/services/hostapd/patches/711-wds_bridge_force.patch
index 01507b6d36..a22580c357 100644
--- a/package/network/services/hostapd/patches/711-wds_bridge_force.patch
+++ b/package/network/services/hostapd/patches/711-wds_bridge_force.patch
@@ -1,6 +1,6 @@
 --- a/hostapd/config_file.c
 +++ b/hostapd/config_file.c
-@@ -2405,6 +2405,8 @@ static int hostapd_config_fill(struct ho
+@@ -2358,6 +2358,8 @@ static int hostapd_config_fill(struct ho
  			   sizeof(conf->bss[0]->iface));
  	} else if (os_strcmp(buf, "bridge") == 0) {
  		os_strlcpy(bss->bridge, pos, sizeof(bss->bridge));
diff --git a/package/network/services/hostapd/patches/720-iface_max_num_sta.patch b/package/network/services/hostapd/patches/720-iface_max_num_sta.patch
new file mode 100644
index 0000000000..106f9d7407
--- /dev/null
+++ b/package/network/services/hostapd/patches/720-iface_max_num_sta.patch
@@ -0,0 +1,82 @@
+--- a/hostapd/config_file.c
++++ b/hostapd/config_file.c
+@@ -2880,6 +2880,14 @@ static int hostapd_config_fill(struct ho
+ 				   line, bss->max_num_sta, MAX_STA_COUNT);
+ 			return 1;
+ 		}
++	} else if (os_strcmp(buf, "iface_max_num_sta") == 0) {
++		conf->max_num_sta = atoi(pos);
++		if (conf->max_num_sta < 0 ||
++		    conf->max_num_sta > MAX_STA_COUNT) {
++			wpa_printf(MSG_ERROR, "Line %d: Invalid max_num_sta=%d; allowed range 0..%d",
++				   line, conf->max_num_sta, MAX_STA_COUNT);
++			return 1;
++		}
+ 	} else if (os_strcmp(buf, "wpa") == 0) {
+ 		bss->wpa = atoi(pos);
+ 	} else if (os_strcmp(buf, "extended_key_id") == 0) {
+--- a/src/ap/hostapd.h
++++ b/src/ap/hostapd.h
+@@ -668,6 +668,7 @@ void hostapd_cleanup_cs_params(struct ho
+ void hostapd_periodic_iface(struct hostapd_iface *iface);
+ int hostapd_owe_trans_get_info(struct hostapd_data *hapd);
+ void hostapd_ocv_check_csa_sa_query(void *eloop_ctx, void *timeout_ctx);
++int hostapd_check_max_sta(struct hostapd_data *hapd);
+ 
+ /* utils.c */
+ int hostapd_register_probereq_cb(struct hostapd_data *hapd,
+--- a/src/ap/hostapd.c
++++ b/src/ap/hostapd.c
+@@ -236,6 +236,30 @@ static int hostapd_iface_conf_changed(st
+ }
+ 
+ 
++static inline int hostapd_iface_num_sta(struct hostapd_iface *iface)
++{
++	int num_sta = 0;
++	int i;
++
++	for (i = 0; i < iface->num_bss; i++)
++		num_sta += iface->bss[i]->num_sta;
++
++	return num_sta;
++}
++
++
++int hostapd_check_max_sta(struct hostapd_data *hapd)
++{
++	if (hapd->num_sta >= hapd->conf->max_num_sta)
++		return 1;
++
++	if (hapd->iconf->max_num_sta &&
++	    hostapd_iface_num_sta(hapd->iface) >= hapd->iconf->max_num_sta)
++		return 1;
++
++	return 0;
++}
++
+ int hostapd_reload_config(struct hostapd_iface *iface, int reconf)
+ {
+ 	struct hapd_interfaces *interfaces = iface->interfaces;
+--- a/src/ap/beacon.c
++++ b/src/ap/beacon.c
+@@ -1068,7 +1068,7 @@ void handle_probe_req(struct hostapd_dat
+ 	if (hapd->conf->no_probe_resp_if_max_sta &&
+ 	    is_multicast_ether_addr(mgmt->da) &&
+ 	    is_multicast_ether_addr(mgmt->bssid) &&
+-	    hapd->num_sta >= hapd->conf->max_num_sta &&
++	    hostapd_check_max_sta(hapd) &&
+ 	    !ap_get_sta(hapd, mgmt->sa)) {
+ 		wpa_printf(MSG_MSGDUMP, "%s: Ignore Probe Request from " MACSTR
+ 			   " since no room for additional STA",
+--- a/src/ap/ap_config.h
++++ b/src/ap/ap_config.h
+@@ -981,6 +981,8 @@ struct hostapd_config {
+ 	unsigned int track_sta_max_num;
+ 	unsigned int track_sta_max_age;
+ 
++	int max_num_sta;
++
+ 	char country[3]; /* first two octets: country code as described in
+ 			  * ISO/IEC 3166-1. Third octet:
+ 			  * ' ' (ascii 32): all environments
diff --git a/package/network/services/hostapd/patches/730-ft_iface.patch b/package/network/services/hostapd/patches/730-ft_iface.patch
index c1adf1ffcf..b5809222d7 100644
--- a/package/network/services/hostapd/patches/730-ft_iface.patch
+++ b/package/network/services/hostapd/patches/730-ft_iface.patch
@@ -1,6 +1,6 @@
 --- a/hostapd/config_file.c
 +++ b/hostapd/config_file.c
-@@ -3069,6 +3069,8 @@ static int hostapd_config_fill(struct ho
+@@ -3038,6 +3038,8 @@ static int hostapd_config_fill(struct ho
  		wpa_printf(MSG_INFO,
  			   "Line %d: Obsolete peerkey parameter ignored", line);
  #ifdef CONFIG_IEEE80211R_AP
@@ -11,7 +11,7 @@
  		    hexstr2bin(pos, bss->mobility_domain,
 --- a/src/ap/ap_config.h
 +++ b/src/ap/ap_config.h
-@@ -284,6 +284,7 @@ struct airtime_sta_weight {
+@@ -277,6 +277,7 @@ struct airtime_sta_weight {
  struct hostapd_bss_config {
  	char iface[IFNAMSIZ + 1];
  	char bridge[IFNAMSIZ + 1];
@@ -21,7 +21,7 @@
  
 --- a/src/ap/wpa_auth_glue.c
 +++ b/src/ap/wpa_auth_glue.c
-@@ -1511,8 +1511,12 @@ int hostapd_setup_wpa(struct hostapd_dat
+@@ -1566,8 +1566,12 @@ int hostapd_setup_wpa(struct hostapd_dat
  	    wpa_key_mgmt_ft(hapd->conf->wpa_key_mgmt)) {
  		const char *ft_iface;
  
diff --git a/package/network/services/hostapd/patches/740-snoop_iface.patch b/package/network/services/hostapd/patches/740-snoop_iface.patch
index 15aaf4b8e4..2ed73750ca 100644
--- a/package/network/services/hostapd/patches/740-snoop_iface.patch
+++ b/package/network/services/hostapd/patches/740-snoop_iface.patch
@@ -1,6 +1,6 @@
 --- a/src/ap/ap_config.h
 +++ b/src/ap/ap_config.h
-@@ -285,6 +285,7 @@ struct hostapd_bss_config {
+@@ -278,6 +278,7 @@ struct hostapd_bss_config {
  	char iface[IFNAMSIZ + 1];
  	char bridge[IFNAMSIZ + 1];
  	char ft_iface[IFNAMSIZ + 1];
@@ -55,7 +55,7 @@
  			   "x_snoop: Failed to initialize L2 packet processing %s",
 --- a/hostapd/config_file.c
 +++ b/hostapd/config_file.c
-@@ -2407,6 +2407,8 @@ static int hostapd_config_fill(struct ho
+@@ -2360,6 +2360,8 @@ static int hostapd_config_fill(struct ho
  		os_strlcpy(bss->bridge, pos, sizeof(bss->bridge));
  		if (!bss->wds_bridge[0])
  			os_strlcpy(bss->wds_bridge, pos, sizeof(bss->wds_bridge));
diff --git a/package/network/services/hostapd/patches/750-qos_map_set_without_interworking.patch b/package/network/services/hostapd/patches/750-qos_map_set_without_interworking.patch
index 94f4a2b297..43a4ea73b3 100644
--- a/package/network/services/hostapd/patches/750-qos_map_set_without_interworking.patch
+++ b/package/network/services/hostapd/patches/750-qos_map_set_without_interworking.patch
@@ -1,6 +1,6 @@
 --- a/hostapd/config_file.c
 +++ b/hostapd/config_file.c
-@@ -1711,6 +1711,8 @@ static int parse_anqp_elem(struct hostap
+@@ -1644,6 +1644,8 @@ static int parse_anqp_elem(struct hostap
  	return 0;
  }
  
@@ -9,7 +9,7 @@
  
  static int parse_qos_map_set(struct hostapd_bss_config *bss,
  			     char *buf, int line)
-@@ -1752,8 +1754,6 @@ static int parse_qos_map_set(struct host
+@@ -1685,8 +1687,6 @@ static int parse_qos_map_set(struct host
  	return 0;
  }
  
@@ -18,7 +18,7 @@
  
  #ifdef CONFIG_HS20
  static int hs20_parse_conn_capab(struct hostapd_bss_config *bss, char *buf,
-@@ -4050,10 +4050,10 @@ static int hostapd_config_fill(struct ho
+@@ -4077,10 +4077,10 @@ static int hostapd_config_fill(struct ho
  		bss->gas_frag_limit = val;
  	} else if (os_strcmp(buf, "gas_comeback_delay") == 0) {
  		bss->gas_comeback_delay = atoi(pos);
@@ -32,7 +32,7 @@
  		os_free(bss->dump_msk_file);
 --- a/src/ap/hostapd.c
 +++ b/src/ap/hostapd.c
-@@ -1386,6 +1386,7 @@ static int hostapd_setup_bss(struct host
+@@ -1415,6 +1415,7 @@ static int hostapd_setup_bss(struct host
  		wpa_printf(MSG_ERROR, "GAS server initialization failed");
  		return -1;
  	}
@@ -40,7 +40,7 @@
  
  	if (conf->qos_map_set_len &&
  	    hostapd_drv_set_qos_map(hapd, conf->qos_map_set,
-@@ -1393,7 +1394,6 @@ static int hostapd_setup_bss(struct host
+@@ -1422,7 +1423,6 @@ static int hostapd_setup_bss(struct host
  		wpa_printf(MSG_ERROR, "Failed to initialize QoS Map");
  		return -1;
  	}
@@ -50,7 +50,7 @@
  		wpa_printf(MSG_ERROR, "BSS Load initialization failed");
 --- a/src/ap/drv_callbacks.c
 +++ b/src/ap/drv_callbacks.c
-@@ -245,12 +245,10 @@ int hostapd_notif_assoc(struct hostapd_d
+@@ -271,12 +271,10 @@ int hostapd_notif_assoc(struct hostapd_d
  	}
  #endif /* NEED_AP_MLME */
  
@@ -65,7 +65,7 @@
  	wpabuf_free(sta->hs20_ie);
 --- a/src/ap/ieee802_11.c
 +++ b/src/ap/ieee802_11.c
-@@ -2875,13 +2875,11 @@ static u16 copy_supp_rates(struct hostap
+@@ -4129,13 +4129,11 @@ static u16 copy_supp_rates(struct hostap
  static u16 check_ext_capab(struct hostapd_data *hapd, struct sta_info *sta,
  			   const u8 *ext_capab_ie, size_t ext_capab_ie_len)
  {
@@ -81,7 +81,7 @@
  		sta->ecsa_supported = !!(ext_capab_ie[0] & BIT(2));
 --- a/wpa_supplicant/events.c
 +++ b/wpa_supplicant/events.c
-@@ -2500,8 +2500,6 @@ void wnm_bss_keep_alive_deinit(struct wp
+@@ -2540,8 +2540,6 @@ void wnm_bss_keep_alive_deinit(struct wp
  }
  
  
@@ -90,7 +90,7 @@
  static int wpas_qos_map_set(struct wpa_supplicant *wpa_s, const u8 *qos_map,
  			    size_t len)
  {
-@@ -2534,8 +2532,6 @@ static void interworking_process_assoc_r
+@@ -2574,8 +2572,6 @@ static void interworking_process_assoc_r
  	}
  }
  
@@ -99,7 +99,7 @@
  
  static void multi_ap_process_assoc_resp(struct wpa_supplicant *wpa_s,
  					const u8 *ies, size_t ies_len)
-@@ -2669,10 +2665,8 @@ static int wpa_supplicant_event_associnf
+@@ -2908,10 +2904,8 @@ static int wpa_supplicant_event_associnf
  		wnm_process_assoc_resp(wpa_s, data->assoc_info.resp_ies,
  				       data->assoc_info.resp_ies_len);
  #endif /* CONFIG_WNM */
diff --git a/package/network/services/hostapd/patches/751-qos_map_ignore_when_unsupported.patch b/package/network/services/hostapd/patches/751-qos_map_ignore_when_unsupported.patch
new file mode 100644
index 0000000000..8af5a0a046
--- /dev/null
+++ b/package/network/services/hostapd/patches/751-qos_map_ignore_when_unsupported.patch
@@ -0,0 +1,12 @@
+--- a/src/ap/ap_drv_ops.c
++++ b/src/ap/ap_drv_ops.c
+@@ -850,7 +850,8 @@ int hostapd_start_dfs_cac(struct hostapd
+ int hostapd_drv_set_qos_map(struct hostapd_data *hapd,
+ 			    const u8 *qos_map_set, u8 qos_map_set_len)
+ {
+-	if (!hapd->driver || !hapd->driver->set_qos_map || !hapd->drv_priv)
++	if (!hapd->driver || !hapd->driver->set_qos_map || !hapd->drv_priv ||
++	    !(hapd->iface->drv_flags & WPA_DRIVER_FLAGS_QOS_MAPPING))
+ 		return 0;
+ 	return hapd->driver->set_qos_map(hapd->drv_priv, qos_map_set,
+ 					 qos_map_set_len);
diff --git a/package/network/services/hostapd/patches/800-dfs-enter-DFS-state-if-no-available-channel-is-found.patch b/package/network/services/hostapd/patches/800-dfs-enter-DFS-state-if-no-available-channel-is-found.patch
deleted file mode 100644
index 3e4638d7ff..0000000000
--- a/package/network/services/hostapd/patches/800-dfs-enter-DFS-state-if-no-available-channel-is-found.patch
+++ /dev/null
@@ -1,37 +0,0 @@
-From cefc52e6b93731c713f1bba1cb5e7e92105b758b Mon Sep 17 00:00:00 2001
-From: David Bauer <mail@david-bauer.net>
-Date: Fri, 3 Jul 2020 23:00:34 +0200
-Subject: [PATCH] dfs: enter DFS state if no available channel is found
-
-Previously hostapd would not stop transmitting when a DFS event was
-detected and no available channel to switch to was available.
-
-Disable and re-enable the interface to enter DFS state. This way, TX
-does not happen until the kernel notifies hostapd about the NOP
-expiring.
-
-Signed-off-by: David Bauer <mail@david-bauer.net>
----
- src/ap/dfs.c | 11 +++++++++--
- 1 file changed, 9 insertions(+), 2 deletions(-)
-
---- a/src/ap/dfs.c
-+++ b/src/ap/dfs.c
-@@ -1086,8 +1086,15 @@ static int hostapd_dfs_start_channel_swi
- 						  &oper_centr_freq_seg0_idx,
- 						  &oper_centr_freq_seg1_idx,
- 						  &skip_radar);
--		if (!channel)
--			return err;
-+		if (!channel) {
-+			/*
-+			 * Toggle interface state to enter DFS state
-+			 * until NOP is finished.
-+			 */
-+			hostapd_disable_iface(iface);
-+			hostapd_enable_iface(iface);
-+			return 0;
-+		}
- 		if (!skip_radar) {
- 			iface->freq = channel->freq;
- 			iface->conf->channel = channel->chan;
diff --git a/package/network/services/hostapd/patches/801-P2P-Fix-copying-of-secondary-device-types-for-P2P-gr.patch b/package/network/services/hostapd/patches/801-P2P-Fix-copying-of-secondary-device-types-for-P2P-gr.patch
deleted file mode 100644
index 944f7d71c9..0000000000
--- a/package/network/services/hostapd/patches/801-P2P-Fix-copying-of-secondary-device-types-for-P2P-gr.patch
+++ /dev/null
@@ -1,33 +0,0 @@
-From 947272febe24a8f0ea828b5b2f35f13c3821901e Mon Sep 17 00:00:00 2001
-From: Jouni Malinen <jouni@codeaurora.org>
-Date: Mon, 9 Nov 2020 11:43:12 +0200
-Subject: [PATCH] P2P: Fix copying of secondary device types for P2P group
- client
-
-Parsing and copying of WPS secondary device types list was verifying
-that the contents is not too long for the internal maximum in the case
-of WPS messages, but similar validation was missing from the case of P2P
-group information which encodes this information in a different
-attribute. This could result in writing beyond the memory area assigned
-for these entries and corrupting memory within an instance of struct
-p2p_device. This could result in invalid operations and unexpected
-behavior when trying to free pointers from that corrupted memory.
-
-Credit to OSS-Fuzz: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=27269
-Fixes: e57ae6e19edf ("P2P: Keep track of secondary device types for peers")
-Signed-off-by: Jouni Malinen <jouni@codeaurora.org>
----
- src/p2p/p2p.c | 2 ++
- 1 file changed, 2 insertions(+)
-
---- a/src/p2p/p2p.c
-+++ b/src/p2p/p2p.c
-@@ -453,6 +453,8 @@ static void p2p_copy_client_info(struct
- 	dev->info.config_methods = cli->config_methods;
- 	os_memcpy(dev->info.pri_dev_type, cli->pri_dev_type, 8);
- 	dev->info.wps_sec_dev_type_list_len = 8 * cli->num_sec_dev_types;
-+	if (dev->info.wps_sec_dev_type_list_len > WPS_SEC_DEV_TYPE_MAX_LEN)
-+		dev->info.wps_sec_dev_type_list_len = WPS_SEC_DEV_TYPE_MAX_LEN;
- 	os_memcpy(dev->info.wps_sec_dev_type_list, cli->sec_dev_types,
- 		  dev->info.wps_sec_dev_type_list_len);
- }
diff --git a/package/network/services/hostapd/src/src/ap/ubus.c b/package/network/services/hostapd/src/src/ap/ubus.c
index 0575fe2572..fdc2a3fd26 100644
--- a/package/network/services/hostapd/src/src/ap/ubus.c
+++ b/package/network/services/hostapd/src/src/ap/ubus.c
@@ -11,6 +11,7 @@
 #include "utils/eloop.h"
 #include "utils/wpabuf.h"
 #include "common/ieee802_11_defs.h"
+#include "common/hw_features_common.h"
 #include "hostapd.h"
 #include "neighbor_db.h"
 #include "wps_hostapd.h"
@@ -21,6 +22,8 @@
 #include "rrm.h"
 #include "wnm_ap.h"
 #include "taxonomy.h"
+#include "airtime_policy.h"
+#include "hw_features.h"
 
 static struct ubus_context *ctx;
 static struct blob_buf b;
@@ -297,6 +300,7 @@ hostapd_bss_get_clients(struct ubus_context *ctx, struct ubus_object *obj,
 		{ "wmm", WLAN_STA_WMM },
 		{ "ht", WLAN_STA_HT },
 		{ "vht", WLAN_STA_VHT },
+		{ "he", WLAN_STA_HE },
 		{ "wps", WLAN_STA_WPS },
 		{ "mfp", WLAN_STA_MFP },
 	};
@@ -372,24 +376,81 @@ hostapd_bss_get_features(struct ubus_context *ctx, struct ubus_object *obj,
 	return 0;
 }
 
+/* Imported from iw/util.c
+ *  https://git.kernel.org/pub/scm/linux/kernel/git/jberg/iw.git/tree/util.c?id=4b25ae3537af48dbf9d0abf94132e5ba01b32c18#n200
+ */
+int ieee80211_frequency_to_channel(int freq)
+{
+	/* see 802.11-2007 17.3.8.3.2 and Annex J */
+	if (freq == 2484)
+		return 14;
+	/* see 802.11ax D6.1 27.3.23.2 and Annex E */
+	else if (freq == 5935)
+		return 2;
+	else if (freq < 2484)
+		return (freq - 2407) / 5;
+	else if (freq >= 4910 && freq <= 4980)
+		return (freq - 4000) / 5;
+	else if (freq < 5950)
+		return (freq - 5000) / 5;
+	else if (freq <= 45000) /* DMG band lower limit */
+		/* see 802.11ax D6.1 27.3.23.2 */
+		return (freq - 5950) / 5;
+	else if (freq >= 58320 && freq <= 70200)
+		return (freq - 56160) / 2160;
+	else
+		return 0;
+}
+
 static int
 hostapd_bss_get_status(struct ubus_context *ctx, struct ubus_object *obj,
 		       struct ubus_request_data *req, const char *method,
 		       struct blob_attr *msg)
 {
 	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
-	void *airtime_table, *dfs_table;
+	void *airtime_table, *dfs_table, *rrm_table, *wnm_table;
 	struct os_reltime now;
+	char ssid[SSID_MAX_LEN + 1];
 	char phy_name[17];
-	char mac_buf[20];
+	size_t ssid_len = SSID_MAX_LEN;
+	u8 channel = 0, op_class = 0;
+
+	if (hapd->conf->ssid.ssid_len < SSID_MAX_LEN)
+		ssid_len = hapd->conf->ssid.ssid_len;
+	
+	ieee80211_freq_to_channel_ext(hapd->iface->freq,
+				      hapd->iconf->secondary_channel,
+				      hostapd_get_oper_chwidth(hapd->iconf),
+				      &op_class, &channel);
 
 	blob_buf_init(&b, 0);
 	blobmsg_add_string(&b, "status", hostapd_state_text(hapd->iface->state));
+	blobmsg_printf(&b, "bssid", MACSTR, MAC2STR(hapd->conf->bssid));
+
+	memset(ssid, 0, SSID_MAX_LEN + 1);
+	memcpy(ssid, hapd->conf->ssid.ssid, ssid_len);
+	blobmsg_add_string(&b, "ssid", ssid);
+
 	blobmsg_add_u32(&b, "freq", hapd->iface->freq);
+	blobmsg_add_u32(&b, "channel", channel);
+	blobmsg_add_u32(&b, "op_class", op_class);
+	blobmsg_add_u32(&b, "beacon_interval", hapd->iconf->beacon_int);
 
 	snprintf(phy_name, 17, "%s", hapd->iface->phy);
 	blobmsg_add_string(&b, "phy", phy_name);
 
+	/* RRM */
+	rrm_table = blobmsg_open_table(&b, "rrm");
+	blobmsg_add_u64(&b, "neighbor_report_tx", hapd->openwrt_stats.rrm.neighbor_report_tx);
+	blobmsg_close_table(&b, rrm_table);
+
+	/* WNM */
+	wnm_table = blobmsg_open_table(&b, "wnm");
+	blobmsg_add_u64(&b, "bss_transition_query_rx", hapd->openwrt_stats.wnm.bss_transition_query_rx);
+	blobmsg_add_u64(&b, "bss_transition_request_tx", hapd->openwrt_stats.wnm.bss_transition_request_tx);
+	blobmsg_add_u64(&b, "bss_transition_response_rx", hapd->openwrt_stats.wnm.bss_transition_response_rx);
+	blobmsg_close_table(&b, wnm_table);
+
 	/* Airtime */
 	airtime_table = blobmsg_open_table(&b, "airtime");
 	blobmsg_add_u64(&b, "time", hapd->iface->last_channel_time);
@@ -703,7 +764,9 @@ enum {
 	CSA_SEC_CHANNEL_OFFSET,
 	CSA_HT,
 	CSA_VHT,
+	CSA_HE,
 	CSA_BLOCK_TX,
+	CSA_FORCE,
 	__CSA_MAX
 };
 
@@ -716,9 +779,20 @@ static const struct blobmsg_policy csa_policy[__CSA_MAX] = {
 	[CSA_SEC_CHANNEL_OFFSET] = { "sec_channel_offset", BLOBMSG_TYPE_INT32 },
 	[CSA_HT] = { "ht", BLOBMSG_TYPE_BOOL },
 	[CSA_VHT] = { "vht", BLOBMSG_TYPE_BOOL },
+	[CSA_HE] = { "he", BLOBMSG_TYPE_BOOL },
 	[CSA_BLOCK_TX] = { "block_tx", BLOBMSG_TYPE_BOOL },
+	[CSA_FORCE] = { "force", BLOBMSG_TYPE_BOOL },
 };
 
+
+static void switch_chan_fallback_cb(void *eloop_data, void *user_ctx)
+{
+	struct hostapd_iface *iface = eloop_data;
+	struct hostapd_freq_params *freq_params = user_ctx;
+
+	hostapd_switch_channel_fallback(iface, freq_params);
+}
+
 #ifdef NEED_AP_MLME
 static int
 hostapd_switch_chan(struct ubus_context *ctx, struct ubus_object *obj,
@@ -727,14 +801,42 @@ hostapd_switch_chan(struct ubus_context *ctx, struct ubus_object *obj,
 {
 	struct blob_attr *tb[__CSA_MAX];
 	struct hostapd_data *hapd = get_hapd_from_object(obj);
-	struct csa_settings css;
+	struct hostapd_config *iconf = hapd->iface->conf;
+	struct hostapd_freq_params *freq_params;
+	struct hostapd_hw_modes *mode = hapd->iface->current_mode;
+	struct csa_settings css = {
+		.freq_params = {
+			.ht_enabled = iconf->ieee80211n,
+			.vht_enabled = iconf->ieee80211ac,
+			.he_enabled = iconf->ieee80211ax,
+			.sec_channel_offset = iconf->secondary_channel,
+		}
+	};
+	u8 chwidth = hostapd_get_oper_chwidth(iconf);
+	u8 seg0 = 0, seg1 = 0;
+	int ret = UBUS_STATUS_OK;
+	int i;
 
 	blobmsg_parse(csa_policy, __CSA_MAX, tb, blob_data(msg), blob_len(msg));
 
 	if (!tb[CSA_FREQ])
 		return UBUS_STATUS_INVALID_ARGUMENT;
 
-	memset(&css, 0, sizeof(css));
+	switch (iconf->vht_oper_chwidth) {
+	case CHANWIDTH_USE_HT:
+		if (iconf->secondary_channel)
+			css.freq_params.bandwidth = 40;
+		else
+			css.freq_params.bandwidth = 20;
+		break;
+	case CHANWIDTH_160MHZ:
+		css.freq_params.bandwidth = 160;
+		break;
+	default:
+		css.freq_params.bandwidth = 80;
+		break;
+	}
+
 	css.freq_params.freq = blobmsg_get_u32(tb[CSA_FREQ]);
 
 #define SET_CSA_SETTING(name, field, type) \
@@ -750,12 +852,54 @@ hostapd_switch_chan(struct ubus_context *ctx, struct ubus_object *obj,
 	SET_CSA_SETTING(CSA_SEC_CHANNEL_OFFSET, freq_params.sec_channel_offset, u32);
 	SET_CSA_SETTING(CSA_HT, freq_params.ht_enabled, bool);
 	SET_CSA_SETTING(CSA_VHT, freq_params.vht_enabled, bool);
+	SET_CSA_SETTING(CSA_HE, freq_params.he_enabled, bool);
 	SET_CSA_SETTING(CSA_BLOCK_TX, block_tx, bool);
 
-
-	if (hostapd_switch_channel(hapd, &css) != 0)
+	css.freq_params.channel = hostapd_hw_get_channel(hapd, css.freq_params.freq);
+	if (!css.freq_params.channel)
 		return UBUS_STATUS_NOT_SUPPORTED;
-	return UBUS_STATUS_OK;
+
+	switch (css.freq_params.bandwidth) {
+	case 160:
+		chwidth = CHANWIDTH_160MHZ;
+		break;
+	case 80:
+		chwidth = css.freq_params.center_freq2 ? CHANWIDTH_80P80MHZ : CHANWIDTH_80MHZ;
+		break;
+	default:
+		chwidth = CHANWIDTH_USE_HT;
+		break;
+	}
+
+	hostapd_set_freq_params(&css.freq_params, iconf->hw_mode,
+				css.freq_params.freq,
+				css.freq_params.channel, iconf->enable_edmg,
+				iconf->edmg_channel,
+				css.freq_params.ht_enabled,
+				css.freq_params.vht_enabled,
+				css.freq_params.he_enabled,
+				css.freq_params.sec_channel_offset,
+				chwidth, seg0, seg1,
+				iconf->vht_capab,
+				mode ? &mode->he_capab[IEEE80211_MODE_AP] :
+				NULL);
+
+	for (i = 0; i < hapd->iface->num_bss; i++) {
+		struct hostapd_data *bss = hapd->iface->bss[i];
+
+		if (hostapd_switch_channel(bss, &css) != 0)
+			ret = UBUS_STATUS_NOT_SUPPORTED;
+	}
+
+	if (!ret || !tb[CSA_FORCE] || !blobmsg_get_bool(tb[CSA_FORCE]))
+		return ret;
+
+	freq_params = malloc(sizeof(*freq_params));
+	memcpy(freq_params, &css.freq_params, sizeof(*freq_params));
+	eloop_register_timeout(0, 1, switch_chan_fallback_cb,
+			       hapd->iface, freq_params);
+
+	return 0;
 #undef SET_CSA_SETTING
 }
 #endif
@@ -1085,7 +1229,7 @@ hostapd_rrm_nr_set(struct ubus_context *ctx, struct ubus_object *obj,
 			memcpy(&ssid, s, ssid.ssid_len);
 		}
 
-		hostapd_neighbor_set(hapd, bssid, &ssid, data, NULL, NULL, 0);
+		hostapd_neighbor_set(hapd, bssid, &ssid, data, NULL, NULL, 0, 0);
 		wpabuf_free(data);
 		continue;
 
@@ -1185,60 +1329,31 @@ hostapd_rrm_beacon_req(struct ubus_context *ctx, struct ubus_object *obj,
 
 
 #ifdef CONFIG_WNM_AP
-enum {
-	WNM_DISASSOC_ADDR,
-	WNM_DISASSOC_DURATION,
-	WNM_DISASSOC_NEIGHBORS,
-	WNM_DISASSOC_ABRIDGED,
-	__WNM_DISASSOC_MAX,
-};
-
-static const struct blobmsg_policy wnm_disassoc_policy[__WNM_DISASSOC_MAX] = {
-	[WNM_DISASSOC_ADDR] = { "addr", BLOBMSG_TYPE_STRING },
-	[WNM_DISASSOC_DURATION] { "duration", BLOBMSG_TYPE_INT32 },
-	[WNM_DISASSOC_NEIGHBORS] { "neighbors", BLOBMSG_TYPE_ARRAY },
-	[WNM_DISASSOC_ABRIDGED] { "abridged", BLOBMSG_TYPE_BOOL },
-};
 
 static int
-hostapd_wnm_disassoc_imminent(struct ubus_context *ctx, struct ubus_object *obj,
-			      struct ubus_request_data *ureq, const char *method,
-			      struct blob_attr *msg)
+hostapd_bss_tr_send(struct hostapd_data *hapd, u8 *addr, bool disassoc_imminent, bool abridged,
+		    u16 disassoc_timer, u8 validity_period, u8 dialog_token,
+		    struct blob_attr *neighbors)
 {
-	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
-	struct blob_attr *tb[__WNM_DISASSOC_MAX];
 	struct blob_attr *cur;
 	struct sta_info *sta;
-	int duration = 10;
-	int rem;
 	int nr_len = 0;
+	int rem;
 	u8 *nr = NULL;
-	u8 req_mode = WNM_BSS_TM_REQ_DISASSOC_IMMINENT;
-	u8 addr[ETH_ALEN];
-
-	blobmsg_parse(wnm_disassoc_policy, __WNM_DISASSOC_MAX, tb, blob_data(msg), blob_len(msg));
-
-	if (!tb[WNM_DISASSOC_ADDR])
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	if (hwaddr_aton(blobmsg_data(tb[WNM_DISASSOC_ADDR]), addr))
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	if ((cur = tb[WNM_DISASSOC_DURATION]) != NULL)
-		duration = blobmsg_get_u32(cur);
+	u8 req_mode = 0;
 
 	sta = ap_get_sta(hapd, addr);
 	if (!sta)
 		return UBUS_STATUS_NOT_FOUND;
 
-	if (tb[WNM_DISASSOC_NEIGHBORS]) {
+	if (neighbors) {
 		u8 *nr_cur;
 
-		if (blobmsg_check_array(tb[WNM_DISASSOC_NEIGHBORS],
+		if (blobmsg_check_array(neighbors,
 					BLOBMSG_TYPE_STRING) < 0)
 			return UBUS_STATUS_INVALID_ARGUMENT;
 
-		blobmsg_for_each_attr(cur, tb[WNM_DISASSOC_NEIGHBORS], rem) {
+		blobmsg_for_each_attr(cur, neighbors, rem) {
 			int len = strlen(blobmsg_get_string(cur));
 
 			if (len % 2)
@@ -1254,7 +1369,7 @@ hostapd_wnm_disassoc_imminent(struct ubus_context *ctx, struct ubus_object *obj,
 		}
 
 		nr_cur = nr;
-		blobmsg_for_each_attr(cur, tb[WNM_DISASSOC_NEIGHBORS], rem) {
+		blobmsg_for_each_attr(cur, neighbors, rem) {
 			int len = strlen(blobmsg_get_string(cur)) / 2;
 
 			*nr_cur++ = WLAN_EID_NEIGHBOR_REPORT;
@@ -1271,22 +1386,186 @@ hostapd_wnm_disassoc_imminent(struct ubus_context *ctx, struct ubus_object *obj,
 	if (nr)
 		req_mode |= WNM_BSS_TM_REQ_PREF_CAND_LIST_INCLUDED;
 
-	if (tb[WNM_DISASSOC_ABRIDGED] && blobmsg_get_bool(tb[WNM_DISASSOC_ABRIDGED]))
+	if (abridged)
 		req_mode |= WNM_BSS_TM_REQ_ABRIDGED;
 
-	if (wnm_send_bss_tm_req(hapd, sta, req_mode, duration, duration, NULL,
-				NULL, nr, nr_len, NULL, 0))
+	if (disassoc_imminent)
+		req_mode |= WNM_BSS_TM_REQ_DISASSOC_IMMINENT;
+
+	if (wnm_send_bss_tm_req(hapd, sta, req_mode, disassoc_timer, validity_period, NULL,
+				dialog_token, NULL, nr, nr_len, NULL, 0))
 		return UBUS_STATUS_UNKNOWN_ERROR;
 
 	return 0;
 }
+
+enum {
+	BSS_TR_ADDR,
+	BSS_TR_DA_IMMINENT,
+	BSS_TR_DA_TIMER,
+	BSS_TR_VALID_PERIOD,
+	BSS_TR_NEIGHBORS,
+	BSS_TR_ABRIDGED,
+	BSS_TR_DIALOG_TOKEN,
+	__BSS_TR_DISASSOC_MAX
+};
+
+static const struct blobmsg_policy bss_tr_policy[__BSS_TR_DISASSOC_MAX] = {
+	[BSS_TR_ADDR] = { "addr", BLOBMSG_TYPE_STRING },
+	[BSS_TR_DA_IMMINENT] = { "disassociation_imminent", BLOBMSG_TYPE_BOOL },
+	[BSS_TR_DA_TIMER] = { "disassociation_timer", BLOBMSG_TYPE_INT32 },
+	[BSS_TR_VALID_PERIOD] = { "validity_period", BLOBMSG_TYPE_INT32 },
+	[BSS_TR_NEIGHBORS] = { "neighbors", BLOBMSG_TYPE_ARRAY },
+	[BSS_TR_ABRIDGED] = { "abridged", BLOBMSG_TYPE_BOOL },
+	[BSS_TR_DIALOG_TOKEN] = { "dialog_token", BLOBMSG_TYPE_INT32 },
+};
+
+static int
+hostapd_bss_transition_request(struct ubus_context *ctx, struct ubus_object *obj,
+			       struct ubus_request_data *ureq, const char *method,
+			       struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+	struct blob_attr *tb[__BSS_TR_DISASSOC_MAX];
+	struct sta_info *sta;
+	u32 da_timer = 0;
+	u32 valid_period = 0;
+	u8 addr[ETH_ALEN];
+	u32 dialog_token = 1;
+	bool abridged;
+	bool da_imminent;
+
+	blobmsg_parse(bss_tr_policy, __BSS_TR_DISASSOC_MAX, tb, blob_data(msg), blob_len(msg));
+
+	if (!tb[BSS_TR_ADDR])
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	if (hwaddr_aton(blobmsg_data(tb[BSS_TR_ADDR]), addr))
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	if (tb[BSS_TR_DA_TIMER])
+		da_timer = blobmsg_get_u32(tb[BSS_TR_DA_TIMER]);
+
+	if (tb[BSS_TR_VALID_PERIOD])
+		valid_period = blobmsg_get_u32(tb[BSS_TR_VALID_PERIOD]);
+
+	if (tb[BSS_TR_DIALOG_TOKEN])
+		dialog_token = blobmsg_get_u32(tb[BSS_TR_DIALOG_TOKEN]);
+
+	da_imminent = !!(tb[BSS_TR_DA_IMMINENT] && blobmsg_get_bool(tb[BSS_TR_DA_IMMINENT]));
+	abridged = !!(tb[BSS_TR_ABRIDGED] && blobmsg_get_bool(tb[BSS_TR_ABRIDGED]));
+
+	return hostapd_bss_tr_send(hapd, addr, da_imminent, abridged, da_timer, valid_period,
+				   dialog_token, tb[BSS_TR_NEIGHBORS]);
+}
+
+enum {
+	WNM_DISASSOC_ADDR,
+	WNM_DISASSOC_DURATION,
+	WNM_DISASSOC_NEIGHBORS,
+	WNM_DISASSOC_ABRIDGED,
+	__WNM_DISASSOC_MAX,
+};
+
+static const struct blobmsg_policy wnm_disassoc_policy[__WNM_DISASSOC_MAX] = {
+	[WNM_DISASSOC_ADDR] = { "addr", BLOBMSG_TYPE_STRING },
+	[WNM_DISASSOC_DURATION] { "duration", BLOBMSG_TYPE_INT32 },
+	[WNM_DISASSOC_NEIGHBORS] { "neighbors", BLOBMSG_TYPE_ARRAY },
+	[WNM_DISASSOC_ABRIDGED] { "abridged", BLOBMSG_TYPE_BOOL },
+};
+
+static int
+hostapd_wnm_disassoc_imminent(struct ubus_context *ctx, struct ubus_object *obj,
+			      struct ubus_request_data *ureq, const char *method,
+			      struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+	struct blob_attr *tb[__WNM_DISASSOC_MAX];
+	struct sta_info *sta;
+	int duration = 10;
+	u8 addr[ETH_ALEN];
+	bool abridged;
+
+	blobmsg_parse(wnm_disassoc_policy, __WNM_DISASSOC_MAX, tb, blob_data(msg), blob_len(msg));
+
+	if (!tb[WNM_DISASSOC_ADDR])
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	if (hwaddr_aton(blobmsg_data(tb[WNM_DISASSOC_ADDR]), addr))
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	if (tb[WNM_DISASSOC_DURATION])
+		duration = blobmsg_get_u32(tb[WNM_DISASSOC_DURATION]);
+
+	abridged = !!(tb[WNM_DISASSOC_ABRIDGED] && blobmsg_get_bool(tb[WNM_DISASSOC_ABRIDGED]));
+
+	return hostapd_bss_tr_send(hapd, addr, true, abridged, duration, duration,
+				   1, tb[WNM_DISASSOC_NEIGHBORS]);
+}
+#endif
+
+#ifdef CONFIG_AIRTIME_POLICY
+enum {
+	UPDATE_AIRTIME_STA,
+	UPDATE_AIRTIME_WEIGHT,
+	__UPDATE_AIRTIME_MAX,
+};
+
+
+static const struct blobmsg_policy airtime_policy[__UPDATE_AIRTIME_MAX] = {
+	[UPDATE_AIRTIME_STA] = { "sta", BLOBMSG_TYPE_STRING },
+	[UPDATE_AIRTIME_WEIGHT] = { "weight", BLOBMSG_TYPE_INT32 },
+};
+
+static int
+hostapd_bss_update_airtime(struct ubus_context *ctx, struct ubus_object *obj,
+			   struct ubus_request_data *ureq, const char *method,
+			   struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+	struct blob_attr *tb[__UPDATE_AIRTIME_MAX];
+	struct sta_info *sta = NULL;
+	u8 addr[ETH_ALEN];
+	int weight;
+
+	blobmsg_parse(airtime_policy, __UPDATE_AIRTIME_MAX, tb, blob_data(msg), blob_len(msg));
+
+	if (!tb[UPDATE_AIRTIME_WEIGHT])
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	weight = blobmsg_get_u32(tb[UPDATE_AIRTIME_WEIGHT]);
+
+	if (!tb[UPDATE_AIRTIME_STA]) {
+		if (!weight)
+			return UBUS_STATUS_INVALID_ARGUMENT;
+
+		hapd->conf->airtime_weight = weight;
+		return 0;
+	}
+
+	if (hwaddr_aton(blobmsg_data(tb[UPDATE_AIRTIME_STA]), addr))
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	sta = ap_get_sta(hapd, addr);
+	if (!sta)
+		return UBUS_STATUS_NOT_FOUND;
+
+	sta->dyn_airtime_weight = weight;
+	airtime_policy_new_sta(hapd, sta);
+
+	return 0;
+}
 #endif
 
+
 static const struct ubus_method bss_methods[] = {
 	UBUS_METHOD_NOARG("reload", hostapd_bss_reload),
 	UBUS_METHOD_NOARG("get_clients", hostapd_bss_get_clients),
 	UBUS_METHOD_NOARG("get_status", hostapd_bss_get_status),
 	UBUS_METHOD("del_client", hostapd_bss_del_client, del_policy),
+#ifdef CONFIG_AIRTIME_POLICY
+	UBUS_METHOD("update_airtime", hostapd_bss_update_airtime, airtime_policy),
+#endif
 	UBUS_METHOD_NOARG("list_bans", hostapd_bss_list_bans),
 #ifdef CONFIG_WPS
 	UBUS_METHOD_NOARG("wps_start", hostapd_bss_wps_start),
@@ -1307,6 +1586,7 @@ static const struct ubus_method bss_methods[] = {
 	UBUS_METHOD("rrm_beacon_req", hostapd_rrm_beacon_req, beacon_req_policy),
 #ifdef CONFIG_WNM_AP
 	UBUS_METHOD("wnm_disassoc_imminent", hostapd_wnm_disassoc_imminent, wnm_disassoc_policy),
+	UBUS_METHOD("bss_transition_request", hostapd_bss_transition_request, bss_tr_policy),
 #endif
 };
 
@@ -1369,6 +1649,43 @@ void hostapd_ubus_free_bss(struct hostapd_data *hapd)
 	free(name);
 }
 
+static void
+hostapd_ubus_vlan_action(struct hostapd_data *hapd, struct hostapd_vlan *vlan,
+			 const char *action)
+{
+	struct vlan_description *desc = &vlan->vlan_desc;
+	void *c;
+	int i;
+
+	if (!hapd->ubus.obj.has_subscribers)
+		return;
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_string(&b, "ifname", vlan->ifname);
+	blobmsg_add_string(&b, "bridge", vlan->bridge);
+	blobmsg_add_u32(&b, "vlan_id", vlan->vlan_id);
+
+	if (desc->notempty) {
+		blobmsg_add_u32(&b, "untagged", desc->untagged);
+		c = blobmsg_open_array(&b, "tagged");
+		for (i = 0; i < ARRAY_SIZE(desc->tagged) && desc->tagged[i]; i++)
+			blobmsg_add_u32(&b, "", desc->tagged[i]);
+		blobmsg_close_array(&b, c);
+	}
+
+	ubus_notify(ctx, &hapd->ubus.obj, action, b.head, -1);
+}
+
+void hostapd_ubus_add_vlan(struct hostapd_data *hapd, struct hostapd_vlan *vlan)
+{
+	hostapd_ubus_vlan_action(hapd, vlan, "vlan_add");
+}
+
+void hostapd_ubus_remove_vlan(struct hostapd_data *hapd, struct hostapd_vlan *vlan)
+{
+	hostapd_ubus_vlan_action(hapd, vlan, "vlan_remove");
+}
+
 static const struct ubus_method daemon_methods[] = {
 	UBUS_METHOD("config_add", hostapd_config_add, config_add_policy),
 	UBUS_METHOD("config_remove", hostapd_config_remove, config_remove_policy),
@@ -1555,3 +1872,103 @@ void hostapd_ubus_notify_beacon_report(
 
 	ubus_notify(ctx, &hapd->ubus.obj, "beacon-report", b.head, -1);
 }
+
+void hostapd_ubus_notify_radar_detected(struct hostapd_iface *iface, int frequency,
+					int chan_width, int cf1, int cf2)
+{
+	struct hostapd_data *hapd;
+	int i;
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_u16(&b, "frequency", frequency);
+	blobmsg_add_u16(&b, "width", chan_width);
+	blobmsg_add_u16(&b, "center1", cf1);
+	blobmsg_add_u16(&b, "center2", cf2);
+
+	for (i = 0; i < iface->num_bss; i++) {
+		hapd = iface->bss[i];
+		ubus_notify(ctx, &hapd->ubus.obj, "radar-detected", b.head, -1);
+	}
+}
+
+#ifdef CONFIG_WNM_AP
+static void hostapd_ubus_notify_bss_transition_add_candidate_list(
+	const u8 *candidate_list, u16 candidate_list_len)
+{
+	char *cl_str;
+	int i;
+
+	if (candidate_list_len == 0)
+		return;
+
+	cl_str = blobmsg_alloc_string_buffer(&b, "candidate-list", candidate_list_len * 2 + 1);
+	for (i = 0; i < candidate_list_len; i++)
+		snprintf(&cl_str[i*2], 3, "%02X", candidate_list[i]);
+	blobmsg_add_string_buffer(&b);
+
+}
+#endif
+
+void hostapd_ubus_notify_bss_transition_response(
+	struct hostapd_data *hapd, const u8 *addr, u8 dialog_token, u8 status_code,
+	u8 bss_termination_delay, const u8 *target_bssid,
+	const u8 *candidate_list, u16 candidate_list_len)
+{
+#ifdef CONFIG_WNM_AP
+	u16 i;
+
+	if (!hapd->ubus.obj.has_subscribers)
+		return;
+
+	if (!addr)
+		return;
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_macaddr(&b, "address", addr);
+	blobmsg_add_u8(&b, "dialog-token", dialog_token);
+	blobmsg_add_u8(&b, "status-code", status_code);
+	blobmsg_add_u8(&b, "bss-termination-delay", bss_termination_delay);
+	if (target_bssid)
+		blobmsg_add_macaddr(&b, "target-bssid", target_bssid);
+	
+	hostapd_ubus_notify_bss_transition_add_candidate_list(candidate_list, candidate_list_len);
+
+	ubus_notify(ctx, &hapd->ubus.obj, "bss-transition-response", b.head, -1);
+#endif
+}
+
+int hostapd_ubus_notify_bss_transition_query(
+	struct hostapd_data *hapd, const u8 *addr, u8 dialog_token, u8 reason,
+	const u8 *candidate_list, u16 candidate_list_len)
+{
+#ifdef CONFIG_WNM_AP
+	struct ubus_event_req ureq = {};
+	char *cl_str;
+	u16 i;
+
+	if (!hapd->ubus.obj.has_subscribers)
+		return 0;
+
+	if (!addr)
+		return 0;
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_macaddr(&b, "address", addr);
+	blobmsg_add_u8(&b, "dialog-token", dialog_token);
+	blobmsg_add_u8(&b, "reason", reason);
+	hostapd_ubus_notify_bss_transition_add_candidate_list(candidate_list, candidate_list_len);
+
+	if (!hapd->ubus.notify_response) {
+		ubus_notify(ctx, &hapd->ubus.obj, "bss-transition-query", b.head, -1);
+		return 0;
+	}
+
+	if (ubus_notify_async(ctx, &hapd->ubus.obj, "bss-transition-query", b.head, &ureq.nreq))
+		return 0;
+
+	ureq.nreq.status_cb = ubus_event_cb;
+	ubus_complete_request(ctx, &ureq.nreq.req, 100);
+
+	return ureq.resp;
+#endif
+}
diff --git a/package/network/services/hostapd/src/src/ap/ubus.h b/package/network/services/hostapd/src/src/ap/ubus.h
index e16017394f..f1bc093e57 100644
--- a/package/network/services/hostapd/src/src/ap/ubus.h
+++ b/package/network/services/hostapd/src/src/ap/ubus.h
@@ -43,6 +43,8 @@ void hostapd_ubus_add_iface(struct hostapd_iface *iface);
 void hostapd_ubus_free_iface(struct hostapd_iface *iface);
 void hostapd_ubus_add_bss(struct hostapd_data *hapd);
 void hostapd_ubus_free_bss(struct hostapd_data *hapd);
+void hostapd_ubus_add_vlan(struct hostapd_data *hapd, struct hostapd_vlan *vlan);
+void hostapd_ubus_remove_vlan(struct hostapd_data *hapd, struct hostapd_vlan *vlan);
 
 int hostapd_ubus_handle_event(struct hostapd_data *hapd, struct hostapd_ubus_request *req);
 void hostapd_ubus_notify(struct hostapd_data *hapd, const char *type, const u8 *mac);
@@ -50,9 +52,18 @@ void hostapd_ubus_notify_beacon_report(struct hostapd_data *hapd,
 				       const u8 *addr, u8 token, u8 rep_mode,
 				       struct rrm_measurement_beacon_report *rep,
 				       size_t len);
+void hostapd_ubus_notify_radar_detected(struct hostapd_iface *iface, int frequency,
+					int chan_width, int cf1, int cf2);
 
+void hostapd_ubus_notify_bss_transition_response(
+	struct hostapd_data *hapd, const u8 *addr, u8 dialog_token, u8 status_code,
+	u8 bss_termination_delay, const u8 *target_bssid,
+	const u8 *candidate_list, u16 candidate_list_len);
 void hostapd_ubus_add(struct hapd_interfaces *interfaces);
 void hostapd_ubus_free(struct hapd_interfaces *interfaces);
+int hostapd_ubus_notify_bss_transition_query(
+	struct hostapd_data *hapd, const u8 *addr, u8 dialog_token, u8 reason,
+	const u8 *candidate_list, u16 candidate_list_len);
 
 #else
 
@@ -74,6 +85,14 @@ static inline void hostapd_ubus_free_bss(struct hostapd_data *hapd)
 {
 }
 
+static inline void hostapd_ubus_add_vlan(struct hostapd_data *hapd, struct hostapd_vlan *vlan)
+{
+}
+
+static inline void hostapd_ubus_remove_vlan(struct hostapd_data *hapd, struct hostapd_vlan *vlan)
+{
+}
+
 static inline int hostapd_ubus_handle_event(struct hostapd_data *hapd, struct hostapd_ubus_request *req)
 {
 	return 0;
@@ -90,6 +109,17 @@ static inline void hostapd_ubus_notify_beacon_report(struct hostapd_data *hapd,
 						     size_t len)
 {
 }
+static inline void hostapd_ubus_notify_radar_detected(struct hostapd_iface *iface, int frequency,
+						      int chan_width, int cf1, int cf2)
+{
+}
+
+static inline void hostapd_ubus_notify_bss_transition_response(
+	struct hostapd_data *hapd, const u8 *addr, u8 dialog_token, u8 status_code,
+	u8 bss_termination_delay, const u8 *target_bssid,
+	const u8 *candidate_list, u16 candidate_list_len)
+{
+}
 
 static inline void hostapd_ubus_add(struct hapd_interfaces *interfaces)
 {
@@ -98,6 +128,13 @@ static inline void hostapd_ubus_add(struct hapd_interfaces *interfaces)
 static inline void hostapd_ubus_free(struct hapd_interfaces *interfaces)
 {
 }
+
+static inline int hostapd_ubus_notify_bss_transition_query(
+	struct hostapd_data *hapd, const u8 *addr, u8 dialog_token, u8 reason,
+	const u8 *candidate_list, u16 candidate_list_len)
+{
+	return 0;
+}
 #endif
 
 #endif
diff --git a/package/network/services/hostapd/src/src/utils/build_features.h b/package/network/services/hostapd/src/src/utils/build_features.h
index c7fccad413..cb7cb72731 100644
--- a/package/network/services/hostapd/src/src/utils/build_features.h
+++ b/package/network/services/hostapd/src/src/utils/build_features.h
@@ -23,8 +23,6 @@ static inline int has_feature(const char *feat)
 	if (!strcmp(feat, "11r"))
 		return 1;
 #endif
-	if (!strcmp(feat, "11w"))
-		return 1;
 #ifdef CONFIG_ACS
 	if (!strcmp(feat, "acs"))
 		return 1;
@@ -52,6 +50,10 @@ static inline int has_feature(const char *feat)
 #ifdef CONFIG_WPS
 	if (!strcmp(feat, "wps"))
 		return 1;
+#endif
+#ifdef CONFIG_FILS
+	if (!strcmp(feat, "fils"))
+		return 1;
 #endif
 	return 0;
 }
-- 
2.25.1

