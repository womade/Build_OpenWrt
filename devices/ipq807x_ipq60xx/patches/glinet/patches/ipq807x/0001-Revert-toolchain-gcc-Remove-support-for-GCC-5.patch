From 2947f1c2ac5e300d209b952979da30e92330a01f Mon Sep 17 00:00:00 2001
From: John Crispin <john@phrozen.org>
Date: Mon, 25 Jan 2021 06:40:20 +0100
Subject: [PATCH 02/43] Revert "toolchain: gcc: Remove support for GCC 5"

This reverts commit 080dc619d4780a1f7b14082b77b28686e694f72d.
---
 toolchain/gcc/Config.in                       |    5 +
 toolchain/gcc/Config.version                  |    7 +-
 toolchain/gcc/common.mk                       |    4 +
 .../001-revert_register_mode_search.patch     |   65 +
 .../patches/5.5.0/002-case_insensitive.patch  |   14 +
 .../gcc/patches/5.5.0/010-documentation.patch |   23 +
 .../patches/5.5.0/020-no-plt-backport.patch   |   28 +
 .../5.5.0/040-fix-mips-ICE-PR-68400.patch     |   23 +
 ...efine-__always_inline-in-local_atomi.patch | 1092 +++++++++++++++++
 .../gcc/patches/5.5.0/200-musl_config.patch   |  309 +++++
 .../gcc/patches/5.5.0/201-musl_arm.patch      |   43 +
 .../gcc/patches/5.5.0/202-musl_mips.patch     |   35 +
 .../gcc/patches/5.5.0/203-musl_powerpc.patch  |  209 ++++
 toolchain/gcc/patches/5.5.0/204-musl_sh.patch |   39 +
 .../gcc/patches/5.5.0/205-musl_x86.patch      |   41 +
 .../gcc/patches/5.5.0/206-musl_aarch64.patch  |   31 +
 .../patches/5.5.0/207-musl_fixincludes.patch  |   30 +
 .../patches/5.5.0/209-musl_libstdc++.patch    |   72 ++
 .../gcc/patches/5.5.0/230-musl_libssp.patch   |   13 +
 .../patches/5.5.0/240-musl-libitm-fixes.patch |   61 +
 .../gcc/patches/5.5.0/250-add-musl.patch      |  120 ++
 .../5.5.0/260-musl-add-unwind-fix.patch       |   34 +
 .../270-musl-add-powerpc-softfloat-fix.patch  |   24 +
 .../280-musl-disable-ifunc-by-default.patch   |   36 +
 .../300-mips_Os_cpu_rtx_cost_model.patch      |   14 +
 .../5.5.0/800-arm_v5te_no_ldrd_strd.patch     |   11 +
 .../5.5.0/810-arm-softfloat-libgcc.patch      |   25 +
 .../gcc/patches/5.5.0/820-libgcc_pic.patch    |   36 +
 .../5.5.0/830-arm_unbreak_armv4t.patch        |   13 +
 .../5.5.0/840-armv4_pass_fix-v4bx_to_ld.patch |   19 +
 .../patches/5.5.0/850-use_shared_libgcc.patch |   47 +
 .../patches/5.5.0/851-libgcc_no_compat.patch  |   12 +
 .../patches/5.5.0/870-ppc_no_crtsavres.patch  |   11 +
 .../patches/5.5.0/880-no_java_section.patch   |   11 +
 .../gcc/patches/5.5.0/881-no_tm_section.patch |   11 +
 .../patches/5.5.0/900-bad-mips16-crt.patch    |    9 +
 .../gcc/patches/5.5.0/910-mbsd_multi.patch    |  222 ++++
 .../5.5.0/920-specs_nonfatal_getenv.patch     |   15 +
 .../5.5.0/930-fix-mips-noexecstack.patch      |  111 ++
 .../931-fix-MIPS-softfloat-build-issue.patch  |  167 +++
 .../5.5.0/940-no-clobber-stamp-bits.patch     |   11 +
 .../5.5.0/950-cpp_file_path_translation.patch |  182 +++
 toolchain/gcc/patches/5.5.0/960-go_libm.patch |   11 +
 .../gcc/patches/5.5.0/970-warn_bug.patch      |   11 +
 44 files changed, 3306 insertions(+), 1 deletion(-)
 create mode 100644 toolchain/gcc/patches/5.5.0/001-revert_register_mode_search.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/002-case_insensitive.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/010-documentation.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/020-no-plt-backport.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/040-fix-mips-ICE-PR-68400.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/050-libitm-Don-t-redefine-__always_inline-in-local_atomi.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/200-musl_config.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/201-musl_arm.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/202-musl_mips.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/203-musl_powerpc.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/204-musl_sh.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/205-musl_x86.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/206-musl_aarch64.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/207-musl_fixincludes.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/209-musl_libstdc++.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/230-musl_libssp.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/240-musl-libitm-fixes.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/250-add-musl.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/260-musl-add-unwind-fix.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/270-musl-add-powerpc-softfloat-fix.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/280-musl-disable-ifunc-by-default.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/300-mips_Os_cpu_rtx_cost_model.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/800-arm_v5te_no_ldrd_strd.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/810-arm-softfloat-libgcc.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/820-libgcc_pic.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/830-arm_unbreak_armv4t.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/840-armv4_pass_fix-v4bx_to_ld.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/850-use_shared_libgcc.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/851-libgcc_no_compat.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/870-ppc_no_crtsavres.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/880-no_java_section.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/881-no_tm_section.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/900-bad-mips16-crt.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/910-mbsd_multi.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/920-specs_nonfatal_getenv.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/930-fix-mips-noexecstack.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/931-fix-MIPS-softfloat-build-issue.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/940-no-clobber-stamp-bits.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/950-cpp_file_path_translation.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/960-go_libm.patch
 create mode 100644 toolchain/gcc/patches/5.5.0/970-warn_bug.patch

diff --git a/toolchain/gcc/Config.in b/toolchain/gcc/Config.in
index f0fc31d567..1aadae6839 100644
--- a/toolchain/gcc/Config.in
+++ b/toolchain/gcc/Config.in
@@ -6,6 +6,10 @@ choice
 	help
 	  Select the version of gcc you wish to use.
 
+	config GCC_USE_VERSION_5
+		bool "gcc 5.x"
+		depends on !arc
+
 	config GCC_USE_VERSION_7
 		bool "gcc 7.x"
 		depends on !arc
@@ -34,6 +38,7 @@ config EXTRA_GCC_CONFIG_OPTIONS
 config GCC_DEFAULT_PIE
 	bool
 	prompt "Build executable with PIE enabled by default" if TOOLCHAINOPTS
+	depends on !GCC_USE_VERSION_5
 	default n
 	help
 	    Use gcc configure option --enable-default-pie to turn on -fPIE and -pie by default.
diff --git a/toolchain/gcc/Config.version b/toolchain/gcc/Config.version
index 967ce9e489..09deae3bf1 100644
--- a/toolchain/gcc/Config.version
+++ b/toolchain/gcc/Config.version
@@ -1,3 +1,7 @@
+config GCC_VERSION_5
+	default y if GCC_USE_VERSION_5
+	bool
+
 config GCC_VERSION_7
 	default y if GCC_USE_VERSION_7
 	bool
@@ -12,6 +16,7 @@ config GCC_VERSION_10
 
 config GCC_VERSION
 	string
+	default "5.5.0"		if GCC_VERSION_5
 	default "7.5.0"		if GCC_VERSION_7
 	default "9.3.0"		if GCC_VERSION_9
 	default "10.2.0"	if GCC_VERSION_10
@@ -19,5 +24,5 @@ config GCC_VERSION
 
 config GCC_USE_IREMAP
 	bool
-	default y if GCC_USE_VERSION_7
+	default y if ( GCC_USE_VERSION_5 || GCC_USE_VERSION_7 )
 	default n
diff --git a/toolchain/gcc/common.mk b/toolchain/gcc/common.mk
index 55fad1fcc4..d9372f9961 100644
--- a/toolchain/gcc/common.mk
+++ b/toolchain/gcc/common.mk
@@ -28,6 +28,10 @@ GCC_DIR:=$(PKG_NAME)-$(PKG_VERSION)
 PKG_SOURCE_URL:=@GNU/gcc/gcc-$(PKG_VERSION)
 PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.xz
 
+ifeq ($(PKG_VERSION),5.5.0)
+  PKG_HASH:=530cea139d82fe542b358961130c69cfde8b3d14556370b65823d2f91f0ced87
+endif
+
 ifeq ($(PKG_VERSION),7.5.0)
   PKG_HASH:=b81946e7f01f90528a1f7352ab08cc602b9ccc05d4e44da4bd501c5a189ee661
 endif
diff --git a/toolchain/gcc/patches/5.5.0/001-revert_register_mode_search.patch b/toolchain/gcc/patches/5.5.0/001-revert_register_mode_search.patch
new file mode 100644
index 0000000000..06373eb6a0
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/001-revert_register_mode_search.patch
@@ -0,0 +1,65 @@
+Revert of:
+
+commit 275035b56823b26d5fb7e90fad945b998648edf2
+Author: bergner <bergner@138bc75d-0d04-0410-961f-82ee72b054a4>
+Date:   Thu Sep 5 14:09:07 2013 +0000
+
+        PR target/58139
+        * reginfo.c (choose_hard_reg_mode): Scan through all mode classes
+        looking for widest mode.
+
+
+    git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/trunk@202286 138bc75d-0d04-0410-961f-82ee72b054a4
+
+
+--- a/gcc/reginfo.c
++++ b/gcc/reginfo.c
+@@ -665,35 +665,40 @@ choose_hard_reg_mode (unsigned int regno
+        mode = GET_MODE_WIDER_MODE (mode))
+     if ((unsigned) hard_regno_nregs[regno][mode] == nregs
+ 	&& HARD_REGNO_MODE_OK (regno, mode)
+-	&& (! call_saved || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode))
+-	&& GET_MODE_SIZE (mode) > GET_MODE_SIZE (found_mode))
++	&& (! call_saved || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)))
+       found_mode = mode;
+ 
++  if (found_mode != VOIDmode)
++    return found_mode;
++
+   for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);
+        mode != VOIDmode;
+        mode = GET_MODE_WIDER_MODE (mode))
+     if ((unsigned) hard_regno_nregs[regno][mode] == nregs
+ 	&& HARD_REGNO_MODE_OK (regno, mode)
+-	&& (! call_saved || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode))
+-	&& GET_MODE_SIZE (mode) > GET_MODE_SIZE (found_mode))
++	&& (! call_saved || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)))
+       found_mode = mode;
+ 
++  if (found_mode != VOIDmode)
++    return found_mode;
++
+   for (mode = GET_CLASS_NARROWEST_MODE (MODE_VECTOR_FLOAT);
+        mode != VOIDmode;
+        mode = GET_MODE_WIDER_MODE (mode))
+     if ((unsigned) hard_regno_nregs[regno][mode] == nregs
+ 	&& HARD_REGNO_MODE_OK (regno, mode)
+-	&& (! call_saved || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode))
+-	&& GET_MODE_SIZE (mode) > GET_MODE_SIZE (found_mode))
++	&& (! call_saved || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)))
+       found_mode = mode;
+ 
++  if (found_mode != VOIDmode)
++    return found_mode;
++
+   for (mode = GET_CLASS_NARROWEST_MODE (MODE_VECTOR_INT);
+        mode != VOIDmode;
+        mode = GET_MODE_WIDER_MODE (mode))
+     if ((unsigned) hard_regno_nregs[regno][mode] == nregs
+ 	&& HARD_REGNO_MODE_OK (regno, mode)
+-	&& (! call_saved || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode))
+-	&& GET_MODE_SIZE (mode) > GET_MODE_SIZE (found_mode))
++	&& (! call_saved || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)))
+       found_mode = mode;
+ 
+   if (found_mode != VOIDmode)
diff --git a/toolchain/gcc/patches/5.5.0/002-case_insensitive.patch b/toolchain/gcc/patches/5.5.0/002-case_insensitive.patch
new file mode 100644
index 0000000000..b3d2dbe291
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/002-case_insensitive.patch
@@ -0,0 +1,14 @@
+--- a/include/filenames.h
++++ b/include/filenames.h
+@@ -43,11 +43,6 @@ extern "C" {
+ #  define IS_DIR_SEPARATOR(c) IS_DOS_DIR_SEPARATOR (c)
+ #  define IS_ABSOLUTE_PATH(f) IS_DOS_ABSOLUTE_PATH (f)
+ #else /* not DOSish */
+-#  if defined(__APPLE__)
+-#    ifndef HAVE_CASE_INSENSITIVE_FILE_SYSTEM
+-#      define HAVE_CASE_INSENSITIVE_FILE_SYSTEM 1
+-#    endif
+-#  endif /* __APPLE__ */
+ #  define HAS_DRIVE_SPEC(f) (0)
+ #  define IS_DIR_SEPARATOR(c) IS_UNIX_DIR_SEPARATOR (c)
+ #  define IS_ABSOLUTE_PATH(f) IS_UNIX_ABSOLUTE_PATH (f)
diff --git a/toolchain/gcc/patches/5.5.0/010-documentation.patch b/toolchain/gcc/patches/5.5.0/010-documentation.patch
new file mode 100644
index 0000000000..d7166b24e7
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/010-documentation.patch
@@ -0,0 +1,23 @@
+--- a/gcc/Makefile.in
++++ b/gcc/Makefile.in
+@@ -2943,18 +2943,10 @@ doc/gcc.info: $(TEXI_GCC_FILES)
+ doc/gccint.info: $(TEXI_GCCINT_FILES)
+ doc/cppinternals.info: $(TEXI_CPPINT_FILES)
+ 
+-doc/%.info: %.texi
+-	if [ x$(BUILD_INFO) = xinfo ]; then \
+-		$(MAKEINFO) $(MAKEINFOFLAGS) -I . -I $(gcc_docdir) \
+-			-I $(gcc_docdir)/include -o $@ $<; \
+-	fi
++doc/%.info:
+ 
+ # Duplicate entry to handle renaming of gccinstall.info
+-doc/gccinstall.info: $(TEXI_GCCINSTALL_FILES)
+-	if [ x$(BUILD_INFO) = xinfo ]; then \
+-		$(MAKEINFO) $(MAKEINFOFLAGS) -I $(gcc_docdir) \
+-			-I $(gcc_docdir)/include -o $@ $<; \
+-	fi
++doc/gccinstall.info:
+ 
+ doc/cpp.dvi: $(TEXI_CPP_FILES)
+ doc/gcc.dvi: $(TEXI_GCC_FILES)
diff --git a/toolchain/gcc/patches/5.5.0/020-no-plt-backport.patch b/toolchain/gcc/patches/5.5.0/020-no-plt-backport.patch
new file mode 100644
index 0000000000..b9702c9520
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/020-no-plt-backport.patch
@@ -0,0 +1,28 @@
+--- a/gcc/calls.c
++++ b/gcc/calls.c
+@@ -225,6 +225,12 @@ prepare_call_address (tree fndecl_or_typ
+ 	       && targetm.small_register_classes_for_mode_p (FUNCTION_MODE))
+ 	      ? force_not_mem (memory_address (FUNCTION_MODE, funexp))
+ 	      : memory_address (FUNCTION_MODE, funexp));
++  else if (flag_pic && !flag_plt && fndecl_or_type
++	   && TREE_CODE (fndecl_or_type) == FUNCTION_DECL
++	   && !targetm.binds_local_p (fndecl_or_type))
++    {
++      funexp = force_reg (Pmode, funexp);
++    }
+   else if (! sibcallp)
+     {
+ #ifndef NO_FUNCTION_CSE
+--- a/gcc/common.opt
++++ b/gcc/common.opt
+@@ -1779,6 +1779,10 @@ fpie
+ Common Report Var(flag_pie,1) Negative(fPIC)
+ Generate position-independent code for executables if possible (small mode)
+ 
++fplt
++Common Report Var(flag_plt) Init(1)
++Use PLT for PIC calls (-fno-plt: load the address from GOT at call site)
++
+ fplugin=
+ Common Joined RejectNegative Var(common_deferred_options) Defer
+ Specify a plugin to load
diff --git a/toolchain/gcc/patches/5.5.0/040-fix-mips-ICE-PR-68400.patch b/toolchain/gcc/patches/5.5.0/040-fix-mips-ICE-PR-68400.patch
new file mode 100644
index 0000000000..e88af34032
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/040-fix-mips-ICE-PR-68400.patch
@@ -0,0 +1,23 @@
+--- a/gcc/config/mips/mips.c
++++ b/gcc/config/mips/mips.c
+@@ -8001,9 +8001,17 @@ mask_low_and_shift_p (machine_mode mode,
+ bool
+ and_operands_ok (machine_mode mode, rtx op1, rtx op2)
+ {
+-  return (memory_operand (op1, mode)
+-	  ? and_load_operand (op2, mode)
+-	  : and_reg_operand (op2, mode));
++  if (!memory_operand (op1, mode))
++    return and_reg_operand (op2, mode);
++
++  if (!and_load_operand (op2, mode))
++    return false;
++
++  if (!TARGET_MIPS16 || si_mask_operand(op2, mode))
++    return true;
++
++  op1 = XEXP (op1, 0);
++  return !(REG_P (op1) && REGNO (op1) == STACK_POINTER_REGNUM);
+ }
+ 
+ /* The canonical form of a mask-low-and-shift-left operation is
diff --git a/toolchain/gcc/patches/5.5.0/050-libitm-Don-t-redefine-__always_inline-in-local_atomi.patch b/toolchain/gcc/patches/5.5.0/050-libitm-Don-t-redefine-__always_inline-in-local_atomi.patch
new file mode 100644
index 0000000000..5ec93f5247
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/050-libitm-Don-t-redefine-__always_inline-in-local_atomi.patch
@@ -0,0 +1,1092 @@
+From 55f12fce4ccf77513644a247f9c401a5b1fa2402 Mon Sep 17 00:00:00 2001
+From: torvald <torvald@138bc75d-0d04-0410-961f-82ee72b054a4>
+Date: Thu, 20 Aug 2015 17:55:24 +0000
+Subject: [PATCH] libitm: Don't redefine __always_inline in local_atomic.
+
+git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/trunk@227040 138bc75d-0d04-0410-961f-82ee72b054a4
+---
+ libitm/ChangeLog    |   6 +
+ libitm/local_atomic | 299 ++++++++++++++++++++++----------------------
+ 2 files changed, 155 insertions(+), 150 deletions(-)
+
+diff --git a/libitm/ChangeLog b/libitm/ChangeLog
+index 569d5bbbf14..6285c85fd44 100644
+--- a/libitm/ChangeLog
++++ b/libitm/ChangeLog
+@@ -1,3 +1,9 @@
++2015-08-20  Gleb Fotengauer-Malinovskiy  <glebfm@altlinux.org>  (tiny change)
++
++	PR libitm/61164
++	* local_atomic (__always_inline): Rename to...
++	(__libitm_always_inline): ... this.
++
+ 2017-10-10  Release Manager
+ 
+ 	PR target/52482
+diff --git a/libitm/local_atomic b/libitm/local_atomic
+index 3119be40d09..e536275dc9f 100644
+--- a/libitm/local_atomic
++++ b/libitm/local_atomic
+@@ -41,8 +41,7 @@
+ #ifndef _GLIBCXX_ATOMIC
+ #define _GLIBCXX_ATOMIC 1
+ 
+-#undef  __always_inline
+-#define __always_inline __attribute__((always_inline))
++#define __libitm_always_inline __attribute__((always_inline))
+ 
+ // #pragma GCC system_header
+ 
+@@ -74,7 +73,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+       memory_order_seq_cst
+     } memory_order;
+ 
+-  inline __always_inline memory_order
++  inline __libitm_always_inline memory_order
+   __calculate_memory_order(memory_order __m) noexcept
+   {
+     const bool __cond1 = __m == memory_order_release;
+@@ -84,13 +83,13 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+     return __mo2;
+   }
+ 
+-  inline __always_inline void
++  inline __libitm_always_inline void
+   atomic_thread_fence(memory_order __m) noexcept
+   {
+     __atomic_thread_fence (__m);
+   }
+ 
+-  inline __always_inline void
++  inline __libitm_always_inline void
+   atomic_signal_fence(memory_order __m) noexcept
+   {
+     __atomic_thread_fence (__m);
+@@ -280,19 +279,19 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+     // Conversion to ATOMIC_FLAG_INIT.
+     atomic_flag(bool __i) noexcept : __atomic_flag_base({ __i }) { }
+ 
+-    __always_inline bool
++    __libitm_always_inline bool
+     test_and_set(memory_order __m = memory_order_seq_cst) noexcept
+     {
+       return __atomic_test_and_set (&_M_i, __m);
+     }
+ 
+-    __always_inline bool
++    __libitm_always_inline bool
+     test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept
+     {
+       return __atomic_test_and_set (&_M_i, __m);
+     }
+ 
+-    __always_inline void
++    __libitm_always_inline void
+     clear(memory_order __m = memory_order_seq_cst) noexcept
+     {
+       // __glibcxx_assert(__m != memory_order_consume);
+@@ -302,7 +301,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+       __atomic_clear (&_M_i, __m);
+     }
+ 
+-    __always_inline void
++    __libitm_always_inline void
+     clear(memory_order __m = memory_order_seq_cst) volatile noexcept
+     {
+       // __glibcxx_assert(__m != memory_order_consume);
+@@ -455,7 +454,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+       is_lock_free() const volatile noexcept
+       { return __atomic_is_lock_free (sizeof (_M_i), &_M_i); }
+ 
+-      __always_inline void
++      __libitm_always_inline void
+       store(__int_type __i, memory_order __m = memory_order_seq_cst) noexcept
+       {
+ 	// __glibcxx_assert(__m != memory_order_acquire);
+@@ -465,7 +464,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 	__atomic_store_n(&_M_i, __i, __m);
+       }
+ 
+-      __always_inline void
++      __libitm_always_inline void
+       store(__int_type __i,
+ 	    memory_order __m = memory_order_seq_cst) volatile noexcept
+       {
+@@ -476,7 +475,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 	__atomic_store_n(&_M_i, __i, __m);
+       }
+ 
+-      __always_inline __int_type
++      __libitm_always_inline __int_type
+       load(memory_order __m = memory_order_seq_cst) const noexcept
+       {
+ 	// __glibcxx_assert(__m != memory_order_release);
+@@ -485,7 +484,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 	return __atomic_load_n(&_M_i, __m);
+       }
+ 
+-      __always_inline __int_type
++      __libitm_always_inline __int_type
+       load(memory_order __m = memory_order_seq_cst) const volatile noexcept
+       {
+ 	// __glibcxx_assert(__m != memory_order_release);
+@@ -494,21 +493,21 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 	return __atomic_load_n(&_M_i, __m);
+       }
+ 
+-      __always_inline __int_type
++      __libitm_always_inline __int_type
+       exchange(__int_type __i,
+ 	       memory_order __m = memory_order_seq_cst) noexcept
+       {
+ 	return __atomic_exchange_n(&_M_i, __i, __m);
+       }
+ 
+-      __always_inline __int_type
++      __libitm_always_inline __int_type
+       exchange(__int_type __i,
+ 	       memory_order __m = memory_order_seq_cst) volatile noexcept
+       {
+ 	return __atomic_exchange_n(&_M_i, __i, __m);
+       }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_weak(__int_type& __i1, __int_type __i2,
+ 			    memory_order __m1, memory_order __m2) noexcept
+       {
+@@ -519,7 +518,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1, __m1, __m2);
+       }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_weak(__int_type& __i1, __int_type __i2,
+ 			    memory_order __m1,
+ 			    memory_order __m2) volatile noexcept
+@@ -531,7 +530,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1, __m1, __m2);
+       }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_weak(__int_type& __i1, __int_type __i2,
+ 			    memory_order __m = memory_order_seq_cst) noexcept
+       {
+@@ -539,7 +538,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 				     __calculate_memory_order(__m));
+       }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_weak(__int_type& __i1, __int_type __i2,
+ 		   memory_order __m = memory_order_seq_cst) volatile noexcept
+       {
+@@ -547,7 +546,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 				     __calculate_memory_order(__m));
+       }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_strong(__int_type& __i1, __int_type __i2,
+ 			      memory_order __m1, memory_order __m2) noexcept
+       {
+@@ -558,7 +557,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0, __m1, __m2);
+       }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_strong(__int_type& __i1, __int_type __i2,
+ 			      memory_order __m1,
+ 			      memory_order __m2) volatile noexcept
+@@ -570,7 +569,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0, __m1, __m2);
+       }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_strong(__int_type& __i1, __int_type __i2,
+ 			      memory_order __m = memory_order_seq_cst) noexcept
+       {
+@@ -578,7 +577,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 				       __calculate_memory_order(__m));
+       }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_strong(__int_type& __i1, __int_type __i2,
+ 		 memory_order __m = memory_order_seq_cst) volatile noexcept
+       {
+@@ -586,52 +585,52 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 				       __calculate_memory_order(__m));
+       }
+ 
+-      __always_inline __int_type
++      __libitm_always_inline __int_type
+       fetch_add(__int_type __i,
+ 		memory_order __m = memory_order_seq_cst) noexcept
+       { return __atomic_fetch_add(&_M_i, __i, __m); }
+ 
+-      __always_inline __int_type
++      __libitm_always_inline __int_type
+       fetch_add(__int_type __i,
+ 		memory_order __m = memory_order_seq_cst) volatile noexcept
+       { return __atomic_fetch_add(&_M_i, __i, __m); }
+ 
+-      __always_inline __int_type
++      __libitm_always_inline __int_type
+       fetch_sub(__int_type __i,
+ 		memory_order __m = memory_order_seq_cst) noexcept
+       { return __atomic_fetch_sub(&_M_i, __i, __m); }
+ 
+-      __always_inline __int_type
++      __libitm_always_inline __int_type
+       fetch_sub(__int_type __i,
+ 		memory_order __m = memory_order_seq_cst) volatile noexcept
+       { return __atomic_fetch_sub(&_M_i, __i, __m); }
+ 
+-      __always_inline __int_type
++      __libitm_always_inline __int_type
+       fetch_and(__int_type __i,
+ 		memory_order __m = memory_order_seq_cst) noexcept
+       { return __atomic_fetch_and(&_M_i, __i, __m); }
+ 
+-      __always_inline __int_type
++      __libitm_always_inline __int_type
+       fetch_and(__int_type __i,
+ 		memory_order __m = memory_order_seq_cst) volatile noexcept
+       { return __atomic_fetch_and(&_M_i, __i, __m); }
+ 
+-      __always_inline __int_type
++      __libitm_always_inline __int_type
+       fetch_or(__int_type __i,
+ 	       memory_order __m = memory_order_seq_cst) noexcept
+       { return __atomic_fetch_or(&_M_i, __i, __m); }
+ 
+-      __always_inline __int_type
++      __libitm_always_inline __int_type
+       fetch_or(__int_type __i,
+ 	       memory_order __m = memory_order_seq_cst) volatile noexcept
+       { return __atomic_fetch_or(&_M_i, __i, __m); }
+ 
+-      __always_inline __int_type
++      __libitm_always_inline __int_type
+       fetch_xor(__int_type __i,
+ 		memory_order __m = memory_order_seq_cst) noexcept
+       { return __atomic_fetch_xor(&_M_i, __i, __m); }
+ 
+-      __always_inline __int_type
++      __libitm_always_inline __int_type
+       fetch_xor(__int_type __i,
+ 		memory_order __m = memory_order_seq_cst) volatile noexcept
+       { return __atomic_fetch_xor(&_M_i, __i, __m); }
+@@ -733,7 +732,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+       is_lock_free() const volatile noexcept
+       { return __atomic_is_lock_free (sizeof (_M_p), &_M_p); }
+ 
+-      __always_inline void
++      __libitm_always_inline void
+       store(__pointer_type __p,
+ 	    memory_order __m = memory_order_seq_cst) noexcept
+       {
+@@ -744,7 +743,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 	__atomic_store_n(&_M_p, __p, __m);
+       }
+ 
+-      __always_inline void
++      __libitm_always_inline void
+       store(__pointer_type __p,
+ 	    memory_order __m = memory_order_seq_cst) volatile noexcept
+       {
+@@ -755,7 +754,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 	__atomic_store_n(&_M_p, __p, __m);
+       }
+ 
+-      __always_inline __pointer_type
++      __libitm_always_inline __pointer_type
+       load(memory_order __m = memory_order_seq_cst) const noexcept
+       {
+ 	// __glibcxx_assert(__m != memory_order_release);
+@@ -764,7 +763,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 	return __atomic_load_n(&_M_p, __m);
+       }
+ 
+-      __always_inline __pointer_type
++      __libitm_always_inline __pointer_type
+       load(memory_order __m = memory_order_seq_cst) const volatile noexcept
+       {
+ 	// __glibcxx_assert(__m != memory_order_release);
+@@ -773,21 +772,21 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 	return __atomic_load_n(&_M_p, __m);
+       }
+ 
+-      __always_inline __pointer_type
++      __libitm_always_inline __pointer_type
+       exchange(__pointer_type __p,
+ 	       memory_order __m = memory_order_seq_cst) noexcept
+       {
+ 	return __atomic_exchange_n(&_M_p, __p, __m);
+       }
+ 
+-      __always_inline __pointer_type
++      __libitm_always_inline __pointer_type
+       exchange(__pointer_type __p,
+ 	       memory_order __m = memory_order_seq_cst) volatile noexcept
+       {
+ 	return __atomic_exchange_n(&_M_p, __p, __m);
+       }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
+ 			      memory_order __m1,
+ 			      memory_order __m2) noexcept
+@@ -799,7 +798,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 	return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0, __m1, __m2);
+       }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
+ 			      memory_order __m1,
+ 			      memory_order __m2) volatile noexcept
+@@ -811,22 +810,22 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 	return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0, __m1, __m2);
+       }
+ 
+-      __always_inline __pointer_type
++      __libitm_always_inline __pointer_type
+       fetch_add(ptrdiff_t __d,
+ 		memory_order __m = memory_order_seq_cst) noexcept
+       { return __atomic_fetch_add(&_M_p, __d, __m); }
+ 
+-      __always_inline __pointer_type
++      __libitm_always_inline __pointer_type
+       fetch_add(ptrdiff_t __d,
+ 		memory_order __m = memory_order_seq_cst) volatile noexcept
+       { return __atomic_fetch_add(&_M_p, __d, __m); }
+ 
+-      __always_inline __pointer_type
++      __libitm_always_inline __pointer_type
+       fetch_sub(ptrdiff_t __d,
+ 		memory_order __m = memory_order_seq_cst) noexcept
+       { return __atomic_fetch_sub(&_M_p, __d, __m); }
+ 
+-      __always_inline __pointer_type
++      __libitm_always_inline __pointer_type
+       fetch_sub(ptrdiff_t __d,
+ 		memory_order __m = memory_order_seq_cst) volatile noexcept
+       { return __atomic_fetch_sub(&_M_p, __d, __m); }
+@@ -870,67 +869,67 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+     bool
+     is_lock_free() const volatile noexcept { return _M_base.is_lock_free(); }
+ 
+-    __always_inline void
++    __libitm_always_inline void
+     store(bool __i, memory_order __m = memory_order_seq_cst) noexcept
+     { _M_base.store(__i, __m); }
+ 
+-    __always_inline void
++    __libitm_always_inline void
+     store(bool __i, memory_order __m = memory_order_seq_cst) volatile noexcept
+     { _M_base.store(__i, __m); }
+ 
+-    __always_inline bool
++    __libitm_always_inline bool
+     load(memory_order __m = memory_order_seq_cst) const noexcept
+     { return _M_base.load(__m); }
+ 
+-    __always_inline bool
++    __libitm_always_inline bool
+     load(memory_order __m = memory_order_seq_cst) const volatile noexcept
+     { return _M_base.load(__m); }
+ 
+-    __always_inline bool
++    __libitm_always_inline bool
+     exchange(bool __i, memory_order __m = memory_order_seq_cst) noexcept
+     { return _M_base.exchange(__i, __m); }
+ 
+-    __always_inline bool
++    __libitm_always_inline bool
+     exchange(bool __i,
+ 	     memory_order __m = memory_order_seq_cst) volatile noexcept
+     { return _M_base.exchange(__i, __m); }
+ 
+-    __always_inline bool
++    __libitm_always_inline bool
+     compare_exchange_weak(bool& __i1, bool __i2, memory_order __m1,
+ 			  memory_order __m2) noexcept
+     { return _M_base.compare_exchange_weak(__i1, __i2, __m1, __m2); }
+ 
+-    __always_inline bool
++    __libitm_always_inline bool
+     compare_exchange_weak(bool& __i1, bool __i2, memory_order __m1,
+ 			  memory_order __m2) volatile noexcept
+     { return _M_base.compare_exchange_weak(__i1, __i2, __m1, __m2); }
+ 
+-    __always_inline bool
++    __libitm_always_inline bool
+     compare_exchange_weak(bool& __i1, bool __i2,
+ 			  memory_order __m = memory_order_seq_cst) noexcept
+     { return _M_base.compare_exchange_weak(__i1, __i2, __m); }
+ 
+-    __always_inline bool
++    __libitm_always_inline bool
+     compare_exchange_weak(bool& __i1, bool __i2,
+ 		     memory_order __m = memory_order_seq_cst) volatile noexcept
+     { return _M_base.compare_exchange_weak(__i1, __i2, __m); }
+ 
+-    __always_inline bool
++    __libitm_always_inline bool
+     compare_exchange_strong(bool& __i1, bool __i2, memory_order __m1,
+ 			    memory_order __m2) noexcept
+     { return _M_base.compare_exchange_strong(__i1, __i2, __m1, __m2); }
+ 
+-    __always_inline bool
++    __libitm_always_inline bool
+     compare_exchange_strong(bool& __i1, bool __i2, memory_order __m1,
+ 			    memory_order __m2) volatile noexcept
+     { return _M_base.compare_exchange_strong(__i1, __i2, __m1, __m2); }
+ 
+-    __always_inline bool
++    __libitm_always_inline bool
+     compare_exchange_strong(bool& __i1, bool __i2,
+ 			    memory_order __m = memory_order_seq_cst) noexcept
+     { return _M_base.compare_exchange_strong(__i1, __i2, __m); }
+ 
+-    __always_inline bool
++    __libitm_always_inline bool
+     compare_exchange_strong(bool& __i1, bool __i2,
+ 		    memory_order __m = memory_order_seq_cst) volatile noexcept
+     { return _M_base.compare_exchange_strong(__i1, __i2, __m); }
+@@ -980,11 +979,11 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+       store(_Tp __i, memory_order _m = memory_order_seq_cst) noexcept
+       { __atomic_store(&_M_i, &__i, _m); }
+ 
+-      __always_inline void
++      __libitm_always_inline void
+       store(_Tp __i, memory_order _m = memory_order_seq_cst) volatile noexcept
+       { __atomic_store(&_M_i, &__i, _m); }
+ 
+-      __always_inline _Tp
++      __libitm_always_inline _Tp
+       load(memory_order _m = memory_order_seq_cst) const noexcept
+       { 
+         _Tp tmp;
+@@ -992,7 +991,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 	return tmp;
+       }
+ 
+-      __always_inline _Tp
++      __libitm_always_inline _Tp
+       load(memory_order _m = memory_order_seq_cst) const volatile noexcept
+       { 
+         _Tp tmp;
+@@ -1000,7 +999,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 	return tmp;
+       }
+ 
+-      __always_inline _Tp
++      __libitm_always_inline _Tp
+       exchange(_Tp __i, memory_order _m = memory_order_seq_cst) noexcept
+       { 
+         _Tp tmp;
+@@ -1008,7 +1007,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 	return tmp;
+       }
+ 
+-      __always_inline _Tp
++      __libitm_always_inline _Tp
+       exchange(_Tp __i, 
+ 	       memory_order _m = memory_order_seq_cst) volatile noexcept
+       { 
+@@ -1017,50 +1016,50 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 	return tmp;
+       }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_weak(_Tp& __e, _Tp __i, memory_order __s, 
+ 			    memory_order __f) noexcept
+       {
+ 	return __atomic_compare_exchange(&_M_i, &__e, &__i, true, __s, __f); 
+       }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_weak(_Tp& __e, _Tp __i, memory_order __s, 
+ 			    memory_order __f) volatile noexcept
+       {
+ 	return __atomic_compare_exchange(&_M_i, &__e, &__i, true, __s, __f); 
+       }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_weak(_Tp& __e, _Tp __i,
+ 			    memory_order __m = memory_order_seq_cst) noexcept
+       { return compare_exchange_weak(__e, __i, __m, __m); }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_weak(_Tp& __e, _Tp __i,
+ 		     memory_order __m = memory_order_seq_cst) volatile noexcept
+       { return compare_exchange_weak(__e, __i, __m, __m); }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s, 
+ 			      memory_order __f) noexcept
+       {
+ 	return __atomic_compare_exchange(&_M_i, &__e, &__i, false, __s, __f); 
+       }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s, 
+ 			      memory_order __f) volatile noexcept
+       {
+ 	return __atomic_compare_exchange(&_M_i, &__e, &__i, false, __s, __f); 
+       }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_strong(_Tp& __e, _Tp __i,
+ 			       memory_order __m = memory_order_seq_cst) noexcept
+       { return compare_exchange_strong(__e, __i, __m, __m); }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_strong(_Tp& __e, _Tp __i,
+ 		     memory_order __m = memory_order_seq_cst) volatile noexcept
+       { return compare_exchange_strong(__e, __i, __m, __m); }
+@@ -1153,46 +1152,46 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+       is_lock_free() const volatile noexcept
+       { return _M_b.is_lock_free(); }
+ 
+-      __always_inline void
++      __libitm_always_inline void
+       store(__pointer_type __p,
+ 	    memory_order __m = memory_order_seq_cst) noexcept
+       { return _M_b.store(__p, __m); }
+ 
+-      __always_inline void
++      __libitm_always_inline void
+       store(__pointer_type __p,
+ 	    memory_order __m = memory_order_seq_cst) volatile noexcept
+       { return _M_b.store(__p, __m); }
+ 
+-      __always_inline __pointer_type
++      __libitm_always_inline __pointer_type
+       load(memory_order __m = memory_order_seq_cst) const noexcept
+       { return _M_b.load(__m); }
+ 
+-      __always_inline __pointer_type
++      __libitm_always_inline __pointer_type
+       load(memory_order __m = memory_order_seq_cst) const volatile noexcept
+       { return _M_b.load(__m); }
+ 
+-      __always_inline __pointer_type
++      __libitm_always_inline __pointer_type
+       exchange(__pointer_type __p,
+ 	       memory_order __m = memory_order_seq_cst) noexcept
+       { return _M_b.exchange(__p, __m); }
+ 
+-      __always_inline __pointer_type
++      __libitm_always_inline __pointer_type
+       exchange(__pointer_type __p,
+ 	       memory_order __m = memory_order_seq_cst) volatile noexcept
+       { return _M_b.exchange(__p, __m); }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_weak(__pointer_type& __p1, __pointer_type __p2,
+ 			    memory_order __m1, memory_order __m2) noexcept
+       { return _M_b.compare_exchange_strong(__p1, __p2, __m1, __m2); }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_weak(__pointer_type& __p1, __pointer_type __p2,
+ 			    memory_order __m1,
+ 			    memory_order __m2) volatile noexcept
+       { return _M_b.compare_exchange_strong(__p1, __p2, __m1, __m2); }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_weak(__pointer_type& __p1, __pointer_type __p2,
+ 			    memory_order __m = memory_order_seq_cst) noexcept
+       {
+@@ -1200,7 +1199,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 				     __calculate_memory_order(__m));
+       }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_weak(__pointer_type& __p1, __pointer_type __p2,
+ 		    memory_order __m = memory_order_seq_cst) volatile noexcept
+       {
+@@ -1208,18 +1207,18 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 				     __calculate_memory_order(__m));
+       }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
+ 			      memory_order __m1, memory_order __m2) noexcept
+       { return _M_b.compare_exchange_strong(__p1, __p2, __m1, __m2); }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
+ 			      memory_order __m1,
+ 			      memory_order __m2) volatile noexcept
+       { return _M_b.compare_exchange_strong(__p1, __p2, __m1, __m2); }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
+ 			      memory_order __m = memory_order_seq_cst) noexcept
+       {
+@@ -1227,7 +1226,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 					    __calculate_memory_order(__m));
+       }
+ 
+-      __always_inline bool
++      __libitm_always_inline bool
+       compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
+ 		    memory_order __m = memory_order_seq_cst) volatile noexcept
+       {
+@@ -1235,22 +1234,22 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 					    __calculate_memory_order(__m));
+       }
+ 
+-      __always_inline __pointer_type
++      __libitm_always_inline __pointer_type
+       fetch_add(ptrdiff_t __d,
+ 		memory_order __m = memory_order_seq_cst) noexcept
+       { return _M_b.fetch_add(__d, __m); }
+ 
+-      __always_inline __pointer_type
++      __libitm_always_inline __pointer_type
+       fetch_add(ptrdiff_t __d,
+ 		memory_order __m = memory_order_seq_cst) volatile noexcept
+       { return _M_b.fetch_add(__d, __m); }
+ 
+-      __always_inline __pointer_type
++      __libitm_always_inline __pointer_type
+       fetch_sub(ptrdiff_t __d,
+ 		memory_order __m = memory_order_seq_cst) noexcept
+       { return _M_b.fetch_sub(__d, __m); }
+ 
+-      __always_inline __pointer_type
++      __libitm_always_inline __pointer_type
+       fetch_sub(ptrdiff_t __d,
+ 		memory_order __m = memory_order_seq_cst) volatile noexcept
+       { return _M_b.fetch_sub(__d, __m); }
+@@ -1544,98 +1543,98 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 
+ 
+   // Function definitions, atomic_flag operations.
+-  inline __always_inline bool
++  inline __libitm_always_inline bool
+   atomic_flag_test_and_set_explicit(atomic_flag* __a,
+ 				    memory_order __m) noexcept
+   { return __a->test_and_set(__m); }
+ 
+-  inline __always_inline bool
++  inline __libitm_always_inline bool
+   atomic_flag_test_and_set_explicit(volatile atomic_flag* __a,
+ 				    memory_order __m) noexcept
+   { return __a->test_and_set(__m); }
+ 
+-  inline __always_inline void
++  inline __libitm_always_inline void
+   atomic_flag_clear_explicit(atomic_flag* __a, memory_order __m) noexcept
+   { __a->clear(__m); }
+ 
+-  inline __always_inline void
++  inline __libitm_always_inline void
+   atomic_flag_clear_explicit(volatile atomic_flag* __a,
+ 			     memory_order __m) noexcept
+   { __a->clear(__m); }
+ 
+-  inline __always_inline bool
++  inline __libitm_always_inline bool
+   atomic_flag_test_and_set(atomic_flag* __a) noexcept
+   { return atomic_flag_test_and_set_explicit(__a, memory_order_seq_cst); }
+ 
+-  inline __always_inline bool
++  inline __libitm_always_inline bool
+   atomic_flag_test_and_set(volatile atomic_flag* __a) noexcept
+   { return atomic_flag_test_and_set_explicit(__a, memory_order_seq_cst); }
+ 
+-  inline __always_inline void
++  inline __libitm_always_inline void
+   atomic_flag_clear(atomic_flag* __a) noexcept
+   { atomic_flag_clear_explicit(__a, memory_order_seq_cst); }
+ 
+-  inline __always_inline void
++  inline __libitm_always_inline void
+   atomic_flag_clear(volatile atomic_flag* __a) noexcept
+   { atomic_flag_clear_explicit(__a, memory_order_seq_cst); }
+ 
+ 
+   // Function templates generally applicable to atomic types.
+   template<typename _ITp>
+-    __always_inline bool
++    __libitm_always_inline bool
+     atomic_is_lock_free(const atomic<_ITp>* __a) noexcept
+     { return __a->is_lock_free(); }
+ 
+   template<typename _ITp>
+-    __always_inline bool
++    __libitm_always_inline bool
+     atomic_is_lock_free(const volatile atomic<_ITp>* __a) noexcept
+     { return __a->is_lock_free(); }
+ 
+   template<typename _ITp>
+-    __always_inline void
++    __libitm_always_inline void
+     atomic_init(atomic<_ITp>* __a, _ITp __i) noexcept;
+ 
+   template<typename _ITp>
+-    __always_inline void
++    __libitm_always_inline void
+     atomic_init(volatile atomic<_ITp>* __a, _ITp __i) noexcept;
+ 
+   template<typename _ITp>
+-    __always_inline void
++    __libitm_always_inline void
+     atomic_store_explicit(atomic<_ITp>* __a, _ITp __i,
+ 			  memory_order __m) noexcept
+     { __a->store(__i, __m); }
+ 
+   template<typename _ITp>
+-    __always_inline void
++    __libitm_always_inline void
+     atomic_store_explicit(volatile atomic<_ITp>* __a, _ITp __i,
+ 			  memory_order __m) noexcept
+     { __a->store(__i, __m); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_load_explicit(const atomic<_ITp>* __a, memory_order __m) noexcept
+     { return __a->load(__m); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_load_explicit(const volatile atomic<_ITp>* __a,
+ 			 memory_order __m) noexcept
+     { return __a->load(__m); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_exchange_explicit(atomic<_ITp>* __a, _ITp __i,
+ 			     memory_order __m) noexcept
+     { return __a->exchange(__i, __m); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_exchange_explicit(volatile atomic<_ITp>* __a, _ITp __i,
+ 			     memory_order __m) noexcept
+     { return __a->exchange(__i, __m); }
+ 
+   template<typename _ITp>
+-    __always_inline bool
++    __libitm_always_inline bool
+     atomic_compare_exchange_weak_explicit(atomic<_ITp>* __a,
+ 					  _ITp* __i1, _ITp __i2,
+ 					  memory_order __m1,
+@@ -1643,7 +1642,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+     { return __a->compare_exchange_weak(*__i1, __i2, __m1, __m2); }
+ 
+   template<typename _ITp>
+-    __always_inline bool
++    __libitm_always_inline bool
+     atomic_compare_exchange_weak_explicit(volatile atomic<_ITp>* __a,
+ 					  _ITp* __i1, _ITp __i2,
+ 					  memory_order __m1,
+@@ -1651,7 +1650,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+     { return __a->compare_exchange_weak(*__i1, __i2, __m1, __m2); }
+ 
+   template<typename _ITp>
+-    __always_inline bool
++    __libitm_always_inline bool
+     atomic_compare_exchange_strong_explicit(atomic<_ITp>* __a,
+ 					    _ITp* __i1, _ITp __i2,
+ 					    memory_order __m1,
+@@ -1659,7 +1658,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+     { return __a->compare_exchange_strong(*__i1, __i2, __m1, __m2); }
+ 
+   template<typename _ITp>
+-    __always_inline bool
++    __libitm_always_inline bool
+     atomic_compare_exchange_strong_explicit(volatile atomic<_ITp>* __a,
+ 					    _ITp* __i1, _ITp __i2,
+ 					    memory_order __m1,
+@@ -1668,37 +1667,37 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+ 
+ 
+   template<typename _ITp>
+-    __always_inline void
++    __libitm_always_inline void
+     atomic_store(atomic<_ITp>* __a, _ITp __i) noexcept
+     { atomic_store_explicit(__a, __i, memory_order_seq_cst); }
+ 
+   template<typename _ITp>
+-    __always_inline void
++    __libitm_always_inline void
+     atomic_store(volatile atomic<_ITp>* __a, _ITp __i) noexcept
+     { atomic_store_explicit(__a, __i, memory_order_seq_cst); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_load(const atomic<_ITp>* __a) noexcept
+     { return atomic_load_explicit(__a, memory_order_seq_cst); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_load(const volatile atomic<_ITp>* __a) noexcept
+     { return atomic_load_explicit(__a, memory_order_seq_cst); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_exchange(atomic<_ITp>* __a, _ITp __i) noexcept
+     { return atomic_exchange_explicit(__a, __i, memory_order_seq_cst); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_exchange(volatile atomic<_ITp>* __a, _ITp __i) noexcept
+     { return atomic_exchange_explicit(__a, __i, memory_order_seq_cst); }
+ 
+   template<typename _ITp>
+-    __always_inline bool
++    __libitm_always_inline bool
+     atomic_compare_exchange_weak(atomic<_ITp>* __a,
+ 				 _ITp* __i1, _ITp __i2) noexcept
+     {
+@@ -1708,7 +1707,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+     }
+ 
+   template<typename _ITp>
+-    __always_inline bool
++    __libitm_always_inline bool
+     atomic_compare_exchange_weak(volatile atomic<_ITp>* __a,
+ 				 _ITp* __i1, _ITp __i2) noexcept
+     {
+@@ -1718,7 +1717,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+     }
+ 
+   template<typename _ITp>
+-    __always_inline bool
++    __libitm_always_inline bool
+     atomic_compare_exchange_strong(atomic<_ITp>* __a,
+ 				   _ITp* __i1, _ITp __i2) noexcept
+     {
+@@ -1728,7 +1727,7 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+     }
+ 
+   template<typename _ITp>
+-    __always_inline bool
++    __libitm_always_inline bool
+     atomic_compare_exchange_strong(volatile atomic<_ITp>* __a,
+ 				   _ITp* __i1, _ITp __i2) noexcept
+     {
+@@ -1742,158 +1741,158 @@ namespace std // _GLIBCXX_VISIBILITY(default)
+   // intergral types as specified in the standard, excluding address
+   // types.
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_fetch_add_explicit(__atomic_base<_ITp>* __a, _ITp __i,
+ 			      memory_order __m) noexcept
+     { return __a->fetch_add(__i, __m); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_fetch_add_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
+ 			      memory_order __m) noexcept
+     { return __a->fetch_add(__i, __m); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_fetch_sub_explicit(__atomic_base<_ITp>* __a, _ITp __i,
+ 			      memory_order __m) noexcept
+     { return __a->fetch_sub(__i, __m); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_fetch_sub_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
+ 			      memory_order __m) noexcept
+     { return __a->fetch_sub(__i, __m); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_fetch_and_explicit(__atomic_base<_ITp>* __a, _ITp __i,
+ 			      memory_order __m) noexcept
+     { return __a->fetch_and(__i, __m); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_fetch_and_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
+ 			      memory_order __m) noexcept
+     { return __a->fetch_and(__i, __m); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_fetch_or_explicit(__atomic_base<_ITp>* __a, _ITp __i,
+ 			     memory_order __m) noexcept
+     { return __a->fetch_or(__i, __m); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_fetch_or_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
+ 			     memory_order __m) noexcept
+     { return __a->fetch_or(__i, __m); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_fetch_xor_explicit(__atomic_base<_ITp>* __a, _ITp __i,
+ 			      memory_order __m) noexcept
+     { return __a->fetch_xor(__i, __m); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_fetch_xor_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
+ 			      memory_order __m) noexcept
+     { return __a->fetch_xor(__i, __m); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_fetch_add(__atomic_base<_ITp>* __a, _ITp __i) noexcept
+     { return atomic_fetch_add_explicit(__a, __i, memory_order_seq_cst); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_fetch_add(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept
+     { return atomic_fetch_add_explicit(__a, __i, memory_order_seq_cst); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_fetch_sub(__atomic_base<_ITp>* __a, _ITp __i) noexcept
+     { return atomic_fetch_sub_explicit(__a, __i, memory_order_seq_cst); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_fetch_sub(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept
+     { return atomic_fetch_sub_explicit(__a, __i, memory_order_seq_cst); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_fetch_and(__atomic_base<_ITp>* __a, _ITp __i) noexcept
+     { return atomic_fetch_and_explicit(__a, __i, memory_order_seq_cst); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_fetch_and(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept
+     { return atomic_fetch_and_explicit(__a, __i, memory_order_seq_cst); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_fetch_or(__atomic_base<_ITp>* __a, _ITp __i) noexcept
+     { return atomic_fetch_or_explicit(__a, __i, memory_order_seq_cst); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_fetch_or(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept
+     { return atomic_fetch_or_explicit(__a, __i, memory_order_seq_cst); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_fetch_xor(__atomic_base<_ITp>* __a, _ITp __i) noexcept
+     { return atomic_fetch_xor_explicit(__a, __i, memory_order_seq_cst); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp
++    __libitm_always_inline _ITp
+     atomic_fetch_xor(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept
+     { return atomic_fetch_xor_explicit(__a, __i, memory_order_seq_cst); }
+ 
+ 
+   // Partial specializations for pointers.
+   template<typename _ITp>
+-    __always_inline _ITp*
++    __libitm_always_inline _ITp*
+     atomic_fetch_add_explicit(atomic<_ITp*>* __a, ptrdiff_t __d,
+ 			      memory_order __m) noexcept
+     { return __a->fetch_add(__d, __m); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp*
++    __libitm_always_inline _ITp*
+     atomic_fetch_add_explicit(volatile atomic<_ITp*>* __a, ptrdiff_t __d,
+ 			      memory_order __m) noexcept
+     { return __a->fetch_add(__d, __m); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp*
++    __libitm_always_inline _ITp*
+     atomic_fetch_add(volatile atomic<_ITp*>* __a, ptrdiff_t __d) noexcept
+     { return __a->fetch_add(__d); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp*
++    __libitm_always_inline _ITp*
+     atomic_fetch_add(atomic<_ITp*>* __a, ptrdiff_t __d) noexcept
+     { return __a->fetch_add(__d); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp*
++    __libitm_always_inline _ITp*
+     atomic_fetch_sub_explicit(volatile atomic<_ITp*>* __a,
+ 			      ptrdiff_t __d, memory_order __m) noexcept
+     { return __a->fetch_sub(__d, __m); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp*
++    __libitm_always_inline _ITp*
+     atomic_fetch_sub_explicit(atomic<_ITp*>* __a, ptrdiff_t __d,
+ 			      memory_order __m) noexcept
+     { return __a->fetch_sub(__d, __m); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp*
++    __libitm_always_inline _ITp*
+     atomic_fetch_sub(volatile atomic<_ITp*>* __a, ptrdiff_t __d) noexcept
+     { return __a->fetch_sub(__d); }
+ 
+   template<typename _ITp>
+-    __always_inline _ITp*
++    __libitm_always_inline _ITp*
+     atomic_fetch_sub(atomic<_ITp*>* __a, ptrdiff_t __d) noexcept
+     { return __a->fetch_sub(__d); }
+   // @} group atomics
+-- 
+2.19.2
+
diff --git a/toolchain/gcc/patches/5.5.0/200-musl_config.patch b/toolchain/gcc/patches/5.5.0/200-musl_config.patch
new file mode 100644
index 0000000000..178c25ce34
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/200-musl_config.patch
@@ -0,0 +1,309 @@
+From: ktkachov <ktkachov@138bc75d-0d04-0410-961f-82ee72b054a4>
+Date: Fri, 8 May 2015 08:25:47 +0000 (+0000)
+Subject: [PATCH 2/13] musl libc config
+X-Git-Url: https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff_plain;h=a9173ceabaf29c16f8ef226fbf98af373a4b2ceb
+
+[PATCH 2/13] musl libc config
+
+2015-05-08  Gregor Richards  <gregor.richards@uwaterloo.ca>
+	    Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	* config.gcc (LIBC_MUSL): New tm_defines macro.
+	* config/linux.h (OPTION_MUSL): Define.
+	(MUSL_DYNAMIC_LINKER, MUSL_DYNAMIC_LINKER32,)
+	(MUSL_DYNAMIC_LINKER64, MUSL_DYNAMIC_LINKERX32,)
+	(INCLUDE_DEFAULTS_MUSL_GPP, INCLUDE_DEFAULTS_MUSL_LOCAL,)
+	(INCLUDE_DEFAULTS_MUSL_PREFIX, INCLUDE_DEFAULTS_MUSL_CROSS,)
+	(INCLUDE_DEFAULTS_MUSL_TOOL, INCLUDE_DEFAULTS_MUSL_NATIVE): Define.
+	* config/linux.opt (mmusl): New option.
+	* doc/invoke.texi (GNU/Linux Options): Document -mmusl.
+	* configure.ac (gcc_cv_libc_provides_ssp): Add *-*-musl*.
+	(gcc_cv_target_dl_iterate_phdr): Add *-linux-musl*.
+	* configure: Regenerate.
+
+
+git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/trunk@222904 138bc75d-0d04-0410-961f-82ee72b054a4
+---
+
+--- a/gcc/config.gcc
++++ b/gcc/config.gcc
+@@ -575,7 +575,7 @@ case ${target} in
+ esac
+ 
+ # Common C libraries.
+-tm_defines="$tm_defines LIBC_GLIBC=1 LIBC_UCLIBC=2 LIBC_BIONIC=3"
++tm_defines="$tm_defines LIBC_GLIBC=1 LIBC_UCLIBC=2 LIBC_BIONIC=3 LIBC_MUSL=4"
+ 
+ # 32-bit x86 processors supported by --with-arch=.  Each processor
+ # MUST be separated by exactly one space.
+@@ -720,6 +720,9 @@ case ${target} in
+     *-*-*uclibc*)
+       tm_defines="$tm_defines DEFAULT_LIBC=LIBC_UCLIBC"
+       ;;
++    *-*-*musl*)
++      tm_defines="$tm_defines DEFAULT_LIBC=LIBC_MUSL"
++      ;;
+     *)
+       tm_defines="$tm_defines DEFAULT_LIBC=LIBC_GLIBC"
+       ;;
+--- a/gcc/config/linux.h
++++ b/gcc/config/linux.h
+@@ -32,10 +32,12 @@ see the files COPYING3 and COPYING.RUNTI
+ #define OPTION_GLIBC  (DEFAULT_LIBC == LIBC_GLIBC)
+ #define OPTION_UCLIBC (DEFAULT_LIBC == LIBC_UCLIBC)
+ #define OPTION_BIONIC (DEFAULT_LIBC == LIBC_BIONIC)
++#define OPTION_MUSL   (DEFAULT_LIBC == LIBC_MUSL)
+ #else
+ #define OPTION_GLIBC  (linux_libc == LIBC_GLIBC)
+ #define OPTION_UCLIBC (linux_libc == LIBC_UCLIBC)
+ #define OPTION_BIONIC (linux_libc == LIBC_BIONIC)
++#define OPTION_MUSL   (linux_libc == LIBC_MUSL)
+ #endif
+ 
+ #define GNU_USER_TARGET_OS_CPP_BUILTINS()			\
+@@ -50,21 +52,25 @@ see the files COPYING3 and COPYING.RUNTI
+     } while (0)
+ 
+ /* Determine which dynamic linker to use depending on whether GLIBC or
+-   uClibc or Bionic is the default C library and whether
+-   -muclibc or -mglibc or -mbionic has been passed to change the default.  */
++   uClibc or Bionic or musl is the default C library and whether
++   -muclibc or -mglibc or -mbionic or -mmusl has been passed to change
++   the default.  */
+ 
+-#define CHOOSE_DYNAMIC_LINKER1(LIBC1, LIBC2, LIBC3, LD1, LD2, LD3)	\
+-  "%{" LIBC2 ":" LD2 ";:%{" LIBC3 ":" LD3 ";:" LD1 "}}"
++#define CHOOSE_DYNAMIC_LINKER1(LIBC1, LIBC2, LIBC3, LIBC4, LD1, LD2, LD3, LD4)	\
++  "%{" LIBC2 ":" LD2 ";:%{" LIBC3 ":" LD3 ";:%{" LIBC4 ":" LD4 ";:" LD1 "}}}"
+ 
+ #if DEFAULT_LIBC == LIBC_GLIBC
+-#define CHOOSE_DYNAMIC_LINKER(G, U, B) \
+-  CHOOSE_DYNAMIC_LINKER1 ("mglibc", "muclibc", "mbionic", G, U, B)
++#define CHOOSE_DYNAMIC_LINKER(G, U, B, M) \
++  CHOOSE_DYNAMIC_LINKER1 ("mglibc", "muclibc", "mbionic", "mmusl", G, U, B, M)
+ #elif DEFAULT_LIBC == LIBC_UCLIBC
+-#define CHOOSE_DYNAMIC_LINKER(G, U, B) \
+-  CHOOSE_DYNAMIC_LINKER1 ("muclibc", "mglibc", "mbionic", U, G, B)
++#define CHOOSE_DYNAMIC_LINKER(G, U, B, M) \
++  CHOOSE_DYNAMIC_LINKER1 ("muclibc", "mglibc", "mbionic", "mmusl", U, G, B, M)
+ #elif DEFAULT_LIBC == LIBC_BIONIC
+-#define CHOOSE_DYNAMIC_LINKER(G, U, B) \
+-  CHOOSE_DYNAMIC_LINKER1 ("mbionic", "mglibc", "muclibc", B, G, U)
++#define CHOOSE_DYNAMIC_LINKER(G, U, B, M) \
++  CHOOSE_DYNAMIC_LINKER1 ("mbionic", "mglibc", "muclibc", "mmusl", B, G, U, M)
++#elif DEFAULT_LIBC == LIBC_MUSL
++#define CHOOSE_DYNAMIC_LINKER(G, U, B, M) \
++  CHOOSE_DYNAMIC_LINKER1 ("mmusl", "mglibc", "muclibc", "mbionic", M, G, U, B)
+ #else
+ #error "Unsupported DEFAULT_LIBC"
+ #endif /* DEFAULT_LIBC */
+@@ -81,24 +87,100 @@ see the files COPYING3 and COPYING.RUNTI
+ #define BIONIC_DYNAMIC_LINKER32 "/system/bin/linker"
+ #define BIONIC_DYNAMIC_LINKER64 "/system/bin/linker64"
+ #define BIONIC_DYNAMIC_LINKERX32 "/system/bin/linkerx32"
++/* Should be redefined for each target that supports musl.  */
++#define MUSL_DYNAMIC_LINKER "/dev/null"
++#define MUSL_DYNAMIC_LINKER32 "/dev/null"
++#define MUSL_DYNAMIC_LINKER64 "/dev/null"
++#define MUSL_DYNAMIC_LINKERX32 "/dev/null"
+ 
+ #define GNU_USER_DYNAMIC_LINKER						\
+   CHOOSE_DYNAMIC_LINKER (GLIBC_DYNAMIC_LINKER, UCLIBC_DYNAMIC_LINKER,	\
+-			 BIONIC_DYNAMIC_LINKER)
++			 BIONIC_DYNAMIC_LINKER, MUSL_DYNAMIC_LINKER)
+ #define GNU_USER_DYNAMIC_LINKER32					\
+   CHOOSE_DYNAMIC_LINKER (GLIBC_DYNAMIC_LINKER32, UCLIBC_DYNAMIC_LINKER32, \
+-			 BIONIC_DYNAMIC_LINKER32)
++			 BIONIC_DYNAMIC_LINKER32, MUSL_DYNAMIC_LINKER32)
+ #define GNU_USER_DYNAMIC_LINKER64					\
+   CHOOSE_DYNAMIC_LINKER (GLIBC_DYNAMIC_LINKER64, UCLIBC_DYNAMIC_LINKER64, \
+-			 BIONIC_DYNAMIC_LINKER64)
++			 BIONIC_DYNAMIC_LINKER64, MUSL_DYNAMIC_LINKER64)
+ #define GNU_USER_DYNAMIC_LINKERX32					\
+   CHOOSE_DYNAMIC_LINKER (GLIBC_DYNAMIC_LINKERX32, UCLIBC_DYNAMIC_LINKERX32, \
+-			 BIONIC_DYNAMIC_LINKERX32)
++			 BIONIC_DYNAMIC_LINKERX32, MUSL_DYNAMIC_LINKERX32)
+ 
+ /* Whether we have Bionic libc runtime */
+ #undef TARGET_HAS_BIONIC
+ #define TARGET_HAS_BIONIC (OPTION_BIONIC)
+ 
++/* musl avoids problematic includes by rearranging the include directories.
++ * Unfortunately, this is mostly duplicated from cppdefault.c */
++#if DEFAULT_LIBC == LIBC_MUSL
++#define INCLUDE_DEFAULTS_MUSL_GPP			\
++    { GPLUSPLUS_INCLUDE_DIR, "G++", 1, 1,		\
++      GPLUSPLUS_INCLUDE_DIR_ADD_SYSROOT, 0 },		\
++    { GPLUSPLUS_TOOL_INCLUDE_DIR, "G++", 1, 1,		\
++      GPLUSPLUS_INCLUDE_DIR_ADD_SYSROOT, 1 },		\
++    { GPLUSPLUS_BACKWARD_INCLUDE_DIR, "G++", 1, 1,	\
++      GPLUSPLUS_INCLUDE_DIR_ADD_SYSROOT, 0 },
++
++#ifdef LOCAL_INCLUDE_DIR
++#define INCLUDE_DEFAULTS_MUSL_LOCAL			\
++    { LOCAL_INCLUDE_DIR, 0, 0, 1, 1, 2 },		\
++    { LOCAL_INCLUDE_DIR, 0, 0, 1, 1, 0 },
++#else
++#define INCLUDE_DEFAULTS_MUSL_LOCAL
++#endif
++
++#ifdef PREFIX_INCLUDE_DIR
++#define INCLUDE_DEFAULTS_MUSL_PREFIX			\
++    { PREFIX_INCLUDE_DIR, 0, 0, 1, 0, 0},
++#else
++#define INCLUDE_DEFAULTS_MUSL_PREFIX
++#endif
++
++#ifdef CROSS_INCLUDE_DIR
++#define INCLUDE_DEFAULTS_MUSL_CROSS			\
++    { CROSS_INCLUDE_DIR, "GCC", 0, 0, 0, 0},
++#else
++#define INCLUDE_DEFAULTS_MUSL_CROSS
++#endif
++
++#ifdef TOOL_INCLUDE_DIR
++#define INCLUDE_DEFAULTS_MUSL_TOOL			\
++    { TOOL_INCLUDE_DIR, "BINUTILS", 0, 1, 0, 0},
++#else
++#define INCLUDE_DEFAULTS_MUSL_TOOL
++#endif
++
++#ifdef NATIVE_SYSTEM_HEADER_DIR
++#define INCLUDE_DEFAULTS_MUSL_NATIVE			\
++    { NATIVE_SYSTEM_HEADER_DIR, 0, 0, 0, 1, 2 },	\
++    { NATIVE_SYSTEM_HEADER_DIR, 0, 0, 0, 1, 0 },
++#else
++#define INCLUDE_DEFAULTS_MUSL_NATIVE
++#endif
++
++#if defined (CROSS_DIRECTORY_STRUCTURE) && !defined (TARGET_SYSTEM_ROOT)
++# undef INCLUDE_DEFAULTS_MUSL_LOCAL
++# define INCLUDE_DEFAULTS_MUSL_LOCAL
++# undef INCLUDE_DEFAULTS_MUSL_NATIVE
++# define INCLUDE_DEFAULTS_MUSL_NATIVE
++#else
++# undef INCLUDE_DEFAULTS_MUSL_CROSS
++# define INCLUDE_DEFAULTS_MUSL_CROSS
++#endif
++
++#undef INCLUDE_DEFAULTS
++#define INCLUDE_DEFAULTS				\
++  {							\
++    INCLUDE_DEFAULTS_MUSL_GPP				\
++    INCLUDE_DEFAULTS_MUSL_PREFIX			\
++    INCLUDE_DEFAULTS_MUSL_CROSS				\
++    INCLUDE_DEFAULTS_MUSL_TOOL				\
++    INCLUDE_DEFAULTS_MUSL_NATIVE			\
++    { GCC_INCLUDE_DIR, "GCC", 0, 1, 0, 0 },		\
++    { 0, 0, 0, 0, 0, 0 }				\
++  }
++#endif
++
+ #if (DEFAULT_LIBC == LIBC_UCLIBC) && defined (SINGLE_LIBC) /* uClinux */
+ /* This is a *uclinux* target.  We don't define below macros to normal linux
+    versions, because doing so would require *uclinux* targets to include
+--- a/gcc/config/linux.opt
++++ b/gcc/config/linux.opt
+@@ -28,5 +28,9 @@ Target Report RejectNegative Var(linux_l
+ Use GNU C library
+ 
+ muclibc
+-Target Report RejectNegative Var(linux_libc,LIBC_UCLIBC) Negative(mbionic)
++Target Report RejectNegative Var(linux_libc,LIBC_UCLIBC) Negative(mmusl)
+ Use uClibc C library
++
++mmusl
++Target Report RejectNegative Var(linux_libc,LIBC_MUSL) Negative(mbionic)
++Use musl C library
+--- a/gcc/configure
++++ b/gcc/configure
+@@ -27833,6 +27833,9 @@ if test "${gcc_cv_libc_provides_ssp+set}
+ else
+   gcc_cv_libc_provides_ssp=no
+     case "$target" in
++       *-*-musl*)
++	 # All versions of musl provide stack protector
++	 gcc_cv_libc_provides_ssp=yes;;
+        *-*-linux* | *-*-kfreebsd*-gnu | *-*-knetbsd*-gnu)
+       # glibc 2.4 and later provides __stack_chk_fail and
+       # either __stack_chk_guard, or TLS access to stack guard canary.
+@@ -27865,6 +27868,7 @@ fi
+ 	 # <http://gcc.gnu.org/ml/gcc/2008-10/msg00130.html>) and for now
+ 	 # simply assert that glibc does provide this, which is true for all
+ 	 # realistically usable GNU/Hurd configurations.
++	 # All supported versions of musl provide it as well
+ 	 gcc_cv_libc_provides_ssp=yes;;
+        *-*-darwin* | *-*-freebsd*)
+ 	 ac_fn_c_check_func "$LINENO" "__stack_chk_fail" "ac_cv_func___stack_chk_fail"
+@@ -27961,6 +27965,9 @@ case "$target" in
+       gcc_cv_target_dl_iterate_phdr=no
+     fi
+     ;;
++  *-linux-musl*)
++    gcc_cv_target_dl_iterate_phdr=yes
++    ;;
+ esac
+ 
+ if test x$gcc_cv_target_dl_iterate_phdr = xyes; then
+--- a/gcc/configure.ac
++++ b/gcc/configure.ac
+@@ -5287,6 +5287,9 @@ AC_CACHE_CHECK(__stack_chk_fail in targe
+       gcc_cv_libc_provides_ssp,
+       [gcc_cv_libc_provides_ssp=no
+     case "$target" in
++       *-*-musl*)
++	 # All versions of musl provide stack protector
++	 gcc_cv_libc_provides_ssp=yes;;
+        *-*-linux* | *-*-kfreebsd*-gnu | *-*-knetbsd*-gnu)
+       # glibc 2.4 and later provides __stack_chk_fail and
+       # either __stack_chk_guard, or TLS access to stack guard canary.
+@@ -5313,6 +5316,7 @@ AC_CACHE_CHECK(__stack_chk_fail in targe
+ 	 # <http://gcc.gnu.org/ml/gcc/2008-10/msg00130.html>) and for now
+ 	 # simply assert that glibc does provide this, which is true for all
+ 	 # realistically usable GNU/Hurd configurations.
++	 # All supported versions of musl provide it as well
+ 	 gcc_cv_libc_provides_ssp=yes;;
+        *-*-darwin* | *-*-freebsd*)
+ 	 AC_CHECK_FUNC(__stack_chk_fail,[gcc_cv_libc_provides_ssp=yes],
+@@ -5386,6 +5390,9 @@ case "$target" in
+       gcc_cv_target_dl_iterate_phdr=no
+     fi
+     ;;
++  *-linux-musl*)
++    gcc_cv_target_dl_iterate_phdr=yes
++    ;;
+ esac
+ GCC_TARGET_TEMPLATE([TARGET_DL_ITERATE_PHDR])
+ if test x$gcc_cv_target_dl_iterate_phdr = xyes; then
+--- a/gcc/doc/invoke.texi
++++ b/gcc/doc/invoke.texi
+@@ -668,7 +668,7 @@ Objective-C and Objective-C++ Dialects}.
+ -mcpu=@var{cpu}}
+ 
+ @emph{GNU/Linux Options}
+-@gccoptlist{-mglibc -muclibc -mbionic -mandroid @gol
++@gccoptlist{-mglibc -muclibc -mmusl -mbionic -mandroid @gol
+ -tno-android-cc -tno-android-ld}
+ 
+ @emph{H8/300 Options}
+@@ -15351,13 +15351,19 @@ These @samp{-m} options are defined for 
+ @item -mglibc
+ @opindex mglibc
+ Use the GNU C library.  This is the default except
+-on @samp{*-*-linux-*uclibc*} and @samp{*-*-linux-*android*} targets.
++on @samp{*-*-linux-*uclibc*}, @samp{*-*-linux-*musl*} and
++@samp{*-*-linux-*android*} targets.
+ 
+ @item -muclibc
+ @opindex muclibc
+ Use uClibc C library.  This is the default on
+ @samp{*-*-linux-*uclibc*} targets.
+ 
++@item -mmusl
++@opindex mmusl
++Use the musl C library.  This is the default on
++@samp{*-*-linux-*musl*} targets.
++
+ @item -mbionic
+ @opindex mbionic
+ Use Bionic C library.  This is the default on
diff --git a/toolchain/gcc/patches/5.5.0/201-musl_arm.patch b/toolchain/gcc/patches/5.5.0/201-musl_arm.patch
new file mode 100644
index 0000000000..27a26afc05
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/201-musl_arm.patch
@@ -0,0 +1,43 @@
+From: ktkachov <ktkachov@138bc75d-0d04-0410-961f-82ee72b054a4>
+Date: Wed, 27 May 2015 13:17:11 +0000 (+0000)
+Subject: [PATCH 4/13] arm musl support
+X-Git-Url: https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff_plain;h=de799bd087ab9a179768fea75bd195a31d3432a4
+
+[PATCH 4/13] arm musl support
+
+On behalf of szabolcs.nagy@arm.com
+
+2015-05-27  Gregor Richards  <gregor.richards@uwaterloo.ca>
+
+	* config/arm/linux-eabi.h (MUSL_DYNAMIC_LINKER): Define.
+
+
+git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/trunk@223749 138bc75d-0d04-0410-961f-82ee72b054a4
+---
+
+--- a/gcc/config/arm/linux-eabi.h
++++ b/gcc/config/arm/linux-eabi.h
+@@ -77,6 +77,23 @@
+     %{mfloat-abi=soft*:" GLIBC_DYNAMIC_LINKER_SOFT_FLOAT "} \
+     %{!mfloat-abi=*:" GLIBC_DYNAMIC_LINKER_DEFAULT "}"
+ 
++/* For ARM musl currently supports four dynamic linkers:
++   - ld-musl-arm.so.1 - for the EABI-derived soft-float ABI
++   - ld-musl-armhf.so.1 - for the EABI-derived hard-float ABI
++   - ld-musl-armeb.so.1 - for the EABI-derived soft-float ABI, EB
++   - ld-musl-armebhf.so.1 - for the EABI-derived hard-float ABI, EB
++   musl does not support the legacy OABI mode.
++   All the dynamic linkers live in /lib.
++   We default to soft-float, EL. */
++#undef  MUSL_DYNAMIC_LINKER
++#if TARGET_BIG_ENDIAN_DEFAULT
++#define MUSL_DYNAMIC_LINKER_E "%{mlittle-endian:;:eb}"
++#else
++#define MUSL_DYNAMIC_LINKER_E "%{mbig-endian:eb}"
++#endif
++#define MUSL_DYNAMIC_LINKER \
++  "/lib/ld-musl-arm" MUSL_DYNAMIC_LINKER_E "%{mfloat-abi=hard:hf}.so.1"
++
+ /* At this point, bpabi.h will have clobbered LINK_SPEC.  We want to
+    use the GNU/Linux version, not the generic BPABI version.  */
+ #undef  LINK_SPEC
diff --git a/toolchain/gcc/patches/5.5.0/202-musl_mips.patch b/toolchain/gcc/patches/5.5.0/202-musl_mips.patch
new file mode 100644
index 0000000000..816dd8d101
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/202-musl_mips.patch
@@ -0,0 +1,35 @@
+From: ktkachov <ktkachov@138bc75d-0d04-0410-961f-82ee72b054a4>
+Date: Fri, 8 May 2015 15:16:50 +0000 (+0000)
+Subject: [PATCH 6/13] mips musl support
+X-Git-Url: https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff_plain;h=2550b6a866c887472b587bef87d433c51cf1ebc8
+
+[PATCH 6/13] mips musl support
+
+2015-05-08  Gregor Richards  <gregor.richards@uwaterloo.ca>
+	    Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	* config/mips/linux.h (MUSL_DYNAMIC_LINKER32): Define.
+	(MUSL_DYNAMIC_LINKER64, MUSL_DYNAMIC_LINKERN32): Define.
+	(GNU_USER_DYNAMIC_LINKERN32): Update.
+
+
+git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/trunk@222915 138bc75d-0d04-0410-961f-82ee72b054a4
+---
+
+--- a/gcc/config/mips/linux.h
++++ b/gcc/config/mips/linux.h
+@@ -37,7 +37,13 @@ along with GCC; see the file COPYING3.
+ #define UCLIBC_DYNAMIC_LINKERN32 \
+   "%{mnan=2008:/lib32/ld-uClibc-mipsn8.so.0;:/lib32/ld-uClibc.so.0}"
+ 
++#undef MUSL_DYNAMIC_LINKER32
++#define MUSL_DYNAMIC_LINKER32 "/lib/ld-musl-mips%{EL:el}%{msoft-float:-sf}.so.1"
++#undef MUSL_DYNAMIC_LINKER64
++#define MUSL_DYNAMIC_LINKER64 "/lib/ld-musl-mips64%{EL:el}%{msoft-float:-sf}.so.1"
++#define MUSL_DYNAMIC_LINKERN32 "/lib/ld-musl-mipsn32%{EL:el}%{msoft-float:-sf}.so.1"
++
+ #define BIONIC_DYNAMIC_LINKERN32 "/system/bin/linker32"
+ #define GNU_USER_DYNAMIC_LINKERN32 \
+   CHOOSE_DYNAMIC_LINKER (GLIBC_DYNAMIC_LINKERN32, UCLIBC_DYNAMIC_LINKERN32, \
+-                         BIONIC_DYNAMIC_LINKERN32)
++                         BIONIC_DYNAMIC_LINKERN32, MUSL_DYNAMIC_LINKERN32)
diff --git a/toolchain/gcc/patches/5.5.0/203-musl_powerpc.patch b/toolchain/gcc/patches/5.5.0/203-musl_powerpc.patch
new file mode 100644
index 0000000000..073c834ce1
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/203-musl_powerpc.patch
@@ -0,0 +1,209 @@
+
+gcc/Changelog:
+
+2015-04-24  Gregor Richards  <gregor.richards@uwaterloo.ca>
+	    Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	* config.gcc (secure_plt): Add *-linux*-musl*.
+	* config/rs6000/linux64.h (MUSL_DYNAMIC_LINKER32): Define.
+	(MUSL_DYNAMIC_LINKER64): Define.
+	(GNU_USER_DYNAMIC_LINKER32): Update.
+	(GNU_USER_DYNAMIC_LINKER64): Update.
+	(CHOOSE_DYNAMIC_LINKER): Update.
+
+	* config/rs6000/secureplt.h (LINK_SECURE_PLT_DEFAULT_SPEC): Define.
+	* config/rs6000/sysv4.h (GNU_USER_DYNAMIC_LINKER): Update.
+	(MUSL_DYNAMIC_LINKER, MUSL_DYNAMIC_LINKER_E,)
+	(INCLUDE_DEFAULTS_MUSL_GPP, INCLUDE_DEFAULTS_MUSL_LOCAL,)
+	(INCLUDE_DEFAULTS_MUSL_PREFIX, INCLUDE_DEFAULTS_MUSL_CROSS,)
+	(INCLUDE_DEFAULTS_MUSL_TOOL, INCLUDE_DEFAULTS_MUSL_NATIVE): Define.
+	(LINK_SECURE_PLT_DEFAULT_SPEC): Define.
+	(CHOOSE_DYNAMIC_LINKER, LINK_TARGET_SPEC, LINK_OS_LINUX_SPEC): Update.
+
+	* config/rs6000/sysv4le.h (MUSL_DYNAMIC_LINKER_E): Define.
+
+--- a/gcc/config/rs6000/linux64.h
++++ b/gcc/config/rs6000/linux64.h
+@@ -365,17 +365,21 @@ extern int dot_symbols;
+ #endif
+ #define UCLIBC_DYNAMIC_LINKER32 "/lib/ld-uClibc.so.0"
+ #define UCLIBC_DYNAMIC_LINKER64 "/lib/ld64-uClibc.so.0"
++#define MUSL_DYNAMIC_LINKER32 "/lib/ld-musl-powerpc" MUSL_DYNAMIC_LINKER_E ".so.1"
++#define MUSL_DYNAMIC_LINKER64 "/lib/ld-musl-powerpc64" MUSL_DYNAMIC_LINKER_E ".so.1"
+ #if DEFAULT_LIBC == LIBC_UCLIBC
+-#define CHOOSE_DYNAMIC_LINKER(G, U) "%{mglibc:" G ";:" U "}"
++#define CHOOSE_DYNAMIC_LINKER(G, U, M) "%{mglibc:" G ";:%{mmusl:" M ";:" U "}}"
+ #elif DEFAULT_LIBC == LIBC_GLIBC
+-#define CHOOSE_DYNAMIC_LINKER(G, U) "%{muclibc:" U ";:" G "}"
++#define CHOOSE_DYNAMIC_LINKER(G, U, M) "%{muclibc:" U ";:%{mmusl:" M ";:" G "}}"
++#elif DEFAULT_LIBC == LIBC_MUSL
++#define CHOOSE_DYNAMIC_LINKER(G, U, M) "%{mglibc:" G ";:%{muclibc:" U ";:" M "}}"
+ #else
+ #error "Unsupported DEFAULT_LIBC"
+ #endif
+ #define GNU_USER_DYNAMIC_LINKER32 \
+-  CHOOSE_DYNAMIC_LINKER (GLIBC_DYNAMIC_LINKER32, UCLIBC_DYNAMIC_LINKER32)
++  CHOOSE_DYNAMIC_LINKER (GLIBC_DYNAMIC_LINKER32, UCLIBC_DYNAMIC_LINKER32, MUSL_DYNAMIC_LINKER32)
+ #define GNU_USER_DYNAMIC_LINKER64 \
+-  CHOOSE_DYNAMIC_LINKER (GLIBC_DYNAMIC_LINKER64, UCLIBC_DYNAMIC_LINKER64)
++  CHOOSE_DYNAMIC_LINKER (GLIBC_DYNAMIC_LINKER64, UCLIBC_DYNAMIC_LINKER64, MUSL_DYNAMIC_LINKER64)
+ 
+ #undef  DEFAULT_ASM_ENDIAN
+ #if (TARGET_DEFAULT & MASK_LITTLE_ENDIAN)
+--- a/gcc/config/rs6000/secureplt.h
++++ b/gcc/config/rs6000/secureplt.h
+@@ -18,3 +18,4 @@ along with GCC; see the file COPYING3.  
+ <http://www.gnu.org/licenses/>.  */
+ 
+ #define CC1_SECURE_PLT_DEFAULT_SPEC "-msecure-plt"
++#define LINK_SECURE_PLT_DEFAULT_SPEC "--secure-plt"
+--- a/gcc/config/rs6000/sysv4.h
++++ b/gcc/config/rs6000/sysv4.h
+@@ -537,6 +537,9 @@ ENDIAN_SELECT(" -mbig", " -mlittle", DEF
+ #ifndef CC1_SECURE_PLT_DEFAULT_SPEC
+ #define CC1_SECURE_PLT_DEFAULT_SPEC ""
+ #endif
++#ifndef LINK_SECURE_PLT_DEFAULT_SPEC
++#define LINK_SECURE_PLT_DEFAULT_SPEC ""
++#endif
+ 
+ /* Pass -G xxx to the compiler.  */
+ #undef CC1_SPEC
+@@ -574,7 +577,8 @@ ENDIAN_SELECT(" -mbig", " -mlittle", DEF
+ %{R*} \
+ %(link_shlib) \
+ %{!T*: %(link_start) } \
+-%(link_os)"
++%(link_os)" \
++"%{!mbss-plt: %{!msecure-plt: %(link_secure_plt_default)}}"
+ 
+ /* Shared libraries are not default.  */
+ #define LINK_SHLIB_SPEC "\
+@@ -757,17 +761,22 @@ ENDIAN_SELECT(" -mbig", " -mlittle", DEF
+ 
+ #define LINK_START_LINUX_SPEC ""
+ 
++#define MUSL_DYNAMIC_LINKER_E ENDIAN_SELECT("","le","")
++
+ #define GLIBC_DYNAMIC_LINKER "/lib/ld.so.1"
+ #define UCLIBC_DYNAMIC_LINKER "/lib/ld-uClibc.so.0"
++#define MUSL_DYNAMIC_LINKER "/lib/ld-musl-powerpc" MUSL_DYNAMIC_LINKER_E ".so.1"
+ #if DEFAULT_LIBC == LIBC_UCLIBC
+-#define CHOOSE_DYNAMIC_LINKER(G, U) "%{mglibc:" G ";:" U "}"
++#define CHOOSE_DYNAMIC_LINKER(G, U, M) "%{mglibc:" G ";:%{mmusl:" M ";:" U "}}"
++#elif DEFAULT_LIBC == LIBC_MUSL
++#define CHOOSE_DYNAMIC_LINKER(G, U, M) "%{mglibc:" G ";:%{muclibc:" U ";:" M "}}"
+ #elif !defined (DEFAULT_LIBC) || DEFAULT_LIBC == LIBC_GLIBC
+-#define CHOOSE_DYNAMIC_LINKER(G, U) "%{muclibc:" U ";:" G "}"
++#define CHOOSE_DYNAMIC_LINKER(G, U, M) "%{muclibc:" U ";:%{mmusl:" M ";:" G "}}"
+ #else
+ #error "Unsupported DEFAULT_LIBC"
+ #endif
+ #define GNU_USER_DYNAMIC_LINKER \
+-  CHOOSE_DYNAMIC_LINKER (GLIBC_DYNAMIC_LINKER, UCLIBC_DYNAMIC_LINKER)
++  CHOOSE_DYNAMIC_LINKER (GLIBC_DYNAMIC_LINKER, UCLIBC_DYNAMIC_LINKER, MUSL_DYNAMIC_LINKER)
+ 
+ #define LINK_OS_LINUX_SPEC "-m elf32ppclinux %{!shared: %{!static: \
+   %{rdynamic:-export-dynamic} \
+@@ -889,6 +898,7 @@ ncrtn.o%s"
+   { "link_os_openbsd",		LINK_OS_OPENBSD_SPEC },			\
+   { "link_os_default",		LINK_OS_DEFAULT_SPEC },			\
+   { "cc1_secure_plt_default",	CC1_SECURE_PLT_DEFAULT_SPEC },		\
++  { "link_secure_plt_default",	LINK_SECURE_PLT_DEFAULT_SPEC },		\
+   { "cpp_os_ads",		CPP_OS_ADS_SPEC },			\
+   { "cpp_os_yellowknife",	CPP_OS_YELLOWKNIFE_SPEC },		\
+   { "cpp_os_mvme",		CPP_OS_MVME_SPEC },			\
+@@ -943,3 +953,72 @@ ncrtn.o%s"
+ /* This target uses the sysv4.opt file.  */
+ #define TARGET_USES_SYSV4_OPT 1
+ 
++/* Include order changes for musl, same as in generic linux.h.  */
++#if DEFAULT_LIBC == LIBC_MUSL
++#define INCLUDE_DEFAULTS_MUSL_GPP			\
++    { GPLUSPLUS_INCLUDE_DIR, "G++", 1, 1,		\
++      GPLUSPLUS_INCLUDE_DIR_ADD_SYSROOT, 0 },		\
++    { GPLUSPLUS_TOOL_INCLUDE_DIR, "G++", 1, 1,		\
++      GPLUSPLUS_INCLUDE_DIR_ADD_SYSROOT, 1 },		\
++    { GPLUSPLUS_BACKWARD_INCLUDE_DIR, "G++", 1, 1,	\
++      GPLUSPLUS_INCLUDE_DIR_ADD_SYSROOT, 0 },
++
++#ifdef LOCAL_INCLUDE_DIR
++#define INCLUDE_DEFAULTS_MUSL_LOCAL			\
++    { LOCAL_INCLUDE_DIR, 0, 0, 1, 1, 2 },		\
++    { LOCAL_INCLUDE_DIR, 0, 0, 1, 1, 0 },
++#else
++#define INCLUDE_DEFAULTS_MUSL_LOCAL
++#endif
++
++#ifdef PREFIX_INCLUDE_DIR
++#define INCLUDE_DEFAULTS_MUSL_PREFIX			\
++    { PREFIX_INCLUDE_DIR, 0, 0, 1, 0, 0},
++#else
++#define INCLUDE_DEFAULTS_MUSL_PREFIX
++#endif
++
++#ifdef CROSS_INCLUDE_DIR
++#define INCLUDE_DEFAULTS_MUSL_CROSS			\
++    { CROSS_INCLUDE_DIR, "GCC", 0, 0, 0, 0},
++#else
++#define INCLUDE_DEFAULTS_MUSL_CROSS
++#endif
++
++#ifdef TOOL_INCLUDE_DIR
++#define INCLUDE_DEFAULTS_MUSL_TOOL			\
++    { TOOL_INCLUDE_DIR, "BINUTILS", 0, 1, 0, 0},
++#else
++#define INCLUDE_DEFAULTS_MUSL_TOOL
++#endif
++
++#ifdef NATIVE_SYSTEM_HEADER_DIR
++#define INCLUDE_DEFAULTS_MUSL_NATIVE			\
++    { NATIVE_SYSTEM_HEADER_DIR, 0, 0, 0, 1, 2 },	\
++    { NATIVE_SYSTEM_HEADER_DIR, 0, 0, 0, 1, 0 },
++#else
++#define INCLUDE_DEFAULTS_MUSL_NATIVE
++#endif
++
++#if defined (CROSS_DIRECTORY_STRUCTURE) && !defined (TARGET_SYSTEM_ROOT)
++# undef INCLUDE_DEFAULTS_MUSL_LOCAL
++# define INCLUDE_DEFAULTS_MUSL_LOCAL
++# undef INCLUDE_DEFAULTS_MUSL_NATIVE
++# define INCLUDE_DEFAULTS_MUSL_NATIVE
++#else
++# undef INCLUDE_DEFAULTS_MUSL_CROSS
++# define INCLUDE_DEFAULTS_MUSL_CROSS
++#endif
++
++#undef INCLUDE_DEFAULTS
++#define INCLUDE_DEFAULTS				\
++  {							\
++    INCLUDE_DEFAULTS_MUSL_GPP				\
++    INCLUDE_DEFAULTS_MUSL_PREFIX			\
++    INCLUDE_DEFAULTS_MUSL_CROSS				\
++    INCLUDE_DEFAULTS_MUSL_TOOL				\
++    INCLUDE_DEFAULTS_MUSL_NATIVE			\
++    { GCC_INCLUDE_DIR, "GCC", 0, 1, 0, 0 },		\
++    { 0, 0, 0, 0, 0, 0 }				\
++  }
++#endif
+--- a/gcc/config/rs6000/sysv4le.h
++++ b/gcc/config/rs6000/sysv4le.h
+@@ -31,3 +31,5 @@
+ /* Little-endian PowerPC64 Linux uses the ELF v2 ABI by default.  */
+ #define LINUX64_DEFAULT_ABI_ELFv2
+ 
++#undef MUSL_DYNAMIC_LINKER_E
++#define MUSL_DYNAMIC_LINKER_E ENDIAN_SELECT("","le","le")
+--- a/gcc/config.gcc
++++ b/gcc/config.gcc
+@@ -2430,6 +2430,10 @@ powerpc*-*-linux*)
+ 	    powerpc*-*-linux*paired*)
+ 		tm_file="${tm_file} rs6000/750cl.h" ;;
+ 	esac
++	case ${target} in
++		*-linux*-musl*)
++			enable_secureplt=yes ;;
++	esac
+ 	if test x${enable_secureplt} = xyes; then
+ 		tm_file="rs6000/secureplt.h ${tm_file}"
+ 	fi
diff --git a/toolchain/gcc/patches/5.5.0/204-musl_sh.patch b/toolchain/gcc/patches/5.5.0/204-musl_sh.patch
new file mode 100644
index 0000000000..8c3753d530
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/204-musl_sh.patch
@@ -0,0 +1,39 @@
+gcc/Changelog:
+
+2015-04-27  Gregor Richards  <gregor.richards@uwaterloo.ca>
+	    Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	* config/sh/linux.h (MUSL_DYNAMIC_LINKER): Define.
+	(MUSL_DYNAMIC_LINKER_E, MUSL_DYNAMIC_LINKER_FP): Define.
+
+--- a/gcc/config/sh/linux.h
++++ b/gcc/config/sh/linux.h
+@@ -43,6 +43,28 @@ along with GCC; see the file COPYING3.
+ 
+ #define TARGET_ASM_FILE_END file_end_indicate_exec_stack
+ 
++#if TARGET_ENDIAN_DEFAULT == MASK_LITTLE_ENDIAN
++#define MUSL_DYNAMIC_LINKER_E "%{mb:eb}"
++#else
++#define MUSL_DYNAMIC_LINKER_E "%{!ml:eb}"
++#endif
++
++#if TARGET_CPU_DEFAULT & ( MASK_HARD_SH2A_DOUBLE | MASK_SH4 )
++/* "-nofpu" if any nofpu option is specified */
++#define MUSL_DYNAMIC_LINKER_FP \
++  "%{m1|m2|m2a-nofpu|m3|m4-nofpu|m4-100-nofpu|m4-200-nofpu|m4-300-nofpu|" \
++  "m4-340|m4-400|m4-500|m4al|m5-32media-nofpu|m5-64media-nofpu|" \
++  "m5-compact-nofpu:-nofpu}"
++#else
++/* "-nofpu" if none of the hard fpu options are specified */
++#define MUSL_DYNAMIC_LINKER_FP \
++  "%{m2a|m4|m4-100|m4-200|m4-300|m4a|m5-32media|m5-64media|m5-compact:;:-nofpu}"
++#endif
++
++#undef MUSL_DYNAMIC_LINKER
++#define MUSL_DYNAMIC_LINKER \
++  "/lib/ld-musl-sh" MUSL_DYNAMIC_LINKER_E MUSL_DYNAMIC_LINKER_FP ".so.1"
++
+ #define GLIBC_DYNAMIC_LINKER "/lib/ld-linux.so.2"
+ 
+ #undef SUBTARGET_LINK_EMUL_SUFFIX
diff --git a/toolchain/gcc/patches/5.5.0/205-musl_x86.patch b/toolchain/gcc/patches/5.5.0/205-musl_x86.patch
new file mode 100644
index 0000000000..8772328d64
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/205-musl_x86.patch
@@ -0,0 +1,41 @@
+From: ktkachov <ktkachov@138bc75d-0d04-0410-961f-82ee72b054a4>
+Date: Fri, 15 May 2015 13:20:01 +0000 (+0000)
+Subject: [PATCH 9/13] x86 musl support
+X-Git-Url: https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff_plain;h=5551c8d927c17f60837f15f8dfe46f945ba3fa9c
+
+[PATCH 9/13] x86 musl support
+
+On behalf of Szabolcs Nagy.
+
+2015-05-15  Gregor Richards  <gregor.richards@uwaterloo.ca>
+
+	* config/i386/linux.h (MUSL_DYNAMIC_LINKER): Define.
+	* config/i386/linux64.h (MUSL_DYNAMIC_LINKER32): Define.
+	(MUSL_DYNAMIC_LINKER64, MUSL_DYNAMIC_LINKERX32): Define.
+
+
+git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/trunk@223218 138bc75d-0d04-0410-961f-82ee72b054a4
+---
+
+--- a/gcc/config/i386/linux.h
++++ b/gcc/config/i386/linux.h
+@@ -21,3 +21,6 @@ along with GCC; see the file COPYING3.
+ 
+ #define GNU_USER_LINK_EMULATION "elf_i386"
+ #define GLIBC_DYNAMIC_LINKER "/lib/ld-linux.so.2"
++
++#undef MUSL_DYNAMIC_LINKER
++#define MUSL_DYNAMIC_LINKER "/lib/ld-musl-i386.so.1"
+--- a/gcc/config/i386/linux64.h
++++ b/gcc/config/i386/linux64.h
+@@ -30,3 +30,10 @@ see the files COPYING3 and COPYING.RUNTI
+ #define GLIBC_DYNAMIC_LINKER32 "/lib/ld-linux.so.2"
+ #define GLIBC_DYNAMIC_LINKER64 "/lib64/ld-linux-x86-64.so.2"
+ #define GLIBC_DYNAMIC_LINKERX32 "/libx32/ld-linux-x32.so.2"
++
++#undef MUSL_DYNAMIC_LINKER32
++#define MUSL_DYNAMIC_LINKER32 "/lib/ld-musl-i386.so.1"
++#undef MUSL_DYNAMIC_LINKER64
++#define MUSL_DYNAMIC_LINKER64 "/lib/ld-musl-x86_64.so.1"
++#undef MUSL_DYNAMIC_LINKERX32
++#define MUSL_DYNAMIC_LINKERX32 "/lib/ld-musl-x32.so.1"
diff --git a/toolchain/gcc/patches/5.5.0/206-musl_aarch64.patch b/toolchain/gcc/patches/5.5.0/206-musl_aarch64.patch
new file mode 100644
index 0000000000..6925a026e7
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/206-musl_aarch64.patch
@@ -0,0 +1,31 @@
+From: jgreenhalgh <jgreenhalgh@138bc75d-0d04-0410-961f-82ee72b054a4>
+Date: Wed, 27 May 2015 16:46:39 +0000 (+0000)
+Subject: [PATCH 3/13] aarch64 musl support
+X-Git-Url: https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff_plain;h=b3ff21cf0531be91bc3fb8200296a7633090ec78
+
+[PATCH 3/13] aarch64 musl support
+
+gcc/Changelog:
+
+2015-05-27  Gregor Richards  <gregor.richards@uwaterloo.ca>
+	    Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	* config/aarch64/aarch64-linux.h (MUSL_DYNAMIC_LINKER): Define.
+
+
+
+git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/trunk@223766 138bc75d-0d04-0410-961f-82ee72b054a4
+---
+
+--- a/gcc/config/aarch64/aarch64-linux.h
++++ b/gcc/config/aarch64/aarch64-linux.h
+@@ -23,6 +23,9 @@
+ 
+ #define GLIBC_DYNAMIC_LINKER "/lib/ld-linux-aarch64%{mbig-endian:_be}%{mabi=ilp32:_ilp32}.so.1"
+ 
++#undef MUSL_DYNAMIC_LINKER
++#define MUSL_DYNAMIC_LINKER "/lib/ld-musl-aarch64%{mbig-endian:_be}%{mabi=ilp32:_ilp32}.so.1"
++
+ #undef  ASAN_CC1_SPEC
+ #define ASAN_CC1_SPEC "%{%:sanitize(address):-funwind-tables}"
+ 
diff --git a/toolchain/gcc/patches/5.5.0/207-musl_fixincludes.patch b/toolchain/gcc/patches/5.5.0/207-musl_fixincludes.patch
new file mode 100644
index 0000000000..0ff33d39d8
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/207-musl_fixincludes.patch
@@ -0,0 +1,30 @@
+From: ktkachov <ktkachov@138bc75d-0d04-0410-961f-82ee72b054a4>
+Date: Wed, 22 Apr 2015 14:18:16 +0000 (+0000)
+Subject: fixincludes update for musl support
+X-Git-Url: https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff_plain;h=2dc727de2e87c2756a514cbb43cea23c99deaa3d
+
+fixincludes update for musl support
+
+On behalf of Szabolcs.Nagy@arm.com
+
+2015-04-22  Gregor Richards  <gregor.richards@uwaterloo.ca>
+
+	* mkfixinc.sh: Add *-musl* with no fixes.
+
+
+
+git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/trunk@222327 138bc75d-0d04-0410-961f-82ee72b054a4
+---
+
+--- a/fixincludes/mkfixinc.sh
++++ b/fixincludes/mkfixinc.sh
+@@ -19,7 +19,8 @@ case $machine in
+     powerpc-*-eabi*    | \
+     powerpc-*-rtems*   | \
+     powerpcle-*-eabisim* | \
+-    powerpcle-*-eabi* )
++    powerpcle-*-eabi* | \
++    *-musl* )
+ 	#  IF there is no include fixing,
+ 	#  THEN create a no-op fixer and exit
+ 	(echo "#! /bin/sh" ; echo "exit 0" ) > ${target}
diff --git a/toolchain/gcc/patches/5.5.0/209-musl_libstdc++.patch b/toolchain/gcc/patches/5.5.0/209-musl_libstdc++.patch
new file mode 100644
index 0000000000..d2414d0232
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/209-musl_libstdc++.patch
@@ -0,0 +1,72 @@
+From: ktkachov <ktkachov@138bc75d-0d04-0410-961f-82ee72b054a4>
+Date: Wed, 22 Apr 2015 14:24:11 +0000 (+0000)
+Subject: libstdc++, libgfortran gthr workaround for musl
+X-Git-Url: https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff_plain;h=1e5f711c11cb80ce609db9e9c1d8b2da0f7b5b61
+
+libstdc++, libgfortran gthr workaround for musl
+
+On behalf of szabolcs.nagy@arm.com
+
+[libstdc++-v3/]
+2015-04-22  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	* config/os/generic/os_defines.h (_GLIBCXX_GTHREAD_USE_WEAK): Define.
+	* configure.host (os_include_dir): Set to "os/generic" for linux-musl*.
+
+[libgfortran/]
+2015-04-22  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	* acinclude.m4 (GTHREAD_USE_WEAK): Define as 0 for *-*-musl*.
+	* configure: Regenerate.
+
+
+
+git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/trunk@222329 138bc75d-0d04-0410-961f-82ee72b054a4
+---
+
+--- a/libgfortran/acinclude.m4
++++ b/libgfortran/acinclude.m4
+@@ -100,7 +100,7 @@ void foo (void);
+ 	      [Define to 1 if the target supports #pragma weak])
+   fi
+   case "$host" in
+-    *-*-darwin* | *-*-hpux* | *-*-cygwin* | *-*-mingw* )
++    *-*-darwin* | *-*-hpux* | *-*-cygwin* | *-*-mingw* | *-*-musl* )
+       AC_DEFINE(GTHREAD_USE_WEAK, 0,
+ 		[Define to 0 if the target shouldn't use #pragma weak])
+       ;;
+--- a/libgfortran/configure
++++ b/libgfortran/configure
+@@ -26456,7 +26456,7 @@ $as_echo "#define SUPPORTS_WEAK 1" >>con
+ 
+   fi
+   case "$host" in
+-    *-*-darwin* | *-*-hpux* | *-*-cygwin* | *-*-mingw* )
++    *-*-darwin* | *-*-hpux* | *-*-cygwin* | *-*-mingw* | *-*-musl* )
+ 
+ $as_echo "#define GTHREAD_USE_WEAK 0" >>confdefs.h
+ 
+--- a/libstdc++-v3/config/os/generic/os_defines.h
++++ b/libstdc++-v3/config/os/generic/os_defines.h
+@@ -33,4 +33,9 @@
+ // System-specific #define, typedefs, corrections, etc, go here.  This
+ // file will come before all others.
+ 
++// Disable the weak reference logic in gthr.h for os/generic because it
++// is broken on every platform unless there is implementation specific
++// workaround in gthr-posix.h and at link-time for static linking.
++#define _GLIBCXX_GTHREAD_USE_WEAK 0
++
+ #endif
+--- a/libstdc++-v3/configure.host
++++ b/libstdc++-v3/configure.host
+@@ -273,6 +273,9 @@ case "${host_os}" in
+   freebsd*)
+     os_include_dir="os/bsd/freebsd"
+     ;;
++  linux-musl*)
++    os_include_dir="os/generic"
++    ;;
+   gnu* | linux* | kfreebsd*-gnu | knetbsd*-gnu)
+     if [ "$uclibc" = "yes" ]; then
+       os_include_dir="os/uclibc"
diff --git a/toolchain/gcc/patches/5.5.0/230-musl_libssp.patch b/toolchain/gcc/patches/5.5.0/230-musl_libssp.patch
new file mode 100644
index 0000000000..30f42e9f7c
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/230-musl_libssp.patch
@@ -0,0 +1,13 @@
+--- a/gcc/gcc.c
++++ b/gcc/gcc.c
+@@ -727,7 +727,9 @@ proper position among the other output f
+ #endif
+ 
+ #ifndef LINK_SSP_SPEC
+-#ifdef TARGET_LIBC_PROVIDES_SSP
++#if DEFAULT_LIBC == LIBC_MUSL
++#define LINK_SSP_SPEC "-lssp_nonshared"
++#elif defined(TARGET_LIBC_PROVIDES_SSP)
+ #define LINK_SSP_SPEC "%{fstack-protector|fstack-protector-all" \
+ 		       "|fstack-protector-strong|fstack-protector-explicit:}"
+ #else
diff --git a/toolchain/gcc/patches/5.5.0/240-musl-libitm-fixes.patch b/toolchain/gcc/patches/5.5.0/240-musl-libitm-fixes.patch
new file mode 100644
index 0000000000..533cb68499
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/240-musl-libitm-fixes.patch
@@ -0,0 +1,61 @@
+From: ktkachov <ktkachov@138bc75d-0d04-0410-961f-82ee72b054a4>
+Date: Wed, 22 Apr 2015 14:11:25 +0000 (+0000)
+Subject: libitm fixes for musl support
+X-Git-Url: https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff_plain;h=e53a4d49c3d03ab8eaddb073cf972c1c46d75338
+
+libitm fixes for musl support
+
+On behalf of Szabolcs.Nagy@arm.com
+
+2015-04-22  Gregor Richards  <gregor.richards@uwaterloo.ca>
+
+       * config/arm/hwcap.cc: Use fcntl.h instead of sys/fcntl.h.
+       * config/linux/x86/tls.h: Only use __GLIBC_PREREQ if defined.
+
+
+
+git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/trunk@222325 138bc75d-0d04-0410-961f-82ee72b054a4
+---
+
+--- a/libitm/config/arm/hwcap.cc
++++ b/libitm/config/arm/hwcap.cc
+@@ -40,7 +40,7 @@ int GTM_hwcap HIDDEN = 0
+ 
+ #ifdef __linux__
+ #include <unistd.h>
+-#include <sys/fcntl.h>
++#include <fcntl.h>
+ #include <elf.h>
+ 
+ static void __attribute__((constructor))
+--- a/libitm/config/linux/x86/tls.h
++++ b/libitm/config/linux/x86/tls.h
+@@ -25,16 +25,19 @@
+ #ifndef LIBITM_X86_TLS_H
+ #define LIBITM_X86_TLS_H 1
+ 
+-#if defined(__GLIBC_PREREQ) && __GLIBC_PREREQ(2, 10)
++#if defined(__GLIBC_PREREQ)
++#if __GLIBC_PREREQ(2, 10)
+ /* Use slots in the TCB head rather than __thread lookups.
+    GLIBC has reserved words 10 through 13 for TM.  */
+ #define HAVE_ARCH_GTM_THREAD 1
+ #define HAVE_ARCH_GTM_THREAD_DISP 1
+ #endif
++#endif
+ 
+ #include "config/generic/tls.h"
+ 
+-#if defined(__GLIBC_PREREQ) && __GLIBC_PREREQ(2, 10)
++#if defined(__GLIBC_PREREQ)
++#if __GLIBC_PREREQ(2, 10)
+ namespace GTM HIDDEN {
+ 
+ #ifdef __x86_64__
+@@ -101,5 +104,6 @@ static inline void set_abi_disp(struct a
+ 
+ } // namespace GTM
+ #endif /* >= GLIBC 2.10 */
++#endif
+ 
+ #endif // LIBITM_X86_TLS_H
diff --git a/toolchain/gcc/patches/5.5.0/250-add-musl.patch b/toolchain/gcc/patches/5.5.0/250-add-musl.patch
new file mode 100644
index 0000000000..8cbeddea33
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/250-add-musl.patch
@@ -0,0 +1,120 @@
+From: ktkachov <ktkachov@138bc75d-0d04-0410-961f-82ee72b054a4>
+Date: Fri, 8 May 2015 08:30:40 +0000 (+0000)
+Subject: [PATCH 0/13] Add musl support to GCC
+X-Git-Url: https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff_plain;h=f2d678afa5b8385d763b93772d73d6bf80a9739e
+
+[PATCH 0/13] Add musl support to GCC
+
+2015-05-08  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	* config/glibc-stdint.h (OPTION_MUSL): Define.
+	(INT_FAST16_TYPE, INT_FAST32_TYPE, UINT_FAST16_TYPE, UINT_FAST32_TYPE):
+	Change the definition based on OPTION_MUSL for 64 bit targets.
+	* config/linux.h (OPTION_MUSL): Redefine.
+	* config/alpha/linux.h (OPTION_MUSL): Redefine.
+	* config/rs6000/linux.h (OPTION_MUSL): Redefine.
+	* config/rs6000/linux64.h (OPTION_MUSL): Redefine.
+
+
+git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/trunk@222905 138bc75d-0d04-0410-961f-82ee72b054a4
+---
+
+--- a/gcc/config/alpha/linux.h
++++ b/gcc/config/alpha/linux.h
+@@ -61,10 +61,14 @@ along with GCC; see the file COPYING3.
+ #define OPTION_GLIBC  (DEFAULT_LIBC == LIBC_GLIBC)
+ #define OPTION_UCLIBC (DEFAULT_LIBC == LIBC_UCLIBC)
+ #define OPTION_BIONIC (DEFAULT_LIBC == LIBC_BIONIC)
++#undef OPTION_MUSL
++#define OPTION_MUSL   (DEFAULT_LIBC == LIBC_MUSL)
+ #else
+ #define OPTION_GLIBC  (linux_libc == LIBC_GLIBC)
+ #define OPTION_UCLIBC (linux_libc == LIBC_UCLIBC)
+ #define OPTION_BIONIC (linux_libc == LIBC_BIONIC)
++#undef OPTION_MUSL
++#define OPTION_MUSL   (linux_libc == LIBC_MUSL)
+ #endif
+ 
+ /* Determine what functions are present at the runtime;
+--- a/gcc/config/glibc-stdint.h
++++ b/gcc/config/glibc-stdint.h
+@@ -22,6 +22,12 @@ a copy of the GCC Runtime Library Except
+ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+ <http://www.gnu.org/licenses/>.  */
+ 
++/* Systems using musl libc should use this header and make sure
++   OPTION_MUSL is defined correctly before using the TYPE macros. */
++#ifndef OPTION_MUSL
++#define OPTION_MUSL 0
++#endif
++
+ #define SIG_ATOMIC_TYPE "int"
+ 
+ #define INT8_TYPE "signed char"
+@@ -43,12 +49,12 @@ see the files COPYING3 and COPYING.RUNTI
+ #define UINT_LEAST64_TYPE (LONG_TYPE_SIZE == 64 ? "long unsigned int" : "long long unsigned int")
+ 
+ #define INT_FAST8_TYPE "signed char"
+-#define INT_FAST16_TYPE (LONG_TYPE_SIZE == 64 ? "long int" : "int")
+-#define INT_FAST32_TYPE (LONG_TYPE_SIZE == 64 ? "long int" : "int")
++#define INT_FAST16_TYPE (LONG_TYPE_SIZE == 64 && !OPTION_MUSL ? "long int" : "int")
++#define INT_FAST32_TYPE (LONG_TYPE_SIZE == 64 && !OPTION_MUSL ? "long int" : "int")
+ #define INT_FAST64_TYPE (LONG_TYPE_SIZE == 64 ? "long int" : "long long int")
+ #define UINT_FAST8_TYPE "unsigned char"
+-#define UINT_FAST16_TYPE (LONG_TYPE_SIZE == 64 ? "long unsigned int" : "unsigned int")
+-#define UINT_FAST32_TYPE (LONG_TYPE_SIZE == 64 ? "long unsigned int" : "unsigned int")
++#define UINT_FAST16_TYPE (LONG_TYPE_SIZE == 64 && !OPTION_MUSL ? "long unsigned int" : "unsigned int")
++#define UINT_FAST32_TYPE (LONG_TYPE_SIZE == 64 && !OPTION_MUSL ? "long unsigned int" : "unsigned int")
+ #define UINT_FAST64_TYPE (LONG_TYPE_SIZE == 64 ? "long unsigned int" : "long long unsigned int")
+ 
+ #define INTPTR_TYPE (LONG_TYPE_SIZE == 64 ? "long int" : "int")
+--- a/gcc/config/linux.h
++++ b/gcc/config/linux.h
+@@ -32,11 +32,13 @@ see the files COPYING3 and COPYING.RUNTI
+ #define OPTION_GLIBC  (DEFAULT_LIBC == LIBC_GLIBC)
+ #define OPTION_UCLIBC (DEFAULT_LIBC == LIBC_UCLIBC)
+ #define OPTION_BIONIC (DEFAULT_LIBC == LIBC_BIONIC)
++#undef OPTION_MUSL
+ #define OPTION_MUSL   (DEFAULT_LIBC == LIBC_MUSL)
+ #else
+ #define OPTION_GLIBC  (linux_libc == LIBC_GLIBC)
+ #define OPTION_UCLIBC (linux_libc == LIBC_UCLIBC)
+ #define OPTION_BIONIC (linux_libc == LIBC_BIONIC)
++#undef OPTION_MUSL
+ #define OPTION_MUSL   (linux_libc == LIBC_MUSL)
+ #endif
+ 
+--- a/gcc/config/rs6000/linux.h
++++ b/gcc/config/rs6000/linux.h
+@@ -30,10 +30,14 @@
+ #define OPTION_GLIBC  (DEFAULT_LIBC == LIBC_GLIBC)
+ #define OPTION_UCLIBC (DEFAULT_LIBC == LIBC_UCLIBC)
+ #define OPTION_BIONIC (DEFAULT_LIBC == LIBC_BIONIC)
++#undef OPTION_MUSL
++#define OPTION_MUSL   (DEFAULT_LIBC == LIBC_MUSL)
+ #else
+ #define OPTION_GLIBC  (linux_libc == LIBC_GLIBC)
+ #define OPTION_UCLIBC (linux_libc == LIBC_UCLIBC)
+ #define OPTION_BIONIC (linux_libc == LIBC_BIONIC)
++#undef OPTION_MUSL
++#define OPTION_MUSL   (linux_libc == LIBC_MUSL)
+ #endif
+ 
+ /* Determine what functions are present at the runtime;
+--- a/gcc/config/rs6000/linux64.h
++++ b/gcc/config/rs6000/linux64.h
+@@ -299,10 +299,14 @@ extern int dot_symbols;
+ #define OPTION_GLIBC  (DEFAULT_LIBC == LIBC_GLIBC)
+ #define OPTION_UCLIBC (DEFAULT_LIBC == LIBC_UCLIBC)
+ #define OPTION_BIONIC (DEFAULT_LIBC == LIBC_BIONIC)
++#undef OPTION_MUSL
++#define OPTION_MUSL   (DEFAULT_LIBC == LIBC_MUSL)
+ #else
+ #define OPTION_GLIBC  (linux_libc == LIBC_GLIBC)
+ #define OPTION_UCLIBC (linux_libc == LIBC_UCLIBC)
+ #define OPTION_BIONIC (linux_libc == LIBC_BIONIC)
++#undef OPTION_MUSL
++#define OPTION_MUSL   (linux_libc == LIBC_MUSL)
+ #endif
+ 
+ /* Determine what functions are present at the runtime;
diff --git a/toolchain/gcc/patches/5.5.0/260-musl-add-unwind-fix.patch b/toolchain/gcc/patches/5.5.0/260-musl-add-unwind-fix.patch
new file mode 100644
index 0000000000..a3b83e2074
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/260-musl-add-unwind-fix.patch
@@ -0,0 +1,34 @@
+From: ktkachov <ktkachov@138bc75d-0d04-0410-961f-82ee72b054a4>
+Date: Wed, 22 Apr 2015 14:20:01 +0000 (+0000)
+Subject: unwind fix for musl
+X-Git-Url: https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff_plain;h=a2e31d0681d8a47389b8a3552622fbd9827bcef4
+
+unwind fix for musl
+
+On behalf of szabolcs.nagy@arm.com
+
+2015-04-22  Gregor Richards  <gregor.richards@uwaterloo.ca>
+	    Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	* unwind-dw2-fde-dip.c (USE_PT_GNU_EH_FRAME): Define it on
+	Linux if target provides dl_iterate_phdr.
+
+
+git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/trunk@222328 138bc75d-0d04-0410-961f-82ee72b054a4
+---
+
+--- a/libgcc/unwind-dw2-fde-dip.c
++++ b/libgcc/unwind-dw2-fde-dip.c
+@@ -59,6 +59,12 @@
+ 
+ #if !defined(inhibit_libc) && defined(HAVE_LD_EH_FRAME_HDR) \
+     && defined(TARGET_DL_ITERATE_PHDR) \
++    && defined(__linux__)
++# define USE_PT_GNU_EH_FRAME
++#endif
++
++#if !defined(inhibit_libc) && defined(HAVE_LD_EH_FRAME_HDR) \
++    && defined(TARGET_DL_ITERATE_PHDR) \
+     && (defined(__DragonFly__) || defined(__FreeBSD__))
+ # define ElfW __ElfN
+ # define USE_PT_GNU_EH_FRAME
diff --git a/toolchain/gcc/patches/5.5.0/270-musl-add-powerpc-softfloat-fix.patch b/toolchain/gcc/patches/5.5.0/270-musl-add-powerpc-softfloat-fix.patch
new file mode 100644
index 0000000000..bdebf6c01f
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/270-musl-add-powerpc-softfloat-fix.patch
@@ -0,0 +1,24 @@
+--- a/gcc/config/rs6000/linux64.h
++++ b/gcc/config/rs6000/linux64.h
+@@ -369,8 +369,8 @@ extern int dot_symbols;
+ #endif
+ #define UCLIBC_DYNAMIC_LINKER32 "/lib/ld-uClibc.so.0"
+ #define UCLIBC_DYNAMIC_LINKER64 "/lib/ld64-uClibc.so.0"
+-#define MUSL_DYNAMIC_LINKER32 "/lib/ld-musl-powerpc" MUSL_DYNAMIC_LINKER_E ".so.1"
+-#define MUSL_DYNAMIC_LINKER64 "/lib/ld-musl-powerpc64" MUSL_DYNAMIC_LINKER_E ".so.1"
++#define MUSL_DYNAMIC_LINKER32 "/lib/ld-musl-powerpc" MUSL_DYNAMIC_LINKER_E "%{msoft-float:-sf}.so.1"
++#define MUSL_DYNAMIC_LINKER64 "/lib/ld-musl-powerpc64" MUSL_DYNAMIC_LINKER_E "%{msoft-float:-sf}.so.1"
+ #if DEFAULT_LIBC == LIBC_UCLIBC
+ #define CHOOSE_DYNAMIC_LINKER(G, U, M) "%{mglibc:" G ";:%{mmusl:" M ";:" U "}}"
+ #elif DEFAULT_LIBC == LIBC_GLIBC
+--- a/gcc/config/rs6000/sysv4.h
++++ b/gcc/config/rs6000/sysv4.h
+@@ -765,7 +765,7 @@ ENDIAN_SELECT(" -mbig", " -mlittle", DEF
+ 
+ #define GLIBC_DYNAMIC_LINKER "/lib/ld.so.1"
+ #define UCLIBC_DYNAMIC_LINKER "/lib/ld-uClibc.so.0"
+-#define MUSL_DYNAMIC_LINKER "/lib/ld-musl-powerpc" MUSL_DYNAMIC_LINKER_E ".so.1"
++#define MUSL_DYNAMIC_LINKER "/lib/ld-musl-powerpc" MUSL_DYNAMIC_LINKER_E "%{msoft-float:-sf}.so.1"
+ #if DEFAULT_LIBC == LIBC_UCLIBC
+ #define CHOOSE_DYNAMIC_LINKER(G, U, M) "%{mglibc:" G ";:%{mmusl:" M ";:" U "}}"
+ #elif DEFAULT_LIBC == LIBC_MUSL
diff --git a/toolchain/gcc/patches/5.5.0/280-musl-disable-ifunc-by-default.patch b/toolchain/gcc/patches/5.5.0/280-musl-disable-ifunc-by-default.patch
new file mode 100644
index 0000000000..9a043eed3c
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/280-musl-disable-ifunc-by-default.patch
@@ -0,0 +1,36 @@
+From 450fb05e2a7510d37744f044009f8237d902f65c Mon Sep 17 00:00:00 2001
+From: nsz <nsz@138bc75d-0d04-0410-961f-82ee72b054a4>
+Date: Tue, 30 Aug 2016 10:26:22 +0000
+Subject: [PATCH] disable ifunc on *-musl by default
+
+gcc/
+	* config.gcc (*-*-*musl*): Disable gnu-indirect-function.
+
+
+
+git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/trunk@239859 138bc75d-0d04-0410-961f-82ee72b054a4
+---
+ gcc/ChangeLog  | 4 ++++
+ gcc/config.gcc | 4 ++--
+ 2 files changed, 6 insertions(+), 2 deletions(-)
+
+--- a/gcc/config.gcc
++++ b/gcc/config.gcc
+@@ -1455,7 +1455,7 @@ i[34567]86-*-linux* | i[34567]86-*-kfree
+ 		extra_options="${extra_options} linux-android.opt"
+ 		# Assume modern glibc if not targeting Android nor uclibc.
+ 		case ${target} in
+-		*-*-*android*|*-*-*uclibc*)
++		*-*-*android*|*-*-*uclibc*|*-*-*musl*)
+ 		  ;;
+ 		*)
+ 		  default_gnu_indirect_function=yes
+@@ -1524,7 +1524,7 @@ x86_64-*-linux* | x86_64-*-kfreebsd*-gnu
+ 		extra_options="${extra_options} linux-android.opt"
+ 		# Assume modern glibc if not targeting Android nor uclibc.
+ 		case ${target} in
+-		*-*-*android*|*-*-*uclibc*)
++		*-*-*android*|*-*-*uclibc*|*-*-*musl*)
+ 		  ;;
+ 		*)
+ 		  default_gnu_indirect_function=yes
diff --git a/toolchain/gcc/patches/5.5.0/300-mips_Os_cpu_rtx_cost_model.patch b/toolchain/gcc/patches/5.5.0/300-mips_Os_cpu_rtx_cost_model.patch
new file mode 100644
index 0000000000..1743658ac6
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/300-mips_Os_cpu_rtx_cost_model.patch
@@ -0,0 +1,14 @@
+Use the proper rtx cost model for the selected CPU, even when optimizing
+for size. This generates better code.
+
+--- a/gcc/config/mips/mips.c
++++ b/gcc/config/mips/mips.c
+@@ -17483,7 +17483,7 @@ mips_option_override (void)
+     flag_pcc_struct_return = 0;
+ 
+   /* Decide which rtx_costs structure to use.  */
+-  if (optimize_size)
++  if (0 && optimize_size)
+     mips_cost = &mips_rtx_cost_optimize_size;
+   else
+     mips_cost = &mips_rtx_cost_data[mips_tune];
diff --git a/toolchain/gcc/patches/5.5.0/800-arm_v5te_no_ldrd_strd.patch b/toolchain/gcc/patches/5.5.0/800-arm_v5te_no_ldrd_strd.patch
new file mode 100644
index 0000000000..0edeb13c75
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/800-arm_v5te_no_ldrd_strd.patch
@@ -0,0 +1,11 @@
+--- a/gcc/config/arm/arm.h
++++ b/gcc/config/arm/arm.h
+@@ -285,7 +285,7 @@ extern void (*arm_lang_output_object_att
+ /* Thumb-1 only.  */
+ #define TARGET_THUMB1_ONLY		(TARGET_THUMB1 && !arm_arch_notm)
+ 
+-#define TARGET_LDRD			(arm_arch5e && ARM_DOUBLEWORD_ALIGN \
++#define TARGET_LDRD			(arm_arch6 && ARM_DOUBLEWORD_ALIGN \
+                                          && !TARGET_THUMB1)
+ 
+ #define TARGET_CRC32			(arm_arch_crc)
diff --git a/toolchain/gcc/patches/5.5.0/810-arm-softfloat-libgcc.patch b/toolchain/gcc/patches/5.5.0/810-arm-softfloat-libgcc.patch
new file mode 100644
index 0000000000..1d06f5b2ec
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/810-arm-softfloat-libgcc.patch
@@ -0,0 +1,25 @@
+--- a/libgcc/config/arm/t-linux
++++ b/libgcc/config/arm/t-linux
+@@ -1,6 +1,10 @@
+ LIB1ASMSRC = arm/lib1funcs.S
+ LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_lnx _clzsi2 _clzdi2 \
+-	_ctzsi2 _arm_addsubdf3 _arm_addsubsf3
++	_ctzsi2 _arm_addsubdf3 _arm_addsubsf3 \
++	_arm_negdf2 _arm_muldivdf3 _arm_cmpdf2 _arm_unorddf2 \
++	_arm_fixdfsi _arm_fixunsdfsi _arm_truncdfsf2 \
++	_arm_negsf2 _arm_muldivsf3 _arm_cmpsf2 _arm_unordsf2 \
++	_arm_fixsfsi _arm_fixunssfsi
+ 
+ # Just for these, we omit the frame pointer since it makes such a big
+ # difference.
+--- a/gcc/config/arm/linux-elf.h
++++ b/gcc/config/arm/linux-elf.h
+@@ -60,8 +60,6 @@
+    %{shared:-lc} \
+    %{!shared:%{profile:-lc_p}%{!profile:-lc}}"
+ 
+-#define LIBGCC_SPEC "%{mfloat-abi=soft*:-lfloat} -lgcc"
+-
+ #define GLIBC_DYNAMIC_LINKER "/lib/ld-linux.so.2"
+ 
+ #define LINUX_TARGET_LINK_SPEC  "%{h*} \
diff --git a/toolchain/gcc/patches/5.5.0/820-libgcc_pic.patch b/toolchain/gcc/patches/5.5.0/820-libgcc_pic.patch
new file mode 100644
index 0000000000..42bf0c8ccc
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/820-libgcc_pic.patch
@@ -0,0 +1,36 @@
+--- a/libgcc/Makefile.in
++++ b/libgcc/Makefile.in
+@@ -887,11 +887,12 @@ $(libgcov-driver-objects): %$(objext): $
+ 
+ # Static libraries.
+ libgcc.a: $(libgcc-objects)
++libgcc_pic.a: $(libgcc-s-objects)
+ libgcov.a: $(libgcov-objects)
+ libunwind.a: $(libunwind-objects)
+ libgcc_eh.a: $(libgcc-eh-objects)
+ 
+-libgcc.a libgcov.a libunwind.a libgcc_eh.a:
++libgcc.a libgcov.a libunwind.a libgcc_eh.a libgcc_pic.a:
+ 	-rm -f $@
+ 
+ 	objects="$(objects)";					\
+@@ -913,7 +914,7 @@ libgcc_s$(SHLIB_EXT): libunwind$(SHLIB_E
+ endif
+ 
+ ifeq ($(enable_shared),yes)
+-all: libgcc_eh.a libgcc_s$(SHLIB_EXT)
++all: libgcc_eh.a libgcc_pic.a libgcc_s$(SHLIB_EXT)
+ ifneq ($(LIBUNWIND),)
+ all: libunwind$(SHLIB_EXT)
+ endif
+@@ -1108,6 +1109,10 @@ install-shared:
+ 	chmod 644 $(DESTDIR)$(inst_libdir)/libgcc_eh.a
+ 	$(RANLIB) $(DESTDIR)$(inst_libdir)/libgcc_eh.a
+ 
++	$(INSTALL_DATA) libgcc_pic.a $(mapfile) $(DESTDIR)$(inst_libdir)/
++	chmod 644 $(DESTDIR)$(inst_libdir)/libgcc_pic.a
++	$(RANLIB) $(DESTDIR)$(inst_libdir)/libgcc_pic.a
++
+ 	$(subst @multilib_dir@,$(MULTIDIR),$(subst \
+ 		@shlib_base_name@,libgcc_s,$(subst \
+ 		@shlib_slibdir_qual@,$(MULTIOSSUBDIR),$(SHLIB_INSTALL))))
diff --git a/toolchain/gcc/patches/5.5.0/830-arm_unbreak_armv4t.patch b/toolchain/gcc/patches/5.5.0/830-arm_unbreak_armv4t.patch
new file mode 100644
index 0000000000..37f8f2a54d
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/830-arm_unbreak_armv4t.patch
@@ -0,0 +1,13 @@
+http://sourceware.org/ml/crossgcc/2008-05/msg00009.html
+
+--- a/gcc/config/arm/linux-eabi.h
++++ b/gcc/config/arm/linux-eabi.h
+@@ -45,7 +45,7 @@
+    The ARM10TDMI core is the default for armv5t, so set
+    SUBTARGET_CPU_DEFAULT to achieve this.  */
+ #undef  SUBTARGET_CPU_DEFAULT
+-#define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm10tdmi
++#define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm9tdmi
+ 
+ /* TARGET_BIG_ENDIAN_DEFAULT is set in
+    config.gcc for big endian configurations.  */
diff --git a/toolchain/gcc/patches/5.5.0/840-armv4_pass_fix-v4bx_to_ld.patch b/toolchain/gcc/patches/5.5.0/840-armv4_pass_fix-v4bx_to_ld.patch
new file mode 100644
index 0000000000..cb1fb98235
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/840-armv4_pass_fix-v4bx_to_ld.patch
@@ -0,0 +1,19 @@
+--- a/gcc/config/arm/linux-eabi.h
++++ b/gcc/config/arm/linux-eabi.h
+@@ -94,10 +94,15 @@
+ #define MUSL_DYNAMIC_LINKER \
+   "/lib/ld-musl-arm" MUSL_DYNAMIC_LINKER_E "%{mfloat-abi=hard:hf}.so.1"
+ 
++/* For armv4 we pass --fix-v4bx to linker to support EABI */
++#undef TARGET_FIX_V4BX_SPEC
++#define TARGET_FIX_V4BX_SPEC " %{mcpu=arm8|mcpu=arm810|mcpu=strongarm*"\
++  "|march=armv4|mcpu=fa526|mcpu=fa626:--fix-v4bx}"
++
+ /* At this point, bpabi.h will have clobbered LINK_SPEC.  We want to
+    use the GNU/Linux version, not the generic BPABI version.  */
+ #undef  LINK_SPEC
+-#define LINK_SPEC EABI_LINK_SPEC					\
++#define LINK_SPEC EABI_LINK_SPEC TARGET_FIX_V4BX_SPEC			\
+   LINUX_OR_ANDROID_LD (LINUX_TARGET_LINK_SPEC,				\
+ 		       LINUX_TARGET_LINK_SPEC " " ANDROID_LINK_SPEC)
+ 
diff --git a/toolchain/gcc/patches/5.5.0/850-use_shared_libgcc.patch b/toolchain/gcc/patches/5.5.0/850-use_shared_libgcc.patch
new file mode 100644
index 0000000000..5818cf4da0
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/850-use_shared_libgcc.patch
@@ -0,0 +1,47 @@
+--- a/gcc/config/arm/linux-eabi.h
++++ b/gcc/config/arm/linux-eabi.h
+@@ -131,10 +131,6 @@
+ #define ENDFILE_SPEC \
+   LINUX_OR_ANDROID_LD (GNU_USER_TARGET_ENDFILE_SPEC, ANDROID_ENDFILE_SPEC)
+ 
+-/* Use the default LIBGCC_SPEC, not the version in linux-elf.h, as we
+-   do not use -lfloat.  */
+-#undef LIBGCC_SPEC
+-
+ /* Clear the instruction cache from `beg' to `end'.  This is
+    implemented in lib1funcs.S, so ensure an error if this definition
+    is used.  */
+--- a/gcc/config/linux.h
++++ b/gcc/config/linux.h
+@@ -53,6 +53,10 @@ see the files COPYING3 and COPYING.RUNTI
+ 	builtin_assert ("system=posix");			\
+     } while (0)
+ 
++#ifndef LIBGCC_SPEC
++#define LIBGCC_SPEC "%{static|static-libgcc:-lgcc}%{!static:%{!static-libgcc:-lgcc_s}}"
++#endif
++
+ /* Determine which dynamic linker to use depending on whether GLIBC or
+    uClibc or Bionic or musl is the default C library and whether
+    -muclibc or -mglibc or -mbionic or -mmusl has been passed to change
+--- a/libgcc/mkmap-symver.awk
++++ b/libgcc/mkmap-symver.awk
+@@ -132,5 +132,5 @@ function output(lib) {
+   else if (inherit[lib])
+     printf("} %s;\n", inherit[lib]);
+   else
+-    printf ("\n  local:\n\t*;\n};\n");
++    printf ("\n\t*;\n};\n");
+ }
+--- a/gcc/config/rs6000/linux.h
++++ b/gcc/config/rs6000/linux.h
+@@ -60,6 +60,9 @@
+ #undef	CPP_OS_DEFAULT_SPEC
+ #define CPP_OS_DEFAULT_SPEC "%(cpp_os_linux)"
+ 
++#undef LIBGCC_SPEC
++#define LIBGCC_SPEC "%{!static:%{!static-libgcc:-lgcc_s}} -lgcc"
++
+ #undef  LINK_SHLIB_SPEC
+ #define LINK_SHLIB_SPEC "%{shared:-shared} %{!shared: %{static:-static}}"
+ 
diff --git a/toolchain/gcc/patches/5.5.0/851-libgcc_no_compat.patch b/toolchain/gcc/patches/5.5.0/851-libgcc_no_compat.patch
new file mode 100644
index 0000000000..80c3476841
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/851-libgcc_no_compat.patch
@@ -0,0 +1,12 @@
+--- a/libgcc/config/t-libunwind
++++ b/libgcc/config/t-libunwind
+@@ -2,8 +2,7 @@
+ 
+ HOST_LIBGCC2_CFLAGS += -DUSE_GAS_SYMVER
+ 
+-LIB2ADDEH = $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c \
+-  $(srcdir)/unwind-compat.c $(srcdir)/unwind-dw2-fde-compat.c
++LIB2ADDEH = $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c
+ LIB2ADDEHSTATIC = $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c
+ 
+ # Override the default value from t-slibgcc-elf-ver and mention -lunwind
diff --git a/toolchain/gcc/patches/5.5.0/870-ppc_no_crtsavres.patch b/toolchain/gcc/patches/5.5.0/870-ppc_no_crtsavres.patch
new file mode 100644
index 0000000000..d06673efc2
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/870-ppc_no_crtsavres.patch
@@ -0,0 +1,11 @@
+--- a/gcc/config/rs6000/rs6000.c
++++ b/gcc/config/rs6000/rs6000.c
+@@ -21528,7 +21528,7 @@ rs6000_savres_strategy (rs6000_stack_t *
+   /* Define cutoff for using out-of-line functions to save registers.  */
+   if (DEFAULT_ABI == ABI_V4 || TARGET_ELF)
+     {
+-      if (!optimize_size)
++      if (1)
+ 	{
+ 	  strategy |= SAVE_INLINE_FPRS | REST_INLINE_FPRS;
+ 	  strategy |= SAVE_INLINE_GPRS | REST_INLINE_GPRS;
diff --git a/toolchain/gcc/patches/5.5.0/880-no_java_section.patch b/toolchain/gcc/patches/5.5.0/880-no_java_section.patch
new file mode 100644
index 0000000000..def6c9f4a0
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/880-no_java_section.patch
@@ -0,0 +1,11 @@
+--- a/gcc/defaults.h
++++ b/gcc/defaults.h
+@@ -380,7 +380,7 @@ see the files COPYING3 and COPYING.RUNTI
+ /* If we have named section and we support weak symbols, then use the
+    .jcr section for recording java classes which need to be registered
+    at program start-up time.  */
+-#if defined (TARGET_ASM_NAMED_SECTION) && SUPPORTS_WEAK
++#if 0 && defined (TARGET_ASM_NAMED_SECTION) && SUPPORTS_WEAK
+ #ifndef JCR_SECTION_NAME
+ #define JCR_SECTION_NAME ".jcr"
+ #endif
diff --git a/toolchain/gcc/patches/5.5.0/881-no_tm_section.patch b/toolchain/gcc/patches/5.5.0/881-no_tm_section.patch
new file mode 100644
index 0000000000..fab5db3be5
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/881-no_tm_section.patch
@@ -0,0 +1,11 @@
+--- a/libgcc/crtstuff.c
++++ b/libgcc/crtstuff.c
+@@ -152,7 +152,7 @@ call_ ## FUNC (void)					\
+ #endif
+ 
+ #if !defined(USE_TM_CLONE_REGISTRY) && defined(OBJECT_FORMAT_ELF)
+-# define USE_TM_CLONE_REGISTRY 1
++# define USE_TM_CLONE_REGISTRY 0
+ #endif
+ 
+ /* We do not want to add the weak attribute to the declarations of these
diff --git a/toolchain/gcc/patches/5.5.0/900-bad-mips16-crt.patch b/toolchain/gcc/patches/5.5.0/900-bad-mips16-crt.patch
new file mode 100644
index 0000000000..dd6e9dc889
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/900-bad-mips16-crt.patch
@@ -0,0 +1,9 @@
+--- a/libgcc/config/mips/t-mips16
++++ b/libgcc/config/mips/t-mips16
+@@ -43,3 +43,6 @@ SYNC_CFLAGS = -mno-mips16
+ 
+ # Version these symbols if building libgcc.so.
+ SHLIB_MAPFILES += $(srcdir)/config/mips/libgcc-mips16.ver
++
++CRTSTUFF_T_CFLAGS += -mno-mips16
++CRTSTUFF_T_CFLAGS_S += -mno-mips16
diff --git a/toolchain/gcc/patches/5.5.0/910-mbsd_multi.patch b/toolchain/gcc/patches/5.5.0/910-mbsd_multi.patch
new file mode 100644
index 0000000000..88905f6f2f
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/910-mbsd_multi.patch
@@ -0,0 +1,222 @@
+
+	This patch brings over a few features from MirBSD:
+	* -fhonour-copts
+	  If this option is not given, it's warned (depending
+	  on environment variables). This is to catch errors
+	  of misbuilt packages which override CFLAGS themselves.
+	* -Werror-maybe-reset
+	  Has the effect of -Wno-error if GCC_NO_WERROR is
+	  set and not '0', a no-operation otherwise. This is
+	  to be able to use -Werror in "make" but prevent
+	  GNU autoconf generated configure scripts from
+	  freaking out.
+
+	This patch was authored by Thorsten Glaser <tg at mirbsd.de>
+	with copyright assignment to the FSF in effect.
+
+--- a/gcc/c-family/c-opts.c
++++ b/gcc/c-family/c-opts.c
+@@ -122,6 +122,9 @@ static int class_dump_flags;
+ /* Whether any standard preincluded header has been preincluded.  */
+ static bool done_preinclude;
+ 
++/* Check if a port honours COPTS.  */
++static int honour_copts = 0;
++
+ static void handle_OPT_d (const char *);
+ static void set_std_cxx98 (int);
+ static void set_std_cxx11 (int);
+@@ -449,6 +452,12 @@ c_common_handle_option (size_t scode, co
+       flag_no_builtin = !value;
+       break;
+ 
++    case OPT_fhonour_copts:
++      if (c_language == clk_c) {
++        honour_copts++;
++      }
++      break;
++
+     case OPT_fconstant_string_class_:
+       constant_string_class_name = arg;
+       break;
+@@ -1039,6 +1048,47 @@ c_common_init (void)
+       return false;
+     }
+ 
++  if (c_language == clk_c) {
++    char *ev = getenv ("GCC_HONOUR_COPTS");
++    int evv;
++    if (ev == NULL)
++      evv = -1;
++    else if ((*ev == '0') || (*ev == '\0'))
++      evv = 0;
++    else if (*ev == '1')
++      evv = 1;
++    else if (*ev == '2')
++      evv = 2;
++    else if (*ev == 's')
++      evv = -1;
++    else {
++      warning (0, "unknown GCC_HONOUR_COPTS value, assuming 1");
++      evv = 1; /* maybe depend this on something like MIRBSD_NATIVE?  */
++    }
++    if (evv == 1) {
++      if (honour_copts == 0) {
++        error ("someone does not honour COPTS at all in lenient mode");
++        return false;
++      } else if (honour_copts != 1) {
++        warning (0, "someone does not honour COPTS correctly, passed %d times",
++         honour_copts);
++      }
++    } else if (evv == 2) {
++      if (honour_copts == 0) {
++        error ("someone does not honour COPTS at all in strict mode");
++        return false;
++      } else if (honour_copts != 1) {
++        error ("someone does not honour COPTS correctly, passed %d times",
++         honour_copts);
++        return false;
++      }
++    } else if (evv == 0) {
++      if (honour_copts != 1)
++        inform (0, "someone does not honour COPTS correctly, passed %d times",
++         honour_copts);
++    }
++  }
++
+   return true;
+ }
+ 
+--- a/gcc/c-family/c.opt
++++ b/gcc/c-family/c.opt
+@@ -431,6 +431,10 @@ Wfloat-conversion
+ C ObjC C++ ObjC++ Var(warn_float_conversion) LangEnabledBy(C ObjC C++ ObjC++,Wconversion)
+ Warn for implicit type conversions that cause loss of floating point precision
+ 
++Werror-maybe-reset
++C ObjC C++ ObjC++
++; Documented in common.opt
++
+ Wfloat-equal
+ C ObjC C++ ObjC++ Var(warn_float_equal) Warning
+ Warn if testing floating point numbers for equality
+@@ -1161,6 +1165,9 @@ C++ ObjC++ Optimization Alias(fexception
+ fhonor-std
+ C++ ObjC++ Ignore Warn(switch %qs is no longer supported)
+ 
++fhonour-copts
++C ObjC C++ ObjC++ RejectNegative
++
+ fhosted
+ C ObjC
+ Assume normal C execution environment
+--- a/gcc/common.opt
++++ b/gcc/common.opt
+@@ -561,6 +561,10 @@ Werror=
+ Common Joined
+ Treat specified warning as error
+ 
++Werror-maybe-reset
++Common
++If environment variable GCC_NO_WERROR is set, act as -Wno-error
++
+ Wextra
+ Common Var(extra_warnings) Warning
+ Print extra (possibly unwanted) warnings
+@@ -1360,6 +1364,9 @@ fguess-branch-probability
+ Common Report Var(flag_guess_branch_prob) Optimization
+ Enable guessing of branch probabilities
+ 
++fhonour-copts
++Common RejectNegative
++
+ ; Nonzero means ignore `#ident' directives.  0 means handle them.
+ ; Generate position-independent code for executables if possible
+ ; On SVR4 targets, it also controls whether or not to emit a
+--- a/gcc/opts.c
++++ b/gcc/opts.c
+@@ -1699,6 +1699,17 @@ common_handle_option (struct gcc_options
+ 			       opts, opts_set, loc, dc);
+       break;
+ 
++    case OPT_Werror_maybe_reset:
++      {
++        char *ev = getenv ("GCC_NO_WERROR");
++        if ((ev != NULL) && (*ev != '0'))
++          warnings_are_errors = 0;
++      }
++      break;
++
++    case OPT_fhonour_copts:
++      break;
++
+     case OPT_Wlarger_than_:
+       opts->x_larger_than_size = value;
+       opts->x_warn_larger_than = value != -1;
+--- a/gcc/doc/cppopts.texi
++++ b/gcc/doc/cppopts.texi
+@@ -163,6 +163,11 @@ in older programs.  This warning is on b
+ Make all warnings into hard errors.  Source code which triggers warnings
+ will be rejected.
+ 
++@item -Werror-maybe-reset
++@opindex Werror-maybe-reset
++Act like @samp{-Wno-error} if the @env{GCC_NO_WERROR} environment
++variable is set to anything other than 0 or empty.
++
+ @item -Wsystem-headers
+ @opindex Wsystem-headers
+ Issue warnings for code in system headers.  These are normally unhelpful
+--- a/gcc/doc/invoke.texi
++++ b/gcc/doc/invoke.texi
+@@ -251,7 +251,7 @@ Objective-C and Objective-C++ Dialects}.
+ -Wdisabled-optimization @gol
+ -Wno-discarded-qualifiers -Wno-discarded-array-qualifiers @gol
+ -Wno-div-by-zero -Wdouble-promotion -Wempty-body  -Wenum-compare @gol
+--Wno-endif-labels -Werror  -Werror=* @gol
++-Wno-endif-labels -Werror  -Werror=* -Werror-maybe-reset @gol
+ -Wfatal-errors  -Wfloat-equal  -Wformat  -Wformat=2 @gol
+ -Wno-format-contains-nul -Wno-format-extra-args -Wformat-nonliteral @gol
+ -Wformat-security  -Wformat-signedness  -Wformat-y2k @gol
+@@ -5388,6 +5388,22 @@ This option is only supported for C and 
+ @option{-Wall} and by @option{-Wpedantic}, which can be disabled with
+ @option{-Wno-pointer-sign}.
+ 
++@item -Werror-maybe-reset
++@opindex Werror-maybe-reset
++Act like @samp{-Wno-error} if the @env{GCC_NO_WERROR} environment
++variable is set to anything other than 0 or empty.
++
++@item -fhonour-copts
++@opindex fhonour-copts
++If @env{GCC_HONOUR_COPTS} is set to 1, abort if this option is not
++given at least once, and warn if it is given more than once.
++If @env{GCC_HONOUR_COPTS} is set to 2, abort if this option is not
++given exactly once.
++If @env{GCC_HONOUR_COPTS} is set to 0 or unset, warn if this option
++is not given exactly once.
++The warning is quelled if @env{GCC_HONOUR_COPTS} is set to @samp{s}.
++This flag and environment variable only affect the C language.
++
+ @item -Wstack-protector
+ @opindex Wstack-protector
+ @opindex Wno-stack-protector
+@@ -7866,7 +7882,7 @@ so, the first branch is redirected to ei
+ second branch or a point immediately following it, depending on whether
+ the condition is known to be true or false.
+ 
+-Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.
++Enabled at levels @option{-O3}.
+ 
+ @item -fsplit-wide-types
+ @opindex fsplit-wide-types
+--- a/gcc/java/jvspec.c
++++ b/gcc/java/jvspec.c
+@@ -629,6 +629,7 @@ lang_specific_pre_link (void)
+      class name.  Append dummy `.c' that can be stripped by set_input so %b
+      is correct.  */ 
+   set_input (concat (main_class_name, "main.c", NULL));
++  putenv ("GCC_HONOUR_COPTS=s"); /* XXX hack!  */
+   err = do_spec (jvgenmain_spec);
+   if (err == 0)
+     {
diff --git a/toolchain/gcc/patches/5.5.0/920-specs_nonfatal_getenv.patch b/toolchain/gcc/patches/5.5.0/920-specs_nonfatal_getenv.patch
new file mode 100644
index 0000000000..4c705ad86b
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/920-specs_nonfatal_getenv.patch
@@ -0,0 +1,15 @@
+--- a/gcc/gcc.c
++++ b/gcc/gcc.c
+@@ -8828,8 +8828,10 @@ getenv_spec_function (int argc, const ch
+ 
+   value = getenv (argv[0]);
+   if (!value)
+-    fatal_error (input_location,
+-		 "environment variable %qs not defined", argv[0]);
++    {
++      warning (input_location, "environment variable %qs not defined", argv[0]);
++      value = "";
++    }
+ 
+   /* We have to escape every character of the environment variable so
+      they are not interpreted as active spec characters.  A
diff --git a/toolchain/gcc/patches/5.5.0/930-fix-mips-noexecstack.patch b/toolchain/gcc/patches/5.5.0/930-fix-mips-noexecstack.patch
new file mode 100644
index 0000000000..c05844d2e4
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/930-fix-mips-noexecstack.patch
@@ -0,0 +1,111 @@
+From da45b3fde60095756f5f6030f6012c23a3d34429 Mon Sep 17 00:00:00 2001
+From: Andrew McDonnell <bugs@andrewmcdonnell.net>
+Date: Fri, 3 Oct 2014 19:09:00 +0930
+Subject: Add .note.GNU-stack section
+
+See http://lists.busybox.net/pipermail/uclibc/2014-October/048671.html
+Below copied from https://gcc.gnu.org/ml/gcc-patches/2014-09/msg02430.html
+
+Re: [Patch, MIPS] Add .note.GNU-stack section
+
+    From: Steve Ellcey <sellcey at mips dot com>
+
+On Wed, 2014-09-10 at 10:15 -0700, Eric Christopher wrote:
+>
+>
+> On Wed, Sep 10, 2014 at 9:27 AM, <pinskia@gmail.com> wrote:
+
+>         This works except you did not update the assembly files in
+>         libgcc or glibc. We (Cavium) have the same patch in our tree
+>         for a few released versions.
+
+> Mind just checking yours in then Andrew?
+
+> Thanks!
+> -eric
+
+I talked to Andrew about what files he changed in GCC and created and
+tested this new patch.  Andrew also mentioned changing some assembly
+files in glibc but I don't see any use of '.section .note.GNU-stack' in
+any assembly files in glibc (for any platform) so I wasn't planning on
+creating a glibc to add them to mips glibc assembly language files.
+
+OK to check in this patch?
+
+Steve Ellcey
+sellcey@mips.com
+
+
+
+2014-09-26  Steve Ellcey  <sellcey@mips.com>
+---
+ gcc/config/mips/mips.c          | 3 +++
+ libgcc/config/mips/crti.S       | 4 ++++
+ libgcc/config/mips/crtn.S       | 3 +++
+ libgcc/config/mips/mips16.S     | 4 ++++
+ libgcc/config/mips/vr4120-div.S | 4 ++++
+ 5 files changed, 18 insertions(+)
+
+--- a/gcc/config/mips/mips.c
++++ b/gcc/config/mips/mips.c
+@@ -19629,6 +19629,9 @@ mips_lra_p (void)
+ #undef TARGET_LRA_P
+ #define TARGET_LRA_P mips_lra_p
+ 
++#undef TARGET_ASM_FILE_END
++#define TARGET_ASM_FILE_END file_end_indicate_exec_stack
++
+ struct gcc_target targetm = TARGET_INITIALIZER;
+ 
+ #include "gt-mips.h"
+--- a/libgcc/config/mips/crti.S
++++ b/libgcc/config/mips/crti.S
+@@ -21,6 +21,10 @@ a copy of the GCC Runtime Library Except
+ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+ <http://www.gnu.org/licenses/>.  */
+ 
++
++/* An executable stack is *not* required for these functions.  */
++	.section .note.GNU-stack,"",%progbits
++
+ /* 4 slots for argument spill area.  1 for cpreturn, 1 for stack.
+    Return spill offset of 40 and 20.  Aligned to 16 bytes for n32.  */
+ 
+--- a/libgcc/config/mips/crtn.S
++++ b/libgcc/config/mips/crtn.S
+@@ -21,6 +21,9 @@ a copy of the GCC Runtime Library Except
+ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+ <http://www.gnu.org/licenses/>.  */
+ 
++/* An executable stack is *not* required for these functions.  */
++	.section .note.GNU-stack,"",%progbits
++
+ /* 4 slots for argument spill area.  1 for cpreturn, 1 for stack.
+    Return spill offset of 40 and 20.  Aligned to 16 bytes for n32.  */
+ 
+--- a/libgcc/config/mips/mips16.S
++++ b/libgcc/config/mips/mips16.S
+@@ -48,6 +48,10 @@ see the files COPYING3 and COPYING.RUNTI
+    values using the soft-float calling convention, but do the actual
+    operation using the hard floating point instructions.  */
+ 
++/* An executable stack is *not* required for these functions.  */
++	.section .note.GNU-stack,"",%progbits
++	.previous
++
+ #if defined _MIPS_SIM && (_MIPS_SIM == _ABIO32 || _MIPS_SIM == _ABIO64)
+ 
+ /* This file contains 32-bit assembly code.  */
+--- a/libgcc/config/mips/vr4120-div.S
++++ b/libgcc/config/mips/vr4120-div.S
+@@ -26,6 +26,10 @@ see the files COPYING3 and COPYING.RUNTI
+    -mfix-vr4120.  div and ddiv do not give the correct result when one
+    of the operands is negative.  */
+ 
++/* An executable stack is *not* required for these functions.  */
++	.section .note.GNU-stack,"",%progbits
++	.previous
++
+ 	.set	nomips16
+ 
+ #define DIV								\
diff --git a/toolchain/gcc/patches/5.5.0/931-fix-MIPS-softfloat-build-issue.patch b/toolchain/gcc/patches/5.5.0/931-fix-MIPS-softfloat-build-issue.patch
new file mode 100644
index 0000000000..9ac0939eb0
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/931-fix-MIPS-softfloat-build-issue.patch
@@ -0,0 +1,167 @@
+From 2b46f9187b6f994fc450628a7cd97fc703dd23e0 Mon Sep 17 00:00:00 2001
+From: BangLang Huang <banglang.huang@foxmail.com>
+Date: Wed, 9 Nov 2016 10:36:49 +0800
+Subject: [PATCH] fix MIPS softfloat build issue
+
+    This patch is backport from github/libffi #272
+
+Signed-off-by: BangLang Huang <banglang.huang@foxmail.com>
+---
+ libffi/src/mips/n32.S | 17 +++++++++++++++++
+ libffi/src/mips/o32.S | 17 +++++++++++++++++
+ 2 files changed, 34 insertions(+)
+
+--- a/libffi/src/mips/n32.S
++++ b/libffi/src/mips/n32.S
+@@ -107,6 +107,16 @@ loadregs:	
+ 
+ 	REG_L	t6, 3*FFI_SIZEOF_ARG($fp)  # load the flags word into t6.
+ 
++#ifdef __mips_soft_float
++	REG_L	a0, 0*FFI_SIZEOF_ARG(t9)
++	REG_L	a1, 1*FFI_SIZEOF_ARG(t9)
++	REG_L	a2, 2*FFI_SIZEOF_ARG(t9)
++	REG_L	a3, 3*FFI_SIZEOF_ARG(t9)
++	REG_L	a4, 4*FFI_SIZEOF_ARG(t9)
++	REG_L	a5, 5*FFI_SIZEOF_ARG(t9)
++	REG_L	a6, 6*FFI_SIZEOF_ARG(t9)
++	REG_L	a7, 7*FFI_SIZEOF_ARG(t9)
++#else
+ 	and	t4, t6, ((1<<FFI_FLAG_BITS)-1)
+ 	REG_L	a0, 0*FFI_SIZEOF_ARG(t9)
+ 	beqz	t4, arg1_next
+@@ -193,6 +203,7 @@ arg7_next:	
+ arg8_doublep:	
+  	l.d	$f19, 7*FFI_SIZEOF_ARG(t9)	
+ arg8_next:	
++#endif
+ 
+ callit:		
+ 	# Load the function pointer
+@@ -214,6 +225,7 @@ retint:
+ 	b	epilogue
+ 
+ retfloat:
++#ifndef __mips_soft_float
+ 	bne     t6, FFI_TYPE_FLOAT, retdouble
+ 	jal	t9
+ 	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+@@ -272,6 +284,7 @@ retstruct_f_d:	
+ 	s.s	$f0, 0(t4)
+ 	s.d	$f2, 8(t4)
+ 	b	epilogue
++#endif
+ 
+ retstruct_d_soft:
+ 	bne	t6, FFI_TYPE_STRUCT_D_SOFT, retstruct_f_soft
+@@ -429,6 +442,7 @@ ffi_closure_N32:
+ 	REG_S	a6, A6_OFF2($sp)
+ 	REG_S	a7, A7_OFF2($sp)
+ 
++#ifndef __mips_soft_float
+ 	# Store all possible float/double registers.
+ 	s.d	$f12, F12_OFF2($sp)
+ 	s.d	$f13, F13_OFF2($sp)
+@@ -438,6 +452,7 @@ ffi_closure_N32:
+ 	s.d	$f17, F17_OFF2($sp)
+ 	s.d	$f18, F18_OFF2($sp)
+ 	s.d	$f19, F19_OFF2($sp)
++#endif
+ 
+ 	# Call ffi_closure_mips_inner_N32 to do the real work.
+ 	LA	t9, ffi_closure_mips_inner_N32
+@@ -458,6 +473,7 @@ cls_retint:
+ 	b	cls_epilogue
+ 
+ cls_retfloat:
++#ifndef __mips_soft_float
+ 	bne     v0, FFI_TYPE_FLOAT, cls_retdouble
+ 	l.s	$f0, V0_OFF2($sp)
+ 	b	cls_epilogue
+@@ -500,6 +516,7 @@ cls_retstruct_f_d:	
+ 	l.s	$f0, V0_OFF2($sp)
+ 	l.d	$f2, V1_OFF2($sp)
+ 	b	cls_epilogue
++#endif
+ 	
+ cls_retstruct_small2:	
+ 	REG_L	v0, V0_OFF2($sp)
+--- a/libffi/src/mips/o32.S
++++ b/libffi/src/mips/o32.S
+@@ -82,13 +82,16 @@ sixteen:
+ 		
+ 	ADDU	$sp, 4 * FFI_SIZEOF_ARG		# adjust $sp to new args
+ 
++#ifndef __mips_soft_float
+ 	bnez	t0, pass_d			# make it quick for int
++#endif
+ 	REG_L	a0, 0*FFI_SIZEOF_ARG($sp)	# just go ahead and load the
+ 	REG_L	a1, 1*FFI_SIZEOF_ARG($sp)	# four regs.
+ 	REG_L	a2, 2*FFI_SIZEOF_ARG($sp)
+ 	REG_L	a3, 3*FFI_SIZEOF_ARG($sp)
+ 	b	call_it
+ 
++#ifndef __mips_soft_float
+ pass_d:
+ 	bne	t0, FFI_ARGS_D, pass_f
+ 	l.d	$f12, 0*FFI_SIZEOF_ARG($sp)	# load $fp regs from args
+@@ -130,6 +133,7 @@ pass_f_d:		
+  #	bne	t0, FFI_ARGS_F_D, call_it
+ 	l.s	$f12, 0*FFI_SIZEOF_ARG($sp)	# load $fp regs from args
+ 	l.d	$f14, 2*FFI_SIZEOF_ARG($sp)	# passing double and float
++#endif
+ 
+ call_it:	
+ 	# Load the function pointer
+@@ -158,14 +162,23 @@ retfloat:
+ 	bne     t2, FFI_TYPE_FLOAT, retdouble
+ 	jalr	t9
+ 	REG_L	t0, SIZEOF_FRAME + 4*FFI_SIZEOF_ARG($fp)
++#ifndef __mips_soft_float
+ 	s.s	$f0, 0(t0)
++#else
++	REG_S v0, 0(t0)
++#endif
+ 	b	epilogue
+ 
+ retdouble:	
+ 	bne	t2, FFI_TYPE_DOUBLE, noretval
+ 	jalr	t9
+ 	REG_L	t0, SIZEOF_FRAME + 4*FFI_SIZEOF_ARG($fp)
++#ifndef __mips_soft_float
+ 	s.d	$f0, 0(t0)
++#else
++	REG_S v1, 4(t0)
++	REG_S v0, 0(t0)
++#endif
+ 	b	epilogue
+ 	
+ noretval:	
+@@ -261,9 +274,11 @@ $LCFI7:
+ 	li	$13, 1		# FFI_O32
+ 	bne	$16, $13, 1f	# Skip fp save if FFI_O32_SOFT_FLOAT
+ 	
++#ifndef __mips_soft_float
+ 	# Store all possible float/double registers.
+ 	s.d	$f12, FA_0_0_OFF2($fp)
+ 	s.d	$f14, FA_1_0_OFF2($fp)
++#endif
+ 1:	
+ 	# Call ffi_closure_mips_inner_O32 to do the work.
+ 	la	t9, ffi_closure_mips_inner_O32
+@@ -281,6 +296,7 @@ $LCFI7:
+ 	li	$13, 1		# FFI_O32
+ 	bne	$16, $13, 1f	# Skip fp restore if FFI_O32_SOFT_FLOAT
+ 
++#ifndef __mips_soft_float
+ 	li	$9, FFI_TYPE_FLOAT
+ 	l.s	$f0, V0_OFF2($fp)
+ 	beq	$8, $9, closure_done
+@@ -288,6 +304,7 @@ $LCFI7:
+ 	li	$9, FFI_TYPE_DOUBLE
+ 	l.d	$f0, V0_OFF2($fp)
+ 	beq	$8, $9, closure_done
++#endif
+ 1:	
+ 	REG_L	$3, V1_OFF2($fp)
+ 	REG_L	$2, V0_OFF2($fp)
diff --git a/toolchain/gcc/patches/5.5.0/940-no-clobber-stamp-bits.patch b/toolchain/gcc/patches/5.5.0/940-no-clobber-stamp-bits.patch
new file mode 100644
index 0000000000..21463a3055
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/940-no-clobber-stamp-bits.patch
@@ -0,0 +1,11 @@
+--- a/libstdc++-v3/include/Makefile.in
++++ b/libstdc++-v3/include/Makefile.in
+@@ -1422,7 +1422,7 @@ stamp-bits: ${bits_headers}
+ 	@$(STAMP) stamp-bits
+ 
+ stamp-bits-sup: stamp-bits ${bits_sup_headers}
+-	@-cd ${bits_builddir} && $(LN_S) $? . 2>/dev/null
++	@-cd ${bits_builddir} && $(LN_S) $(filter-out stamp-bits,$?) . 2>/dev/null
+ 	@$(STAMP) stamp-bits-sup
+ 
+ stamp-c_base: ${c_base_headers}
diff --git a/toolchain/gcc/patches/5.5.0/950-cpp_file_path_translation.patch b/toolchain/gcc/patches/5.5.0/950-cpp_file_path_translation.patch
new file mode 100644
index 0000000000..b67940897e
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/950-cpp_file_path_translation.patch
@@ -0,0 +1,182 @@
+Forward ported from attachment to https://gcc.gnu.org/bugzilla/show_bug.cgi?id=47047
+
+--- a/gcc/c-family/c-opts.c
++++ b/gcc/c-family/c-opts.c
+@@ -581,6 +581,10 @@ c_common_handle_option (size_t scode, co
+       add_path (xstrdup (arg), SYSTEM, 0, true);
+       break;
+ 
++    case OPT_iremap:
++      add_cpp_remap_path (arg);
++      break;
++
+     case OPT_iwithprefix:
+       add_prefixed_path (arg, SYSTEM);
+       break;
+--- a/gcc/c-family/c.opt
++++ b/gcc/c-family/c.opt
+@@ -1528,6 +1528,10 @@ iquote
+ C ObjC C++ ObjC++ Joined Separate MissingArgError(missing path after %qs)
+ -iquote <dir>	Add <dir> to the end of the quote include path
+ 
++iremap
++C ObjC C++ ObjC++ Joined Separate
++-iremap <src:dst>  Convert <src> to <dst> if it occurs as prefix in __FILE__.
++
+ iwithprefix
+ C ObjC C++ ObjC++ Joined Separate
+ -iwithprefix <dir>	Add <dir> to the end of the system include path
+--- a/gcc/doc/cpp.texi
++++ b/gcc/doc/cpp.texi
+@@ -4441,6 +4441,7 @@ without notice.
+ @c man begin SYNOPSIS
+ cpp [@option{-D}@var{macro}[=@var{defn}]@dots{}] [@option{-U}@var{macro}]
+     [@option{-I}@var{dir}@dots{}] [@option{-iquote}@var{dir}@dots{}]
++    [@option{-iremap}@var{src}:@var{dst}]
+     [@option{-W}@var{warn}@dots{}]
+     [@option{-M}|@option{-MM}] [@option{-MG}] [@option{-MF} @var{filename}]
+     [@option{-MP}] [@option{-MQ} @var{target}@dots{}]
+--- a/gcc/doc/cppopts.texi
++++ b/gcc/doc/cppopts.texi
+@@ -532,6 +532,12 @@ Search @var{dir} only for header files r
+ If @var{dir} begins with @code{=}, then the @code{=} will be replaced
+ by the sysroot prefix; see @option{--sysroot} and @option{-isysroot}.
+ 
++@item -iremap @var{src}:@var{dst}
++@opindex iremap
++Replace the prefix @var{src} in __FILE__ with @var{dst} at expansion time.
++This option can be specified more than once.  Processing stops at the first
++match.
++
+ @item -fdirectives-only
+ @opindex fdirectives-only
+ When preprocessing, handle directives, but do not expand macros.
+--- a/gcc/doc/invoke.texi
++++ b/gcc/doc/invoke.texi
+@@ -494,8 +494,8 @@ Objective-C and Objective-C++ Dialects}.
+ @item Directory Options
+ @xref{Directory Options,,Options for Directory Search}.
+ @gccoptlist{-B@var{prefix} -I@var{dir} -iplugindir=@var{dir} @gol
+--iquote@var{dir} -L@var{dir} -specs=@var{file} -I- @gol
+---sysroot=@var{dir} --no-sysroot-suffix}
++-iquote@var{dir} -iremap@var{src}:@var{dst} -L@var{dir} -specs=@var{file} @gol
++-I- --sysroot=@var{dir} --no-sysroot-suffix}
+ 
+ @item Machine Dependent Options
+ @xref{Submodel Options,,Hardware Models and Configurations}.
+@@ -11485,6 +11485,12 @@ be searched for header files only for th
+ "@var{file}"}; they are not searched for @code{#include <@var{file}>},
+ otherwise just like @option{-I}.
+ 
++@item -iremap @var{src}:@var{dst}
++@opindex iremap
++Replace the prefix @var{src} in __FILE__ with @var{dst} at expansion time.
++This option can be specified more than once.  Processing stops at the first
++match.
++
+ @item -L@var{dir}
+ @opindex L
+ Add directory @var{dir} to the list of directories to be searched
+--- a/libcpp/include/cpplib.h
++++ b/libcpp/include/cpplib.h
+@@ -751,6 +751,9 @@ extern void cpp_set_lang (cpp_reader *, 
+ /* Set the include paths.  */
+ extern void cpp_set_include_chains (cpp_reader *, cpp_dir *, cpp_dir *, int);
+ 
++/* Provide src:dst pair for __FILE__ remapping.  */
++extern void add_cpp_remap_path (const char *);
++
+ /* Call these to get pointers to the options, callback, and deps
+    structures for a given reader.  These pointers are good until you
+    call cpp_finish on that reader.  You can either edit the callbacks
+--- a/libcpp/macro.c
++++ b/libcpp/macro.c
+@@ -224,6 +224,64 @@ static const char * const monthnames[] =
+   "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
+ };
+ 
++static size_t remap_pairs;
++static char **remap_src;
++static char **remap_dst;
++
++void
++add_cpp_remap_path (const char *arg)
++{
++  const char *arg_dst;
++  size_t len;
++
++  arg_dst = strchr(arg, ':');
++  if (arg_dst == NULL)
++    {
++      fprintf(stderr, "Invalid argument for -iremap\n");
++      exit(1);
++    }
++
++  len = arg_dst - arg;
++  ++arg_dst;
++
++  remap_src = (char **) xrealloc(remap_src, sizeof(char *) * (remap_pairs + 1));
++  remap_dst = (char **) xrealloc(remap_dst, sizeof(char *) * (remap_pairs + 1));
++
++  remap_src[remap_pairs] = (char *) xmalloc(len + 1);
++  memcpy(remap_src[remap_pairs], arg, len);
++  remap_src[remap_pairs][len] = '\0';
++  remap_dst[remap_pairs] = xstrdup(arg_dst);
++  ++remap_pairs;
++}
++
++static const char *
++cpp_remap_file (const char *arg, char **tmp_name)
++{
++  char *result;
++  size_t i, len;
++
++  for (i = 0; i < remap_pairs; ++i)
++    {
++      len = strlen (remap_src[i]);
++      if (strncmp (remap_src[i], arg, len))
++	continue;
++      if (arg[len] == '\0')
++	return xstrdup (remap_dst[i]);
++      if (arg[len] != '/')
++	continue;
++      arg += len;
++      len = strlen (remap_dst[i]);
++      result = (char *) xmalloc (len + strlen (arg) + 1);
++      memcpy(result, remap_dst[i], len);
++      strcpy(result + len, arg);
++      *tmp_name = result;
++
++      return result;
++    }
++
++   return arg;
++}
++
+ /* Helper function for builtin_macro.  Returns the text generated by
+    a builtin macro. */
+ const uchar *
+@@ -286,6 +344,7 @@ _cpp_builtin_macro_text (cpp_reader *pfi
+       {
+ 	unsigned int len;
+ 	const char *name;
++	char *tmp_name = NULL;
+ 	uchar *buf;
+ 	
+ 	if (node->value.builtin == BT_FILE)
+@@ -297,6 +356,7 @@ _cpp_builtin_macro_text (cpp_reader *pfi
+ 	    if (!name)
+ 	      abort ();
+ 	  }
++	name = cpp_remap_file (name, &tmp_name);
+ 	len = strlen (name);
+ 	buf = _cpp_unaligned_alloc (pfile, len * 2 + 3);
+ 	result = buf;
+@@ -304,6 +364,7 @@ _cpp_builtin_macro_text (cpp_reader *pfi
+ 	buf = cpp_quote_string (buf + 1, (const unsigned char *) name, len);
+ 	*buf++ = '"';
+ 	*buf = '\0';
++	free (tmp_name);
+       }
+       break;
+ 
diff --git a/toolchain/gcc/patches/5.5.0/960-go_libm.patch b/toolchain/gcc/patches/5.5.0/960-go_libm.patch
new file mode 100644
index 0000000000..d16b0200c0
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/960-go_libm.patch
@@ -0,0 +1,11 @@
+--- a/gcc/go/Make-lang.in
++++ b/gcc/go/Make-lang.in
+@@ -74,7 +74,7 @@ go_OBJS = $(GO_OBJS) go/gospec.o
+ 
+ go1$(exeext): $(GO_OBJS) attribs.o $(BACKEND) $(LIBDEPS)
+ 	+$(LLINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \
+-	      $(GO_OBJS) attribs.o $(BACKEND) $(LIBS) $(BACKENDLIBS)
++	      $(GO_OBJS) attribs.o $(BACKEND) $(LIBS) $(BACKENDLIBS) -lm
+ 
+ # Documentation.
+ 
diff --git a/toolchain/gcc/patches/5.5.0/970-warn_bug.patch b/toolchain/gcc/patches/5.5.0/970-warn_bug.patch
new file mode 100644
index 0000000000..2c5cf9be20
--- /dev/null
+++ b/toolchain/gcc/patches/5.5.0/970-warn_bug.patch
@@ -0,0 +1,11 @@
+--- a/libgo/runtime/mprof.goc
++++ b/libgo/runtime/mprof.goc
+@@ -403,7 +403,7 @@ func ThreadCreateProfile(p Slice) (n int
+ 
+ func Stack(b Slice, all bool) (n int) {
+ 	byte *pc, *sp;
+-	bool enablegc;
++	bool enablegc = false; /* workaround GCC bug #36550 */
+ 	
+ 	sp = runtime_getcallersp(&b);
+ 	pc = (byte*)(uintptr)runtime_getcallerpc(&b);
-- 
2.25.1

